var completions = [
{name: "contr", value: "contr", meta: "Π {A : Type} (C : Contr A) (y : A), path (center C) y"},
{name: "trunc_index", value: "trunc_index", meta: "Type"},
{name: "minus_one", value: "minus_one", meta: "trunc_index"},
{name: "Contr", value: "Contr", meta: "Type → Type"},
{name: "Contr.Contr_mk", value: "Contr.Contr_mk", meta: "Π {A : Type} (center : A), (Π (y : A), path center y) → Contr A"},
{name: "Contr.rec", value: "Contr.rec", meta: "Π {A : Type} {C : Contr A → Type}, (Π (center : A) (contr : Π (y : A), path center y), C (Contr.Contr_mk center contr)) → (Π (n : Contr A), C n)"},
{name: "IsHSet", value: "IsHSet", meta: "Type → Type"},
{name: "IsHProp", value: "IsHProp", meta: "Type → Type"},
{name: "trunc_index.trunc_S", value: "trunc_index.trunc_S", meta: "trunc_index → trunc_index"},
{name: "center", value: "center", meta: "Π {A : Type}, Contr A → A"},
{name: "trunc_index.rec", value: "trunc_index.rec", meta: "Π {C : trunc_index → Type}, C trunc_index.minus_two → (Π (a : trunc_index), C a → C (trunc_index.trunc_S a)) → (Π (n : trunc_index), C n)"},
{name: "trunc_index.minus_two", value: "trunc_index.minus_two", meta: "trunc_index"},
{name: "IsTrunc", value: "IsTrunc", meta: "trunc_index → Type → Type"},
{name: "equiv_inv", value: "equiv_inv", meta: "Π {A : Type} {B : Type} {f : A → B}, IsEquiv f → B → A"},
{name: "equiv_fun", value: "equiv_fun", meta: "Π {A : Type} {B : Type}, Equiv A B → A → B"},
{name: "eissect", value: "eissect", meta: "Π {A : Type} {B : Type} {f : A → B} (H : IsEquiv f), Sect f (equiv_inv H)"},
{name: "Equiv.Equiv_mk", value: "Equiv.Equiv_mk", meta: "Π {A : Type} {B : Type} (equiv_fun : A → B), IsEquiv equiv_fun → Equiv A B"},
{name: "eisadj", value: "eisadj", meta: "Π {A : Type} {B : Type} {f : A → B} (H : IsEquiv f) (x : A), path (eisretr H (f x)) (ap f (eissect H x))"},
{name: "equiv_isequiv", value: "equiv_isequiv", meta: "Π {A : Type} {B : Type} (e : Equiv A B), IsEquiv e"},
{name: "IsEquiv.rec", value: "IsEquiv.rec", meta: "Π {A : Type} {B : Type} {f : A → B} {C : IsEquiv f → Type}, (Π (equiv_inv : B → A) (eisretr : Sect equiv_inv f) (eissect : Sect f equiv_inv) (eisadj : Π (x : A), path (eisretr (f x)) (ap f (eissect x))), C (IsEquiv.IsEquiv_mk equiv_inv eisretr eissect eisadj)) → (Π (n : IsEquiv f), C n)"},
{name: "Equiv", value: "Equiv", meta: "Type → Type → Type"},
{name: "Sect", value: "Sect", meta: "Π {A : Type} {B : Type}, (A → B) → (B → A) → Type"},
{name: "Equiv.rec", value: "Equiv.rec", meta: "Π {A : Type} {B : Type} {C : Equiv A B → Type}, (Π (equiv_fun : A → B) (equiv_isequiv : IsEquiv equiv_fun), C (Equiv.Equiv_mk equiv_fun equiv_isequiv)) → (Π (n : Equiv A B), C n)"},
{name: "eisretr", value: "eisretr", meta: "Π {A : Type} {B : Type} {f : A → B} (H : IsEquiv f), Sect (equiv_inv H) f"},
{name: "IsEquiv.IsEquiv_mk", value: "IsEquiv.IsEquiv_mk", meta: "Π {A : Type} {B : Type} {f : A → B} (equiv_inv : B → A) (eisretr : Sect equiv_inv f) (eissect : Sect f equiv_inv), (Π (x : A), path (eisretr (f x)) (ap f (eissect x))) → IsEquiv f"},
{name: "IsEquiv", value: "IsEquiv", meta: "Π {A : Type} {B : Type}, (A → B) → Type"},
{name: "path.whiskerL", value: "path.whiskerL", meta: "Π {A : Type} {x y z : A} (p : path x y) {q r : path y z}, path q r → path (path.concat p q) (path.concat p r)"},
{name: "path.induction_on", value: "path.induction_on", meta: "Π {A : Type} {a b : A} (p : path a b) {C : Π (b : A), path a b → Type}, C a (path.idpath a) → C b p"},
{name: "path.ap", value: "path.ap", meta: "Π ⦃A : Type⦄ ⦃B : Type⦄ (f : A → B) {x y : A}, path x y → path (f x) (f y)"},
{name: "path", value: "path", meta: "Π {A : Type}, A → A → Type"},
{name: "path.apD10", value: "path.apD10", meta: "Π {A : Type} {B : A → Type} {f g : Π (x : A), B x}, path f g → path.pointwise_paths f g"},
{name: "path.concat_concat2", value: "path.concat_concat2", meta: "Π {A : Type} {x y z : A} {p p' p'' : path x y} {q q' q'' : path y z} (a : path p p') (b : path p' p'') (c : path q q') (d : path q' q''), path (path.concat (path.concat2 a c) (path.concat2 b d)) (path.concat2 (path.concat a b) (path.concat c d))"},
{name: "path.concat_pA1_p", value: "path.concat_pA1_p", meta: "Π {A : Type} {f : A → A} (p : Π (x : A), path (f x) x) {x y : A} (q : path x y) {w : A} (r : path w (f x)), path (path.concat (path.concat r (path.ap f q)) (p y)) (path.concat (path.concat r (p x)) q)"},
{name: "path.transport_pVp", value: "path.transport_pVp", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path x y) (z : P x), path (path.transport_pV P p (path.transport P p z)) (path.ap (path.transport P p) (path.transport_Vp P p z))"},
{name: "path.concat_pA1", value: "path.concat_pA1", meta: "Π {A : Type} {f : A → A} (p : Π (x : A), path x (f x)) {x y : A} (q : path x y), path (path.concat (p x) (path.ap f q)) (path.concat q (p y))"},
{name: "path.concat_pA_pp", value: "path.concat_pA_pp", meta: "Π {A : Type} {B : Type} {f g : A → B} (p : Π (x : A), path (f x) (g x)) {x y : A} (q : path x y) {w z : B} (r : path w (f x)) (s : path (g y) z), path (path.concat (path.concat r (path.ap f q)) (path.concat (p y) s)) (path.concat (path.concat r (p x)) (path.concat (path.ap g q) s))"},
{name: "path.inverse2", value: "path.inverse2", meta: "Π {A : Type} {x y : A} {p q : path x y}, path p q → path (path.inverse p) (path.inverse q)"},
{name: "path.moveL_Mp", value: "path.moveL_Mp", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path y x), path (path.concat (path.inverse r) q) p → path q (path.concat r p)"},
{name: "path.ap_transport", value: "path.ap_transport", meta: "Π {A : Type} {P : A → Type} {Q : A → Type} {x y : A} (p : path x y) (f : Π (x : A), P x → Q x) (z : P x), path (f y (path.transport (λ (x : A), P x) p z)) (path.transport (λ (x : A), Q x) p (f x z))"},
{name: "path.moveR_1V", value: "path.moveR_1V", meta: "Π {A : Type} {x y : A} (p : path x y) (q : path y x), path path.idp (path.concat q p) → path (path.inverse p) q"},
{name: "path.ap02_pp", value: "path.ap02_pp", meta: "Π {A : Type} {B : Type} (f : A → B) {x y : A} {p p' p'' : path x y} (r : path p p') (r' : path p' p''), path (path.ap02 f (path.concat r r')) (path.concat (path.ap02 f r) (path.ap02 f r'))"},
{name: "path.whiskerR_p1", value: "path.whiskerR_p1", meta: "Π {A : Type} {x y : A} {p q : path x y} (h : path p q), path (path.concat (path.concat (path.inverse (path.concat_p1 p)) (path.whiskerR h path.idp)) (path.concat_p1 q)) h"},
{name: "path.ap_pp", value: "path.ap_pp", meta: "Π {A : Type} {B : Type} (f : A → B) {x y z : A} (p : path x y) (q : path y z), path (path.ap f (path.concat p q)) (path.concat (path.ap f p) (path.ap f q))"},
{name: "path.concat_pp_p", value: "path.concat_pp_p", meta: "Π {A : Type} {x y z t : A} (p : path x y) (q : path y z) (r : path z t), path (path.concat (path.concat p q) r) (path.concat p (path.concat q r))"},
{name: "path.concat", value: "path.concat", meta: "Π {A : Type} {x y z : A}, path x y → path y z → path x z"},
{name: "path.transport2", value: "path.transport2", meta: "Π {A : Type} (P : A → Type) {x y : A} {p q : path x y}, path p q → (Π (z : P x), path (path.transport (λ (x : A), P x) p z) (path.transport (λ (x : A), P x) q z))"},
{name: "path.ap_1", value: "path.ap_1", meta: "Π {A : Type} {B : Type} (x : A) (f : A → B), path (path.ap f path.idp) path.idp"},
{name: "path.concat_p_pp", value: "path.concat_p_pp", meta: "Π {A : Type} {x y z t : A} (p : path x y) (q : path y z) (r : path z t), path (path.concat p (path.concat q r)) (path.concat (path.concat p q) r)"},
{name: "path.apD_1", value: "path.apD_1", meta: "Π {A : Type} {B : A → Type} (x : A) (f : Π (x : A), B x), path (path.apD f path.idp) path.idp"},
{name: "path.ap_compose", value: "path.ap_compose", meta: "Π {A : Type} {B : Type} {C : Type} (f : A → B) (g : B → C) {x y : A} (p : path x y), path (path.ap (compose g f) p) (path.ap g (path.ap f p))"},
{name: "path.whiskerL_1p", value: "path.whiskerL_1p", meta: "Π {A : Type} {x y : A} {p q : path x y} (h : path p q), path (path.concat (path.concat (path.inverse (path.concat_1p p)) (path.whiskerL path.idp h)) (path.concat_1p q)) h"},
{name: "path.transport_pV", value: "path.transport_pV", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path x y) (z : P y), path (path.transport (λ (x : A), P x) p (path.transport (λ (x : A), P x) (path.inverse p) z)) z"},
{name: "path.moveL_V1", value: "path.moveL_V1", meta: "Π {A : Type} {x y : A} (p : path x y) (q : path y x), path (path.concat q p) path.idp → path p (path.inverse q)"},
{name: "path.concat_pA1_pp", value: "path.concat_pA1_pp", meta: "Π {A : Type} {f : A → A} (p : Π (x : A), path (f x) x) {x y : A} (q : path x y) {w z : A} (r : path w (f x)) (s : path y z), path (path.concat (path.concat r (path.ap f q)) (path.concat (p y) s)) (path.concat (path.concat r (p x)) (path.concat q s))"},
{name: "path.concat_A1_pp", value: "path.concat_A1_pp", meta: "Π {A : Type} {f : A → A} (p : Π (x : A), path (f x) x) {x y : A} (q : path x y) {z : A} (s : path y z), path (path.concat (path.ap f q) (path.concat (p y) s)) (path.concat (p x) (path.concat q s))"},
{name: "path.cancelR", value: "path.cancelR", meta: "Π {A : Type} {x y z : A} (p q : path x y) (r : path y z), path (path.concat p r) (path.concat q r) → path p q"},
{name: "path.inv_VV", value: "path.inv_VV", meta: "Π {A : Type} {x y z : A} (p : path y x) (q : path z y), path (path.inverse (path.concat (path.inverse p) (path.inverse q))) (path.concat q p)"},
{name: "path.inverse", value: "path.inverse", meta: "Π {A : Type} {x y : A}, path x y → path y x"},
{name: "path.concat_pA_p", value: "path.concat_pA_p", meta: "Π {A : Type} {B : Type} {f g : A → B} (p : Π (x : A), path (f x) (g x)) {x y : A} (q : path x y) {w : B} (r : path w (f x)), path (path.concat (path.concat r (path.ap f q)) (p y)) (path.concat (path.concat r (p x)) (path.ap g q))"},
{name: "path.ap_const", value: "path.ap_const", meta: "Π {A : Type} {B : Type} {x y : A} (p : path x y) (z : B), path (path.ap (λ (u : A), z) p) path.idp"},
{name: "path.moveL_transport_p", value: "path.moveL_transport_p", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path y x) (u : P x) (v : P y), path (path.transport (λ (x : A), P x) (path.inverse p) u) v → path u (path.transport (λ (x : A), P x) p v)"},
{name: "path.transport2_const", value: "path.transport2_const", meta: "Π {A : Type} {B : Type} {x1 x2 : A} {p q : path x1 x2} (r : path p q) (y : B), path (path.transport_const p y) (path.concat (path.transport2 (λ (x : A), B) r y) (path.transport_const q y))"},
{name: "path.concat_AT", value: "path.concat_AT", meta: "Π {A : Type} (P : A → Type) {x y : A} {p q : path x y} {z w : P x} (r : path p q) (s : path z w), path (path.concat (path.ap (path.transport P p) s) (path.transport2 P r w)) (path.concat (path.transport2 P r z) (path.ap (path.transport P q) s))"},
{name: "path.concat2_p1", value: "path.concat2_p1", meta: "Π {A : Type} {x y : A} {p q : path x y} (h : path p q), path (path.concat2 h path.idp) (path.whiskerR h path.idp)"},
{name: "path.transport_idmap_ap", value: "path.transport_idmap_ap", meta: "Π (A : Type) (P : A → Type) (x y : A) (p : path x y) (u : P x), path (path.transport P p u) (path.transport (λ (z : Type), z) (path.ap P p) u)"},
{name: "path.apD10_V", value: "path.apD10_V", meta: "Π {A : Type} {B : A → Type} {f g : Π (x : A), B x} (h : path f g) (x : A), path (path.apD10 (path.inverse h) x) (path.inverse (path.apD10 h x))"},
{name: "path.concat_pV_p", value: "path.concat_pV_p", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z), path (path.concat (path.concat p (path.inverse q)) q) p"},
{name: "path.cancelL", value: "path.cancelL", meta: "Π {A : Type} {x y z : A} (p : path x y) (q r : path y z), path (path.concat p q) (path.concat p r) → path q r"},
{name: "path.moveR_transport_p", value: "path.moveR_transport_p", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path x y) (u : P x) (v : P y), path u (path.transport (λ (x : A), P x) (path.inverse p) v) → path (path.transport (λ (x : A), P x) p u) v"},
{name: "path.inv_pp", value: "path.inv_pp", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.inverse (path.concat p q)) (path.concat (path.inverse q) (path.inverse p))"},
{name: "path.transport_pp", value: "path.transport_pp", meta: "Π {A : Type} (P : A → Type) {x y z : A} (p : path x y) (q : path y z) (u : P x), path (path.transport (λ (x : A), P x) (path.concat p q) u) (path.transport (λ (x : A), P x) q (path.transport (λ (x : A), P x) p u))"},
{name: "path.moveL_1M", value: "path.moveL_1M", meta: "Π {A : Type} {x y : A} (p q : path x y), path (path.concat p (path.inverse q)) path.idp → path p q"},
{name: "path.transport_compose", value: "path.transport_compose", meta: "Π {A : Type} {B : Type} {x y : A} (P : B → Type) (f : A → B) (p : path x y) (z : P (f x)), path (path.transport (λ (x : A), P (f x)) p z) (path.transport P (path.ap f p) z)"},
{name: "path.ap10", value: "path.ap10", meta: "Π {A : Type} {B : Type} {f g : A → B}, path f g → path.pointwise_paths f g"},
{name: "path.transport_1", value: "path.transport_1", meta: "Π {A : Type} (P : A → Type) {x : A} (u : P x), path (path.transport (λ (x : Type), x) path.idp u) u"},
{name: "path.transport2_p2p", value: "path.transport2_p2p", meta: "Π {A : Type} (P : A → Type) {x y : A} {p1 p2 p3 : path x y} (r1 : path p1 p2) (r2 : path p2 p3) (z : P x), path (path.transport2 P (path.concat r1 r2) z) (path.concat (path.transport2 P r1 z) (path.transport2 P r2 z))"},
{name: "path.idp", value: "path.idp", meta: "Π {A : Type} {a : A}, path a a"},
{name: "path.idpath", value: "path.idpath", meta: "Π {A : Type} (a : A), path a a"},
{name: "path.moveL_Vp", value: "path.moveL_Vp", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path x y), path (path.concat r q) p → path q (path.concat (path.inverse r) p)"},
{name: "path.moveR_pM", value: "path.moveR_pM", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path y x), path r (path.concat q (path.inverse p)) → path (path.concat r p) q"},
{name: "path.transport_const", value: "path.transport_const", meta: "Π {A : Type} {B : Type} {x1 x2 : A} (p : path x1 x2) (y : B), path (path.transport (λ (x : A), B) p y) y"},
{name: "path.pentagon", value: "path.pentagon", meta: "Π {A : Type} {v w x y z : A} (p : path v w) (q : path w x) (r : path x y) (s : path y z), path (path.concat (path.concat (path.whiskerL p (path.concat_p_pp q r s)) (path.concat_p_pp p (path.concat q r) s)) (path.whiskerR (path.concat_p_pp p q r) s)) (path.concat (path.concat_p_pp p q (path.concat r s)) (path.concat_p_pp (path.concat p q) r s))"},
{name: "path.eckmann_hilton", value: "path.eckmann_hilton", meta: "Π {A : Type} {x : A} (p q : path path.idp path.idp), path (path.concat p q) (path.concat q p)"},
{name: "path.inv_Vp", value: "path.inv_Vp", meta: "Π {A : Type} {x y z : A} (p : path y x) (q : path y z), path (path.inverse (path.concat (path.inverse p) q)) (path.concat (path.inverse q) p)"},
{name: "path.concat_pp_A1p", value: "path.concat_pp_A1p", meta: "Π {A : Type} {g : A → A} (p : Π (x : A), path x (g x)) {x y : A} (q : path x y) {w z : A} (r : path w x) (s : path (g y) z), path (path.concat (path.concat r (p x)) (path.concat (path.ap g q) s)) (path.concat (path.concat r q) (path.concat (p y) s))"},
{name: "path.inverse_ap", value: "path.inverse_ap", meta: "Π {A : Type} {B : Type} (f : A → B) {x y : A} (p : path x y), path (path.inverse (path.ap f p)) (path.ap f (path.inverse p))"},
{name: "path.concat2", value: "path.concat2", meta: "Π {A : Type} {x y z : A} {p p' : path x y} {q q' : path y z}, path p p' → path q q' → path (path.concat p q) (path.concat p' q')"},
{name: "path.apD", value: "path.apD", meta: "Π {A : Type} {B : A → Type} (f : Π (x : A), B x) {x y : A} (p : path x y), path (path.transport (λ (x : A), B x) p (f x)) (f y)"},
{name: "path.moveL_pV", value: "path.moveL_pV", meta: "Π {A : Type} {x y z : A} (p : path z x) (q : path y z) (r : path y x), path (path.concat q p) r → path q (path.concat r (path.inverse p))"},
{name: "path.triangulator", value: "path.triangulator", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.concat (path.concat_p_pp p path.idp q) (path.whiskerR (path.concat_p1 p) q)) (path.whiskerL p (path.concat_1p q))"},
{name: "path.ap01", value: "path.ap01", meta: "Π ⦃A : Type⦄ ⦃B : Type⦄ (f : A → B) {x y : A}, path x y → path (f x) (f y)"},
{name: "path.ap_compose'", value: "path.ap_compose'", meta: "Π {A : Type} {B : Type} {C : Type} (f : A → B) (g : B → C) {x y : A} (p : path x y), path (path.ap (λ (a : A), g (f a)) p) (path.ap g (path.ap f p))"},
{name: "path.moveR_pV", value: "path.moveR_pV", meta: "Π {A : Type} {x y z : A} (p : path z x) (q : path y z) (r : path y x), path r (path.concat q p) → path (path.concat r (path.inverse p)) q"},
{name: "path.concat_p_Vp", value: "path.concat_p_Vp", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path x z), path (path.concat p (path.concat (path.inverse p) q)) q"},
{name: "path.inv_pV", value: "path.inv_pV", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path z y), path (path.inverse (path.concat p (path.inverse q))) (path.concat q (path.inverse p))"},
{name: "path.moveL_transport_V", value: "path.moveL_transport_V", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path x y) (u : P x) (v : P y), path (path.transport (λ (x : A), P x) p u) v → path u (path.transport (λ (x : A), P x) (path.inverse p) v)"},
{name: "path.moveL_M1", value: "path.moveL_M1", meta: "Π {A : Type} {x y : A} (p q : path x y), path (path.concat (path.inverse q) p) path.idp → path p q"},
{name: "path.moveR_V1", value: "path.moveR_V1", meta: "Π {A : Type} {x y : A} (p : path x y) (q : path y x), path path.idp (path.concat p q) → path (path.inverse p) q"},
{name: "path.apD10_1", value: "path.apD10_1", meta: "Π {A : Type} {B : A → Type} (f : Π (x : A), B x) (x : A), path (path.apD10 (path.idpath f) x) path.idp"},
{name: "path.ap_V", value: "path.ap_V", meta: "Π {A : Type} {B : Type} (f : A → B) {x y : A} (p : path x y), path (path.ap f (path.inverse p)) (path.inverse (path.ap f p))"},
{name: "path.moveR_M1", value: "path.moveR_M1", meta: "Π {A : Type} {x y : A} (p q : path x y), path path.idp (path.concat (path.inverse p) q) → path p q"},
{name: "path.transport2_V", value: "path.transport2_V", meta: "Π {A : Type} (Q : A → Type) {x y : A} {p q : path x y} (r : path p q) (z : Q x), path (path.transport2 Q (path.inverse r) z) (path.inverse (path.transport2 Q r z))"},
{name: "path.concat_p1", value: "path.concat_p1", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.concat p path.idp) p"},
{name: "path.transport_Vp", value: "path.transport_Vp", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path x y) (z : P x), path (path.transport (λ (x : A), P x) (path.inverse p) (path.transport (λ (x : A), P x) p z)) z"},
{name: "path.transport_p_pp", value: "path.transport_p_pp", meta: "Π {A : Type} (P : A → Type) {x y z w : A} (p : path x y) (q : path y z) (r : path z w) (u : P x), path (path.concat (path.concat (path.ap (λ (e : path x w), path.transport (λ (x : A), P x) e u) (path.concat_p_pp p q r)) (path.transport_pp P (path.concat p q) r u)) (path.ap (path.transport P r) (path.transport_pp P p q u))) (path.concat (path.transport_pp P p (path.concat q r) u) (path.transport_pp P q r (path.transport (λ (x : A), P x) p u)))"},
{name: "path.concat_V_pp", value: "path.concat_V_pp", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.concat (path.inverse p) (path.concat p q)) q"},
{name: "path.ap10_pp", value: "path.ap10_pp", meta: "Π {A : Type} {B : Type} {f f' f'' : A → B} (h : path f f') (h' : path f' f'') (x : A), path (path.ap10 (path.concat h h') x) (path.concat (path.ap10 h x) (path.ap10 h' x))"},
{name: "path.concat_pV", value: "path.concat_pV", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.concat p (path.inverse p)) path.idp"},
{name: "path.apD_const", value: "path.apD_const", meta: "Π {A : Type} {B : Type} {x y : A} (f : A → B) (p : path x y), path (path.apD f p) (path.concat (path.transport_const p (f x)) (path.ap f p))"},
{name: "path.ap_ap10", value: "path.ap_ap10", meta: "Π {A : Type} {B : Type} {C : Type} (f g : A → B) (h : B → C) (p : path f g) (a : A), path (path.ap h (path.ap10 p a)) (path.ap10 (path.ap (λ (f' : A → B), compose h f') p) a)"},
{name: "path.concat_1p", value: "path.concat_1p", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.concat path.idp p) p"},
{name: "path.concat_pp_A1", value: "path.concat_pp_A1", meta: "Π {A : Type} {g : A → A} (p : Π (x : A), path x (g x)) {x y : A} (q : path x y) {w : A} (r : path w x), path (path.concat (path.concat r (p x)) (path.ap g q)) (path.concat (path.concat r q) (p y))"},
{name: "path.transport2_is_ap10", value: "path.transport2_is_ap10", meta: "Π {A : Type} (Q : A → Type) {x y : A} {p q : path x y} (r : path p q) (z : Q x), path (path.transport2 Q r z) (path.ap10 (path.ap (path.transport Q) r) z)"},
{name: "path.moveL_1V", value: "path.moveL_1V", meta: "Π {A : Type} {x y : A} (p : path x y) (q : path y x), path (path.concat p q) path.idp → path p (path.inverse q)"},
{name: "path.concat_Vp", value: "path.concat_Vp", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.concat (path.inverse p) p) path.idp"},
{name: "path.apD02_pp", value: "path.apD02_pp", meta: "Π {A : Type} (B : A → Type) (f : Π (x : A), B x) {x y : A} {p1 p2 p3 : path x y} (r1 : path p1 p2) (r2 : path p2 p3), path (path.apD02 f (path.concat r1 r2)) (path.concat (path.concat (path.concat (path.apD02 f r1) (path.whiskerL (path.transport2 B r1 (f x)) (path.apD02 f r2))) (path.concat_p_pp (path.transport2 B r1 (f x)) (path.transport2 (λ (x : A), B x) r2 (f x)) (path.apD f p3))) (path.whiskerR (path.inverse (path.transport2_p2p B r1 r2 (f x))) (path.apD f p3)))"},
{name: "path.apD10_ap_postcompose", value: "path.apD10_ap_postcompose", meta: "Π {A : Type} {B : Type} {C : Type} (f : B → C) (g g' : A → B) (p : path g g') (a : A), path (path.apD10 (path.ap (λ (h : A → B), compose f h) p) a) (path.ap f (path.apD10 p a))"},
{name: "path.ap02_p2p", value: "path.ap02_p2p", meta: "Π {A : Type} {B : Type} (f : A → B) {x y z : A} {p p' : path x y} {q q' : path y z} (r : path p p') (s : path q q'), path (path.ap02 f (path.concat2 r s)) (path.concat (path.concat (path.ap_pp f p q) (path.concat2 (path.ap02 f r) (path.ap02 f s))) (path.inverse (path.ap_pp f p' q')))"},
{name: "path.moveR_1M", value: "path.moveR_1M", meta: "Π {A : Type} {x y : A} (p q : path x y), path path.idp (path.concat q (path.inverse p)) → path p q"},
{name: "path.ap11", value: "path.ap11", meta: "Π {A : Type} {B : Type} {f g : A → B}, path f g → (Π {x y : A}, path x y → path (f x) (g y))"},
{name: "path.concat_Ap", value: "path.concat_Ap", meta: "Π {A : Type} {B : Type} {f g : A → B} (p : Π (x : A), path (f x) (g x)) {x y : A} (q : path x y), path (path.concat (path.ap f q) (p y)) (path.concat (p x) (path.ap g q))"},
{name: "path.ap_idmap", value: "path.ap_idmap", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.ap id p) p"},
{name: "path.whiskerL_p1", value: "path.whiskerL_p1", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.whiskerL p path.idp) path.idp"},
{name: "path.rec", value: "path.rec", meta: "Π {A : Type} {a : A} {C : Π (a_1 : A), path a a_1 → Type}, C a (path.idpath a) → (Π {a_1 : A} (n : path a a_1), C a_1 n)"},
{name: "path.concat_p_A1p", value: "path.concat_p_A1p", meta: "Π {A : Type} {g : A → A} (p : Π (x : A), path x (g x)) {x y : A} (q : path x y) {z : A} (s : path (g y) z), path (path.concat (p x) (path.concat (path.ap g q) s)) (path.concat q (path.concat (p y) s))"},
{name: "path.ap10_V", value: "path.ap10_V", meta: "Π {A : Type} {B : Type} {f g : A → B} (h : path f g) (x : A), path (path.ap10 (path.inverse h) x) (path.inverse (path.ap10 h x))"},
{name: "path.apD10_pp", value: "path.apD10_pp", meta: "Π {A : Type} {B : A → Type} {f f' f'' : Π (x : A), B x} (h : path f f') (h' : path f' f'') (x : A), path (path.apD10 (path.concat h h') x) (path.concat (path.apD10 h x) (path.apD10 h' x))"},
{name: "path.concat_whisker", value: "path.concat_whisker", meta: "Π {A : Type} {x y z : A} (p p' : path x y) (q q' : path y z) (a : path p p') (b : path q q'), path (path.concat (path.whiskerR a q) (path.whiskerL p' b)) (path.concat (path.whiskerL p b) (path.whiskerR a q'))"},
{name: "path.ap_pp_p", value: "path.ap_pp_p", meta: "Π {A : Type} {B : Type} (f : A → B) {w x y z : A} (p : path x y) (q : path y z) (r : path (f z) (f w)), path (path.concat (path.ap f (path.concat p q)) r) (path.concat (path.ap f p) (path.concat (path.ap f q) r))"},
{name: "path.moveR_Mp", value: "path.moveR_Mp", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path y x), path p (path.concat (path.inverse r) q) → path (path.concat r p) q"},
{name: "path.concat2_1p", value: "path.concat2_1p", meta: "Π {A : Type} {x y : A} {p q : path x y} (h : path p q), path (path.concat2 path.idp h) (path.whiskerL path.idp h)"},
{name: "path.apD10_ap_precompose", value: "path.apD10_ap_precompose", meta: "Π {A : Type} {B : Type} {C : Type} (f : A → B) (g g' : B → C) (p : path g g') (a : A), path (path.apD10 (path.ap (λ (h : B → C), compose h f) p) a) (path.apD10 p (f a))"},
{name: "path.apD02", value: "path.apD02", meta: "Π {A : Type} {B : A → Type} {x y : A} {p q : path x y} (f : Π (x : A), B x) (r : path p q), path (path.apD f p) (path.concat (path.transport2 B r (f x)) (path.apD f q))"},
{name: "path.moveR_transport_V", value: "path.moveR_transport_V", meta: "Π {A : Type} (P : A → Type) {x y : A} (p : path y x) (u : P x) (v : P y), path u (path.transport (λ (x : A), P x) p v) → path (path.transport (λ (x : A), P x) (path.inverse p) u) v"},
{name: "path.moveL_pM", value: "path.moveL_pM", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path y x), path (path.concat q (path.inverse p)) r → path q (path.concat r p)"},
{name: "path.ap02", value: "path.ap02", meta: "Π {A : Type} {B : Type} (f : A → B) {x y : A} {p q : path x y}, path p q → path (path.ap f p) (path.ap f q)"},
{name: "path.whiskerR", value: "path.whiskerR", meta: "Π {A : Type} {x y z : A} {p q : path x y}, path p q → (Π (r : path y z), path (path.concat p r) (path.concat q r))"},
{name: "path.ap_p_pp", value: "path.ap_p_pp", meta: "Π {A : Type} {B : Type} (f : A → B) {w x y z : A} (r : path (f w) (f x)) (p : path x y) (q : path y z), path (path.concat r (path.ap f (path.concat p q))) (path.concat (path.concat r (path.ap f p)) (path.ap f q))"},
{name: "path.transportD", value: "path.transportD", meta: "Π {A : Type} (B : A → Type) (C : Π (a : A), B a → Type) {x1 x2 : A} (p : path x1 x2) (y : B x1), C x1 y → C x2 (path.transport (λ (x : A), B x) p y)"},
{name: "path.ap10_1", value: "path.ap10_1", meta: "Π {A : Type} {B : Type} {f : A → B} (x : A), path (path.ap10 (path.idpath f) x) path.idp"},
{name: "path.concat_A_pp", value: "path.concat_A_pp", meta: "Π {A : Type} {B : Type} {f g : A → B} (p : Π (x : A), path (f x) (g x)) {x y : A} (q : path x y) {z : B} (s : path (g y) z), path (path.concat (path.ap f q) (path.concat (p y) s)) (path.concat (p x) (path.concat (path.ap g q) s))"},
{name: "path.pointwise_paths", value: "path.pointwise_paths", meta: "Π {A : Type} {P : A → Type}, (Π (x : A), P x) → (Π (x : A), P x) → Type"},
{name: "path.concat_pp_V", value: "path.concat_pp_V", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.concat (path.concat p q) (path.inverse q)) p"},
{name: "path.moveR_Vp", value: "path.moveR_Vp", meta: "Π {A : Type} {x y z : A} (p : path x z) (q : path y z) (r : path x y), path p (path.concat r q) → path (path.concat (path.inverse r) p) q"},
{name: "path.transport", value: "path.transport", meta: "Π {A : Type} (P : A → Type) {x y : A}, path x y → P x → P y"},
{name: "path.concat_A1p", value: "path.concat_A1p", meta: "Π {A : Type} {f : A → A} (p : Π (x : A), path (f x) x) {x y : A} (q : path x y), path (path.concat (path.ap f q) (p y)) (path.concat (p x) q)"},
{name: "path.transport_precompose", value: "path.transport_precompose", meta: "Π {A : Type} {B : Type} {C : Type} (f : A → B) (g g' : B → C) (p : path g g'), path (path.transport (λ (h : B → C), path (compose g f) (compose h f)) p path.idp) (path.ap (λ (h : B → C), compose h f) p)"},
{name: "path.inv_V", value: "path.inv_V", meta: "Π {A : Type} {x y : A} (p : path x y), path (path.inverse (path.inverse p)) p"},
{name: "path.whiskerR_1p", value: "path.whiskerR_1p", meta: "Π {A : Type} {x y z : A} (p : path x y) (q : path y z), path (path.whiskerR path.idp q) path.idp"},
{name: "fibrant.unit_fibrant", value: "fibrant.unit_fibrant", meta: "fibrant unit"},
{name: "fibrant.rec", value: "fibrant.rec", meta: "Π {T : Type} {C : fibrant T → Type}, C (fibrant.fibrant_mk T) → (Π (n : fibrant T), C n)"},
{name: "fibrant.prod_fibrant", value: "fibrant.prod_fibrant", meta: "Π {A : Type} {B : Type}, fibrant A → fibrant B → fibrant (prod A B)"},
{name: "fibrant.pi_fibrant", value: "fibrant.pi_fibrant", meta: "Π {A : Type} {B : A → Type}, fibrant A → (Π (x : A), fibrant (B x)) → fibrant (Π (x : A), B x)"},
{name: "fibrant.nat_fibrant", value: "fibrant.nat_fibrant", meta: "fibrant nat"},
{name: "fibrant", value: "fibrant", meta: "Type → Type"},
{name: "fibrant.bool_fibrant", value: "fibrant.bool_fibrant", meta: "fibrant bool"},
{name: "fibrant.sum_fibrant", value: "fibrant.sum_fibrant", meta: "Π {A : Type} {B : Type}, fibrant A → fibrant B → fibrant (sum A B)"},
{name: "fibrant.fibrant_mk", value: "fibrant.fibrant_mk", meta: "Π (T : Type), fibrant T"},
{name: "fibrant.sigma_fibrant", value: "fibrant.sigma_fibrant", meta: "Π {A : Type} {B : A → Type}, fibrant A → (Π (x : A), fibrant (B x)) → fibrant (sigma (λ (x : A), B x))"},
{name: "funext", value: "funext", meta: "Π {A : Type} {P : A → Type} (f g : Π (x : A), P x), IsEquiv apD10"},
{name: "path_forall", value: "path_forall", meta: "Π {A : Type} {P : A → Type} (f g : Π (x : A), P x), pointwise_paths f g → path f g"},
{name: "path_forall2", value: "path_forall2", meta: "Π {A : Type} {B : Type} {P : A → B → Type} (f g : Π (x : A) (y : B), P x y), (Π (x : A) (y : B), path (f x y) (g x y)) → path f g"},
{name: "thm4", value: "thm4", meta: "∀ {P Q : Prop}, not P → P → Q"},
{name: "thm22b", value: "thm22b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, or C (not C) → (∀ (x : T), or (P x) C) → or (∀ (x : T), P x) C"},
{name: "thm21a", value: "thm21a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), true) → or (Exists (λ (x : T), P x)) C → Exists (λ (x : T), or (P x) C)"},
{name: "thm20a", value: "thm20a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, or C (not C) → Exists (λ (x : T), true) → (not (∀ (x : T), P x) → Exists (λ (x : T), not (P x))) → ((∀ (x : T), P x) → C) → Exists (λ (x : T), P x → C)"},
{name: "thm19a", value: "thm19a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, or C (not C) → Exists (λ (x : T), true) → (C → Exists (λ (x : T), P x)) → Exists (λ (x : T), C → P x)"},
{name: "thm18a", value: "thm18a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, (Exists (λ (x : T), P x) → C) → (∀ (x : T), P x → C)"},
{name: "thm12", value: "thm12", meta: "∀ {P Q : Prop}, not (or P Q) → and (not P) (not Q)"},
{name: "thm6", value: "thm6", meta: "∀ {P Q : Prop}, (P → Q) → not Q → not P"},
{name: "thm21b", value: "thm21b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), or (P x) C) → or (Exists (λ (x : T), P x)) C"},
{name: "thm7", value: "thm7", meta: "∀ {P Q : Prop}, (P → not P) → P → Q"},
{name: "thm23b", value: "thm23b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), and (P x) C) → and (Exists (λ (x : T), P x)) C"},
{name: "thm22a", value: "thm22a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, or (∀ (x : T), P x) C → (∀ (x : T), or (P x) C)"},
{name: "thm15", value: "thm15", meta: "∀ {P Q : Prop}, (P → Q) → not (not (or (not P) Q))"},
{name: "thm23a", value: "thm23a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, and (Exists (λ (x : T), P x)) C → Exists (λ (x : T), and (P x) C)"},
{name: "thm19b", value: "thm19b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), C → P x) → C → Exists (λ (x : T), P x)"},
{name: "thm24a", value: "thm24a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, and (∀ (x : T), P x) C → (∀ (x : T), and (P x) C)"},
{name: "thm2", value: "thm2", meta: "∀ {A B C : Prop}, (A → B) → (A → B → C) → A → C"},
{name: "thm10", value: "thm10", meta: "∀ {P : Prop}, not (not (or P (not P)))"},
{name: "thm14", value: "thm14", meta: "∀ {P Q : Prop}, or (not P) Q → P → Q"},
{name: "thm3", value: "thm3", meta: "∀ {A B C : Prop}, (A → B) → (B → C) → A → C"},
{name: "thm16", value: "thm16", meta: "∀ {P Q : Prop}, and (P → Q) (or (or P (not P)) (or Q (not Q))) → or (not P) Q"},
{name: "thm1", value: "thm1", meta: "∀ {A B : Prop}, A → B → A"},
{name: "thm24b", value: "thm24b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), true) → (∀ (x : T), and (P x) C) → and (∀ (x : T), P x) C"},
{name: "thm20b", value: "thm20b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, Exists (λ (x : T), P x → C) → (∀ (x : T), P x) → C"},
{name: "thm8", value: "thm8", meta: "∀ {P Q : Prop}, not (P → Q) → P → not Q"},
{name: "thm9", value: "thm9", meta: "∀ {P : Prop}, or P (not P) → not (not P) → P"},
{name: "thm11", value: "thm11", meta: "∀ {P Q : Prop}, or (not P) (not Q) → not (and P Q)"},
{name: "thm17a", value: "thm17a", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, (C → (∀ (x : T), P x)) → (∀ (x : T), C → P x)"},
{name: "thm17b", value: "thm17b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, (∀ (x : T), C → P x) → C → (∀ (x : T), P x)"},
{name: "thm18b", value: "thm18b", meta: "∀ {T : Type} {C : Prop} {P : T → Prop}, (∀ (x : T), P x → C) → Exists (λ (x : T), P x) → C"},
{name: "thm5", value: "thm5", meta: "∀ {P : Prop}, P → not (not P)"},
{name: "thm13", value: "thm13", meta: "∀ {P Q : Prop}, and (not P) (not Q) → not (or P Q)"},
{name: "test6", value: "test6", meta: "∀ (a b c d : Prop), iff a b → iff c b → iff c d → iff a d"},
{name: "test8", value: "test8", meta: "∀ (a b c d : Prop), iff a b → iff c b → iff c d → iff a d"},
{name: "test3", value: "test3", meta: "∀ (a b c d : Prop), Prop → iff a b → (or a c → not (d → a)) → or b c → not (d → b)"},
{name: "test2", value: "test2", meta: "∀ (a b c d : Prop), Prop → iff a b → (or a c → not (d → a)) → or b c → not (d → b)"},
{name: "test7", value: "test7", meta: "∀ (T : Type) (a b c d : T), eq a b → eq c b → eq c d → eq a d"},
{name: "test5", value: "test5", meta: "∀ (T : Type) (a b c d : T), eq a b → eq c b → eq c d → eq a d"},
{name: "test1", value: "test1", meta: "∀ (a b : Prop), iff a b → a → b"},
{name: "test4", value: "test4", meta: "∀ (a b c d : Prop), Prop → iff a b → iff (or a c → not (d → a)) (or b c → not (d → b))"},
{name: "rfl", value: "rfl", meta: "∀ {A : Type} {a : A}, eq a a"},
{name: "ne.intro", value: "ne.intro", meta: "∀ {A : Type} {a b : A}, (eq a b → false) → ne a b"},
{name: "congr", value: "congr", meta: "∀ {A : Type} {B : Type} {a a' : A} {f g : A → B}, eq f g → eq a a' → eq (f a) (g a')"},
{name: "eq.trans", value: "eq.trans", meta: "∀ {A : Type} {a b c : A}, eq a b → eq b c → eq a c"},
{name: "eqmp", value: "eqmp", meta: "∀ {a b : Prop}, eq a b → a → b"},
{name: "subsingleton.rec", value: "subsingleton.rec", meta: "Π {A : Type} {C : Type}, ((∀ (a b : A), eq a b) → C) → subsingleton A → C"},
{name: "true_ne_false", value: "true_ne_false", meta: "not (eq true false)"},
{name: "congr_arg5", value: "congr_arg5", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {E : Type} {F : Type} {a a' : A} {b b' : B} {c c' : C} {d d' : D} {e e' : E} (f : A → B → C → D → E → F), eq a a' → eq b b' → eq c c' → eq d d' → eq e e' → eq (f a b c d e) (f a' b' c' d' e')"},
{name: "eq.rec_id", value: "eq.rec_id", meta: "∀ {A : Type} {a : A} {B : A → Type} (H : eq a a) (b : B a), eq (eq.rec b H) b"},
{name: "congr_arg3", value: "congr_arg3", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {a a' : A} {b b' : B} {c c' : C} (f : A → B → C → D), eq a a' → eq b b' → eq c c' → eq (f a b c) (f a' b' c')"},
{name: "congr_arg2_dep", value: "congr_arg2_dep", meta: "∀ {A : Type} {B : A → Type} {R : Type} {a₁ a₂ : A} {b₁ : B a₁} {b₂ : B a₂} (f : Π (a : A), B a → R) (H₁ : eq a₁ a₂), eq (rec_on H₁ b₁) b₂ → eq (f a₁ b₁) (f a₂ b₂)"},
{name: "eq.rec_on_id", value: "eq.rec_on_id", meta: "∀ {A : Type} {a : A} {B : Π (a' : A), eq a a' → Type} (H : eq a a) (b : B a H), eq (rec_on H b) b"},
{name: "eq.refl", value: "eq.refl", meta: "∀ {A : Type} (a : A), eq a a"},
{name: "congr_fun", value: "congr_fun", meta: "∀ {A : Type} {B : A → Type} {f g : Π (x : A), B x}, eq f g → (∀ (a : A), eq (f a) (g a))"},
{name: "ne.elim", value: "ne.elim", meta: "∀ {A : Type} {a b : A}, ne a b → eq a b → false"},
{name: "subsingleton", value: "subsingleton", meta: "Type → Prop"},
{name: "eq.rec_on_constant2", value: "eq.rec_on_constant2", meta: "∀ {A : Type} {a₁ a₂ a₃ a₄ : A} {B : Type} (H₁ : eq a₁ a₂) (H₂ : eq a₃ a₄) (b : B), eq (rec_on H₁ b) (rec_on H₂ b)"},
{name: "eq.subst", value: "eq.subst", meta: "∀ {A : Type} {a b : A} {P : A → Prop}, eq a b → P a → P b"},
{name: "eq_imp_trans", value: "eq_imp_trans", meta: "∀ {a b c : Prop}, eq a b → (b → c) → a → c"},
{name: "eq.id_refl", value: "eq.id_refl", meta: "∀ {A : Type} {a : A} (H₁ : eq a a), eq H₁ (refl a)"},
{name: "p_ne_false", value: "p_ne_false", meta: "∀ {p : Prop}, p → ne p false"},
{name: "congr_arg", value: "congr_arg", meta: "∀ {A : Type} {B : Type} {a a' : A} (f : A → B), eq a a' → eq (f a) (f a')"},
{name: "ne_eq_trans", value: "ne_eq_trans", meta: "∀ {A : Type} {a b c : A}, ne a b → eq b c → ne a c"},
{name: "eq_ne_trans", value: "eq_ne_trans", meta: "∀ {A : Type} {a b c : A}, eq a b → ne b c → ne a c"},
{name: "congr5", value: "congr5", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {E : Type} {F : Type} {a a' : A} {b b' : B} {c c' : C} {d d' : D} {e e' : E} (f f' : A → B → C → D → E → F), eq f f' → eq a a' → eq b b' → eq c c' → eq d d' → eq e e' → eq (f a b c d e) (f' a' b' c' d' e')"},
{name: "eq.rec_on_constant", value: "eq.rec_on_constant", meta: "∀ {A : Type} {a a' : A} {B : Type} (H : eq a a') (b : B), eq (rec_on H b) b"},
{name: "imp_eq_trans", value: "imp_eq_trans", meta: "∀ {a b c : Prop}, (a → b) → eq b c → a → c"},
{name: "equal_f", value: "equal_f", meta: "∀ {A : Type} {B : A → Type} {f g : Π (x : A), B x}, eq f g → (∀ (x : A), eq (f x) (g x))"},
{name: "congr_arg3_ndep_dep", value: "congr_arg3_ndep_dep", meta: "∀ {A : Type} {B : Type} {C : A → B → Type} {R : Type} {a₁ a₂ : A} {b₁ b₂ : B} {c₁ : C a₁ b₁} {c₂ : C a₂ b₂} (f : Π (a : A) (b : B), C a b → R) (H₁ : eq a₁ a₂) (H₂ : eq b₁ b₂), eq (rec_on (congr_arg2 C H₁ H₂) c₁) c₂ → eq (f a₁ b₁ c₁) (f a₂ b₂ c₂)"},
{name: "eq.rec_on_compose", value: "eq.rec_on_compose", meta: "∀ {A : Type} {a b c : A} {P : A → Type} (H₁ : eq a b) (H₂ : eq b c) (u : P a), eq (rec_on H₂ (rec_on H₁ u)) (rec_on (trans H₁ H₂) u)"},
{name: "eq.irrel", value: "eq.irrel", meta: "∀ {A : Type} {a b : A} (H₁ H₂ : eq a b), eq H₁ H₂"},
{name: "eq.symm", value: "eq.symm", meta: "∀ {A : Type} {a b : A}, eq a b → eq b a"},
{name: "a_neq_a_elim", value: "a_neq_a_elim", meta: "∀ {A : Type} {a : A}, ne a a → false"},
{name: "subsingleton.intro", value: "subsingleton.intro", meta: "∀ {A : Type}, (∀ (a b : A), eq a b) → subsingleton A"},
{name: "ne.irrefl", value: "ne.irrefl", meta: "∀ {A : Type} {a : A}, ne a a → false"},
{name: "congr_arg2", value: "congr_arg2", meta: "∀ {A : Type} {B : Type} {C : Type} {a a' : A} {b b' : B} (f : A → B → C), eq a a' → eq b b' → eq (f a b) (f a' b')"},
{name: "p_ne_true", value: "p_ne_true", meta: "∀ {p : Prop}, not p → ne p true"},
{name: "ne.symm", value: "ne.symm", meta: "∀ {A : Type} {a b : A}, ne a b → ne b a"},
{name: "eqmpr", value: "eqmpr", meta: "∀ {a b : Prop}, eq a b → b → a"},
{name: "congr2", value: "congr2", meta: "∀ {A : Type} {B : Type} {C : Type} {a a' : A} {b b' : B} (f f' : A → B → C), eq f f' → eq a a' → eq b b' → eq (f a b) (f' a' b')"},
{name: "eq.rec_on_irrel", value: "eq.rec_on_irrel", meta: "∀ {A : Type} {B : Type} {a a' : A} {f : A → B} {D : B → Type} (H : eq a a') (H' : eq (f a) (f a')) (b : D (f a)), eq (rec_on H b) (rec_on H' b)"},
{name: "congr4", value: "congr4", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {E : Type} {a a' : A} {b b' : B} {c c' : C} {d d' : D} (f f' : A → B → C → D → E), eq f f' → eq a a' → eq b b' → eq c c' → eq d d' → eq (f a b c d) (f' a' b' c' d')"},
{name: "eq.rec_on", value: "eq.rec_on", meta: "Π {A : Type} {a a' : A} {B : Π (a' : A), eq a a' → Type} (H₁ : eq a a'), B a (refl a) → B a' H₁"},
{name: "imp_trans", value: "imp_trans", meta: "∀ {a b c : Prop}, (a → b) → (b → c) → a → c"},
{name: "eq_true_elim", value: "eq_true_elim", meta: "∀ {a : Prop}, eq a true → a"},
{name: "congr3", value: "congr3", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {a a' : A} {b b' : B} {c c' : C} (f f' : A → B → C → D), eq f f' → eq a a' → eq b b' → eq c c' → eq (f a b c) (f' a' b' c')"},
{name: "ne", value: "ne", meta: "Π {A : Type}, A → A → Prop"},
{name: "eq_false_elim", value: "eq_false_elim", meta: "∀ {a : Prop}, eq a false → not a"},
{name: "eq", value: "eq", meta: "Π {A : Type}, A → A → Prop"},
{name: "proof_irrel", value: "proof_irrel", meta: "∀ {a : Prop} (H₁ H₂ : a), eq H₁ H₂"},
{name: "eq.rec", value: "eq.rec", meta: "Π {A : Type} {a : A} {C : A → Type}, C a → (Π {a_1 : A}, eq a a_1 → C a_1)"},
{name: "congr_arg4", value: "congr_arg4", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} {E : Type} {a a' : A} {b b' : B} {c c' : C} {d d' : D} (f : A → B → C → D → E), eq a a' → eq b b' → eq c c' → eq d d' → eq (f a b c d) (f a' b' c' d')"},
{name: "prop.subsingleton", value: "prop.subsingleton", meta: "∀ (P : Prop), subsingleton P"},
{name: "congr_arg3_dep", value: "congr_arg3_dep", meta: "∀ {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} {R : Type} {a₁ a₂ : A} {b₁ : B a₁} {b₂ : B a₂} {c₁ : C a₁ b₁} {c₂ : C a₂ b₂} (f : Π (a : A) (b : B a), C a b → R) (H₁ : eq a₁ a₂) (H₂ : eq (rec_on H₁ b₁) b₂), eq (rec_on (congr_arg2_dep C H₁ H₂) c₁) c₂ → eq (f a₁ b₁ c₁) (f a₂ b₂ c₂)"},
{name: "subsingleton.elim", value: "subsingleton.elim", meta: "∀ {A : Type}, subsingleton A → (∀ (a b : A), eq a b)"},
{name: "if_congr", value: "if_congr", meta: "∀ {c₁ c₂ : Prop} [H₁ : decidable c₁] {A : Type} {t₁ t₂ e₁ e₂ : A} (Hc : iff c₁ c₂), eq t₁ t₂ → eq e₁ e₂ → eq (ite c₁ t₁ e₁) (ite c₂ t₂ e₂)"},
{name: "if_cond_congr", value: "if_cond_congr", meta: "∀ {c₁ c₂ : Prop} [H₁ : decidable c₁] [H₂ : decidable c₂], iff c₁ c₂ → (∀ {A : Type} (t e : A), eq (ite c₁ t e) (ite c₂ t e))"},
{name: "if_true", value: "if_true", meta: "∀ {A : Type} (t e : A), eq (ite true t e) t"},
{name: "if_t_t", value: "if_t_t", meta: "∀ (c : Prop) [H : decidable c] {A : Type} (t : A), eq (ite c t t) t"},
{name: "if_neg", value: "if_neg", meta: "∀ {c : Prop} [H : decidable c], not c → (∀ {A : Type} {t e : A}, eq (ite c t e) e)"},
{name: "if_false", value: "if_false", meta: "∀ {A : Type} (t e : A), eq (ite false t e) e"},
{name: "if_congr_aux", value: "if_congr_aux", meta: "∀ {c₁ c₂ : Prop} [H₁ : decidable c₁] [H₂ : decidable c₂] {A : Type} {t₁ t₂ e₁ e₂ : A}, iff c₁ c₂ → eq t₁ t₂ → eq e₁ e₂ → eq (ite c₁ t₁ e₁) (ite c₂ t₂ e₂)"},
{name: "ite", value: "ite", meta: "Π (c : Prop) [H : decidable c] {A : Type}, A → A → A"},
{name: "if_pos", value: "if_pos", meta: "∀ {c : Prop} [H : decidable c], c → (∀ {A : Type} {t e : A}, eq (ite c t e) t)"},
{name: "inhabited.dfun_inhabited", value: "inhabited.dfun_inhabited", meta: "Π (A : Type) {B : A → Type}, (Π (x : A), inhabited (B x)) → inhabited (Π (x : A), B x)"},
{name: "inhabited.fun_inhabited", value: "inhabited.fun_inhabited", meta: "Π (A : Type) {B : Type}, inhabited B → inhabited (A → B)"},
{name: "inhabited.default", value: "inhabited.default", meta: "Π (A : Type) [H : inhabited A], A"},
{name: "inhabited.rec", value: "inhabited.rec", meta: "Π {A : Type} {C : inhabited A → Type}, (Π (a : A), C (inhabited.mk a)) → (Π (n : inhabited A), C n)"},
{name: "inhabited.Prop_inhabited", value: "inhabited.Prop_inhabited", meta: "inhabited Prop"},
{name: "inhabited.mk", value: "inhabited.mk", meta: "Π {A : Type}, A → inhabited A"},
{name: "inhabited", value: "inhabited", meta: "Type → Type"},
{name: "inhabited.destruct", value: "inhabited.destruct", meta: "Π {A : Type} {B : Type}, inhabited A → (A → B) → B"},
{name: "heq.symm", value: "heq.symm", meta: "∀ {A B : Type} {a : A} {b : B}, heq a b → heq b a"},
{name: "heq.trans_right", value: "heq.trans_right", meta: "∀ {A C : Type} {a b : A} {c : C}, eq a b → heq b c → heq a c"},
{name: "heq.to_cast_eq", value: "heq.to_cast_eq", meta: "∀ {A B : Type} {a : A} {b : B} (H : heq a b), eq (cast (heq.type_eq H) a) b"},
{name: "dcongr_arg", value: "dcongr_arg", meta: "∀ {A : Type} {B : A → Type} (f : Π (x : A), B x) {a b : A}, eq a b → heq (f a) (f b)"},
{name: "heq.trans", value: "heq.trans", meta: "∀ {A B C : Type} {a : A} {b : B} {c : C}, heq a b → heq b c → heq a c"},
{name: "hcongr_fun'", value: "hcongr_fun'", meta: "∀ {A : Type} {B B' : A → Type} {f : Π (x : A), B x} {f' : Π (x : A), B' x} (a : A), heq f f' → eq B B' → heq (f a) (f' a)"},
{name: "heq.elim", value: "heq.elim", meta: "∀ {A B : Type} {C : Prop} {a : A} {b : B}, heq a b → (∀ (Hab : eq A B), eq (cast Hab a) b → C) → C"},
{name: "heq", value: "heq", meta: "Π {A : Type}, A → (Π {B : Type}, B → Prop)"},
{name: "cast", value: "cast", meta: "Π {A B : Type}, eq A B → A → B"},
{name: "heq.type_eq", value: "heq.type_eq", meta: "∀ {A B : Type} {a : A} {b : B}, heq a b → eq A B"},
{name: "heq.rec", value: "heq.rec", meta: "Π {A : Type} {a : A} {C : Π {B : Type}, B → Type}, C a → (Π {B : Type} {a_1 : B}, heq a a_1 → C a_1)"},
{name: "heq.true_elim", value: "heq.true_elim", meta: "∀ {a : Prop}, heq a true → a"},
{name: "heq.refl", value: "heq.refl", meta: "∀ {A : Type} (a : A), heq a a"},
{name: "heq.rec_on", value: "heq.rec_on", meta: "Π {A B : Type} {a : A} {b : B} {C : Π {B : Type} (b : B), heq a b → Type} (H₁ : heq a b), C a (heq.refl a) → C b H₁"},
{name: "cast_refl", value: "cast_refl", meta: "∀ {A : Type} (a : A), eq (cast (eq.refl A) a) a"},
{name: "cast_eq_to_heq", value: "cast_eq_to_heq", meta: "∀ {A B : Type} {a : A} {b : B} {H : eq A B}, eq (cast H a) b → heq a b"},
{name: "cast_heq", value: "cast_heq", meta: "∀ {A B : Type} (H : eq A B) (a : A), heq (cast H a) a"},
{name: "cast_trans", value: "cast_trans", meta: "∀ {A B C : Type} (Hab : eq A B) (Hbc : eq B C) (a : A), eq (cast Hbc (cast Hab a)) (cast (eq.trans Hab Hbc) a)"},
{name: "pi_eq", value: "pi_eq", meta: "∀ {A : Type} {B B' : A → Type}, eq B B' → eq (Π (x : A), B x) (Π (x : A), B' x)"},
{name: "cast_eq", value: "cast_eq", meta: "∀ {A : Type} (H : eq A A) (a : A), eq (cast H a) a"},
{name: "heq.from_eq", value: "heq.from_eq", meta: "∀ {A : Type} {a b : A}, eq a b → heq a b"},
{name: "heq.subst", value: "heq.subst", meta: "∀ {A B : Type} {a : A} {b : B} {P : Π (T : Type), T → Prop}, heq a b → P A a → P B b"},
{name: "cast_proof_irrel", value: "cast_proof_irrel", meta: "∀ {A B : Type} (H₁ H₂ : eq A B) (a : A), eq (cast H₁ a) (cast H₂ a)"},
{name: "heq.to_eq", value: "heq.to_eq", meta: "∀ {A : Type} {a b : A}, heq a b → eq a b"},
{name: "cast_pull", value: "cast_pull", meta: "∀ {A : Type} {B B' : A → Type} (H : eq B B') (f : Π (x : A), B x) (a : A), eq (cast (pi_eq H) f a) (cast (congr_fun H a) (f a))"},
{name: "heq.trans_left", value: "heq.trans_left", meta: "∀ {A B : Type} {a : A} {b c : B}, heq a b → eq b c → heq a c"},
{name: "cast_app'", value: "cast_app'", meta: "∀ {A : Type} {B B' : A → Type} (H : eq B B') (f : Π (x : A), B x) (a : A), heq (cast (pi_eq H) f a) (f a)"},
{name: "imp_or", value: "imp_or", meta: "∀ {a b : Prop} [Da : decidable a], iff (a → b) (or (not a) b)"},
{name: "not_exists_forall", value: "not_exists_forall", meta: "∀ {A : Type} {P : A → Prop} [D : Π (x : A), decidable (P x)], not (Exists (λ (x : A), P x)) → (∀ (x : A), not (P x))"},
{name: "not_and", value: "not_and", meta: "∀ {a b : Prop} [Da : decidable a] [Db : decidable b], iff (not (and a b)) (or (not a) (not b))"},
{name: "or_left_comm", value: "or_left_comm", meta: "∀ (a b c : Prop), iff (or a (or b c)) (or b (or a c))"},
{name: "a_iff_not_a", value: "a_iff_not_a", meta: "∀ (a : Prop), iff (iff a (not a)) false"},
{name: "iff_true_intro", value: "iff_true_intro", meta: "∀ {a : Prop}, a → iff a true"},
{name: "true_eq_false", value: "true_eq_false", meta: "iff (iff true false) false"},
{name: "eq_id", value: "eq_id", meta: "∀ {A : Type} (a : A), iff (eq a a) true"},
{name: "or_right_comm", value: "or_right_comm", meta: "∀ (a b c : Prop), iff (or (or a b) c) (or (or a c) b)"},
{name: "and_left_comm", value: "and_left_comm", meta: "∀ (a b c : Prop), iff (and a (and b c)) (and b (and a c))"},
{name: "a_neq_a", value: "a_neq_a", meta: "∀ {A : Type} (a : A), iff (ne a a) false"},
{name: "not_true", value: "not_true", meta: "iff (not true) false"},
{name: "not_false", value: "not_false", meta: "iff (not false) true"},
{name: "not_not_elim", value: "not_not_elim", meta: "∀ {a : Prop} [D : decidable a], not (not a) → a"},
{name: "not_not_iff", value: "not_not_iff", meta: "∀ {a : Prop} [D : decidable a], iff (not (not a)) a"},
{name: "not_forall_exists", value: "not_forall_exists", meta: "∀ {A : Type} {P : A → Prop} [D : Π (x : A), decidable (P x)] [D' : decidable (Exists (λ (x : A), not (P x)))], not (∀ (x : A), P x) → Exists (λ (x : A), not (P x))"},
{name: "iff_false_intro", value: "iff_false_intro", meta: "∀ {a : Prop}, not a → iff a false"},
{name: "false_eq_true", value: "false_eq_true", meta: "iff (iff false true) false"},
{name: "not_or", value: "not_or", meta: "∀ {a b : Prop} [Da : decidable a] [Db : decidable b], iff (not (or a b)) (and (not a) (not b))"},
{name: "a_eq_true", value: "a_eq_true", meta: "∀ (a : Prop), iff (iff a true) a"},
{name: "and_right_comm", value: "and_right_comm", meta: "∀ (a b c : Prop), iff (and (and a b) c) (and (and a c) b)"},
{name: "heq_id", value: "heq_id", meta: "∀ {A : Type} (a : A), iff (heq a a) true"},
{name: "a_eq_false", value: "a_eq_false", meta: "∀ (a : Prop), iff (iff a false) (not a)"},
{name: "peirce", value: "peirce", meta: "∀ {a b : Prop} [D : decidable a], ((a → b) → a) → a"},
{name: "not_implies", value: "not_implies", meta: "∀ {a b : Prop} [Da : decidable a] [Db : decidable b], iff (not (a → b)) (and a (not b))"},
{name: "decidable.by_contradiction", value: "decidable.by_contradiction", meta: "∀ {p : Prop} [Hp : decidable p], (not p → false) → p"},
{name: "decidable.implies_decidable", value: "decidable.implies_decidable", meta: "Π {p q : Prop}, decidable p → decidable q → decidable (p → q)"},
{name: "decidable.or_decidable", value: "decidable.or_decidable", meta: "Π {p q : Prop}, decidable p → decidable q → decidable (or p q)"},
{name: "decidable.decidable_iff_equiv", value: "decidable.decidable_iff_equiv", meta: "Π {p q : Prop}, decidable p → iff p q → decidable q"},
{name: "decidable.rec", value: "decidable.rec", meta: "Π {p : Prop} {C : decidable p → Type}, (Π (a : p), C (decidable.inl a)) → (Π (a : not p), C (decidable.inr a)) → (Π (n : decidable p), C n)"},
{name: "decidable_rel2", value: "decidable_rel2", meta: "Π {A : Type}, (A → A → Prop) → Type"},
{name: "decidable_rel", value: "decidable_rel", meta: "Π {A : Type}, (A → Prop) → Type"},
{name: "decidable.true_decidable", value: "decidable.true_decidable", meta: "decidable true"},
{name: "decidable.rec_subsingleton", value: "decidable.rec_subsingleton", meta: "∀ {p : Prop} [H : decidable p] {H1 : p → Type} {H2 : not p → Type}, (∀ (h : p), subsingleton (H1 h)) → (∀ (h : not p), subsingleton (H2 h)) → subsingleton (decidable.rec_on H H1 H2)"},
{name: "decidable_eq", value: "decidable_eq", meta: "Type → Type"},
{name: "decidable.decidable_eq_equiv", value: "decidable.decidable_eq_equiv", meta: "Π {p q : Prop}, decidable p → eq p q → decidable q"},
{name: "empty.has_decidable_eq", value: "empty.has_decidable_eq", meta: "decidable_eq empty"},
{name: "decidable.irrelevant", value: "decidable.irrelevant", meta: "∀ {p : Prop}, subsingleton (decidable p)"},
{name: "decidable.rec_on", value: "decidable.rec_on", meta: "Π {p : Prop} {C : decidable p → Type} (H : decidable p), (Π (a : p), C (decidable.inl a)) → (Π (a : not p), C (decidable.inr a)) → C H"},
{name: "decidable.rec_on_false", value: "decidable.rec_on_false", meta: "Π {p : Prop} [H : decidable p] {H1 : p → Type} {H2 : not p → Type} (H3 : not p), H2 H3 → decidable.rec_on H H1 H2"},
{name: "decidable.not_decidable", value: "decidable.not_decidable", meta: "Π {p : Prop}, decidable p → decidable (not p)"},
{name: "decidable.rec_on_true", value: "decidable.rec_on_true", meta: "Π {p : Prop} [H : decidable p] {H1 : p → Type} {H2 : not p → Type} (H3 : p), H1 H3 → decidable.rec_on H H1 H2"},
{name: "decidable", value: "decidable", meta: "Prop → Type"},
{name: "decidable.inl", value: "decidable.inl", meta: "Π {p : Prop}, p → decidable p"},
{name: "decidable.iff_decidable", value: "decidable.iff_decidable", meta: "Π {p q : Prop}, decidable p → decidable q → decidable (iff p q)"},
{name: "decidable.and_decidable", value: "decidable.and_decidable", meta: "Π {p q : Prop}, decidable p → decidable q → decidable (and p q)"},
{name: "decidable.false_decidable", value: "decidable.false_decidable", meta: "decidable false"},
{name: "decidable.by_cases", value: "decidable.by_cases", meta: "Π {p : Prop} {q : Type} [C : decidable p], (p → q) → (not p → q) → q"},
{name: "decidable.inr", value: "decidable.inr", meta: "Π {p : Prop}, not p → decidable p"},
{name: "decidable.induction_on", value: "decidable.induction_on", meta: "∀ {p C : Prop}, decidable p → (p → C) → (not p → C) → C"},
{name: "decidable.em", value: "decidable.em", meta: "∀ (p : Prop) [H : decidable p], or p (not p)"},
{name: "iff.refl", value: "iff.refl", meta: "∀ (a : Prop), iff a a"},
{name: "iff", value: "iff", meta: "Prop → Prop → Prop"},
{name: "iff.intro", value: "iff.intro", meta: "∀ {a b : Prop}, (a → b) → (b → a) → iff a b"},
{name: "or.elim3", value: "or.elim3", meta: "∀ {a b c d : Prop}, or a (or b c) → (a → d) → (b → d) → (c → d) → d"},
{name: "eq_to_iff", value: "eq_to_iff", meta: "∀ {a b : Prop}, eq a b → iff a b"},
{name: "or.imp_or_right", value: "or.imp_or_right", meta: "∀ {a b c : Prop}, or c a → (a → b) → or c b"},
{name: "or.resolve_right", value: "or.resolve_right", meta: "∀ {a b : Prop}, or a b → not a → b"},
{name: "iff.trans", value: "iff.trans", meta: "∀ {a b c : Prop}, iff a b → iff b c → iff a c"},
{name: "and.imp_left", value: "and.imp_left", meta: "∀ {a b c : Prop}, and a c → (a → b) → and b c"},
{name: "iff.true_elim", value: "iff.true_elim", meta: "∀ {a : Prop}, iff a true → a"},
{name: "and", value: "and", meta: "Prop → Prop → Prop"},
{name: "or.intro_left", value: "or.intro_left", meta: "∀ {a : Prop} (b : Prop), a → or a b"},
{name: "and.comm", value: "and.comm", meta: "∀ {a b : Prop}, iff (and a b) (and b a)"},
{name: "or.rec", value: "or.rec", meta: "∀ {a b C : Prop}, (a → C) → (b → C) → or a b → C"},
{name: "iff.symm", value: "iff.symm", meta: "∀ {a b : Prop}, iff a b → iff b a"},
{name: "or.resolve_left", value: "or.resolve_left", meta: "∀ {a b : Prop}, or a b → not b → a"},
{name: "and.elim_right", value: "and.elim_right", meta: "∀ {a b : Prop}, and a b → b"},
{name: "and.imp_and", value: "and.imp_and", meta: "∀ {a b c d : Prop}, and a b → (a → c) → (b → d) → and c d"},
{name: "iff.flip_sign", value: "iff.flip_sign", meta: "∀ {a b : Prop}, iff a b → iff (not a) (not b)"},
{name: "and.not_left", value: "and.not_left", meta: "∀ {a : Prop} (b : Prop), not a → not (and a b)"},
{name: "or.inr", value: "or.inr", meta: "∀ {a b : Prop}, b → or a b"},
{name: "or.elim", value: "or.elim", meta: "∀ {a b c : Prop}, or a b → (a → c) → (b → c) → c"},
{name: "and.rec", value: "and.rec", meta: "Π {a b : Prop} {C : Type}, (a → b → C) → and a b → C"},
{name: "iff.elim_right", value: "iff.elim_right", meta: "∀ {a b : Prop}, iff a b → b → a"},
{name: "or.imp_or", value: "or.imp_or", meta: "∀ {a b c d : Prop}, or a b → (a → c) → (b → d) → or c d"},
{name: "iff.rfl", value: "iff.rfl", meta: "∀ {a : Prop}, iff a a"},
{name: "and.assoc", value: "and.assoc", meta: "∀ {a b c : Prop}, iff (and (and a b) c) (and a (and b c))"},
{name: "iff.elim_left", value: "iff.elim_left", meta: "∀ {a b : Prop}, iff a b → a → b"},
{name: "iff.elim", value: "iff.elim", meta: "∀ {a b c : Prop}, ((a → b) → (b → a) → c) → iff a b → c"},
{name: "and.swap", value: "and.swap", meta: "∀ {a b : Prop}, and a b → and b a"},
{name: "or.swap", value: "or.swap", meta: "∀ {a b : Prop}, or a b → or b a"},
{name: "or.comm", value: "or.comm", meta: "∀ {a b : Prop}, iff (or a b) (or b a)"},
{name: "or.assoc", value: "or.assoc", meta: "∀ {a b c : Prop}, iff (or (or a b) c) (or a (or b c))"},
{name: "or.intro_right", value: "or.intro_right", meta: "∀ (a : Prop) {b : Prop}, b → or a b"},
{name: "not_not_em", value: "not_not_em", meta: "∀ {p : Prop}, not (not (or p (not p)))"},
{name: "or.inl", value: "or.inl", meta: "∀ {a b : Prop}, a → or a b"},
{name: "or", value: "or", meta: "Prop → Prop → Prop"},
{name: "iff.false_elim", value: "iff.false_elim", meta: "∀ {a : Prop}, iff a false → not a"},
{name: "iff.mp", value: "iff.mp", meta: "∀ {a b : Prop}, iff a b → a → b"},
{name: "and.imp_right", value: "and.imp_right", meta: "∀ {a b c : Prop}, and c a → (a → b) → and c b"},
{name: "and.elim", value: "and.elim", meta: "∀ {a b c : Prop}, and a b → (a → b → c) → c"},
{name: "or.not_intro", value: "or.not_intro", meta: "∀ {a b : Prop}, not a → not b → not (or a b)"},
{name: "and.elim_left", value: "and.elim_left", meta: "∀ {a b : Prop}, and a b → a"},
{name: "and.intro", value: "and.intro", meta: "∀ {a b : Prop}, a → b → and a b"},
{name: "or.imp_or_left", value: "or.imp_or_left", meta: "∀ {a b c : Prop}, or a c → (a → b) → or b c"},
{name: "iff.def", value: "iff.def", meta: "∀ {a b : Prop}, eq (iff a b) (and (a → b) (b → a))"},
{name: "and.not_right", value: "and.not_right", meta: "∀ (a : Prop) {b : Prop}, not b → not (and a b)"},
{name: "false.rec", value: "false.rec", meta: "∀ (C : Prop), false → C"},
{name: "not_implies_left", value: "not_implies_left", meta: "∀ {a b : Prop}, not (a → b) → not (not a)"},
{name: "not_false_trivial", value: "not_false_trivial", meta: "not false"},
{name: "true.intro", value: "true.intro", meta: "true"},
{name: "trivial", value: "trivial", meta: "true"},
{name: "absurd", value: "absurd", meta: "∀ {a b : Prop}, a → not a → b"},
{name: "imp", value: "imp", meta: "Prop → Prop → Prop"},
{name: "not_intro", value: "not_intro", meta: "∀ {a : Prop}, (a → false) → not a"},
{name: "false_elim", value: "false_elim", meta: "∀ {c : Prop}, false → c"},
{name: "not_elim", value: "not_elim", meta: "∀ {a : Prop}, not a → a → false"},
{name: "mt", value: "mt", meta: "∀ {a b : Prop}, (a → b) → not b → not a"},
{name: "false", value: "false", meta: "Prop"},
{name: "not_implies_right", value: "not_implies_right", meta: "∀ {a b : Prop}, not (a → b) → not b"},
{name: "true.rec", value: "true.rec", meta: "Π {C : Type}, C → true → C"},
{name: "not_not_intro", value: "not_not_intro", meta: "∀ {a : Prop}, a → not (not a)"},
{name: "true", value: "true", meta: "Prop"},
{name: "not", value: "not", meta: "Prop → Prop"},
{name: "exists_unique", value: "exists_unique", meta: "Π {A : Type}, (A → Prop) → Prop"},
{name: "Exists.intro", value: "Exists.intro", meta: "∀ {A : Type} {P : A → Prop} (a : A), P a → Exists P"},
{name: "exists_not_forall", value: "exists_not_forall", meta: "∀ {A : Type} {p : A → Prop}, Exists (λ (x : A), p x) → not (∀ (x : A), not (p x))"},
{name: "forall_congr", value: "forall_congr", meta: "∀ {A : Type} {φ ψ : A → Prop}, (∀ (x : A), iff (φ x) (ψ x)) → iff (∀ (x : A), φ x) (∀ (x : A), ψ x)"},
{name: "exists_p_iff_p", value: "exists_p_iff_p", meta: "∀ (A : Type) [H : inhabited A] (p : Prop), iff (Exists (λ (x : A), p)) p"},
{name: "exists_elim", value: "exists_elim", meta: "∀ {A : Type} {p : A → Prop} {B : Prop}, Exists (λ (x : A), p x) → (∀ (a : A), p a → B) → B"},
{name: "forall_and_distribute", value: "forall_and_distribute", meta: "∀ {A : Type} (φ ψ : A → Prop), iff (∀ (x : A), and (φ x) (ψ x)) (and (∀ (x : A), φ x) (∀ (x : A), ψ x))"},
{name: "exists_congr", value: "exists_congr", meta: "∀ {A : Type} {φ ψ : A → Prop}, (∀ (x : A), iff (φ x) (ψ x)) → iff (Exists (λ (x : A), φ x)) (Exists (λ (x : A), ψ x))"},
{name: "exists_intro", value: "exists_intro", meta: "∀ {A : Type} {P : A → Prop} (a : A), P a → Exists P"},
{name: "exists_unique_intro", value: "exists_unique_intro", meta: "∀ {A : Type} {p : A → Prop} (w : A), p w → (∀ (y : A), p y → eq y w) → exists_unique (λ (x : A), p x)"},
{name: "forall_p_iff_p", value: "forall_p_iff_p", meta: "∀ (A : Type) [H : inhabited A] (p : Prop), iff (A → p) p"},
{name: "exists_imp_nonempty", value: "exists_imp_nonempty", meta: "∀ {A : Type} {P : A → Prop}, Exists (λ (x : A), P x) → nonempty A"},
{name: "forall_not_exists", value: "forall_not_exists", meta: "∀ {A : Type} {p : A → Prop}, (∀ (x : A), p x) → not (Exists (λ (x : A), not (p x)))"},
{name: "exists_or_distribute", value: "exists_or_distribute", meta: "∀ {A : Type} (φ ψ : A → Prop), iff (Exists (λ (x : A), or (φ x) (ψ x))) (or (Exists (λ (x : A), φ x)) (Exists (λ (x : A), ψ x)))"},
{name: "exists_unique_elim", value: "exists_unique_elim", meta: "∀ {A : Type} {p : A → Prop} {b : Prop}, exists_unique (λ (x : A), p x) → (∀ (x : A), p x → (∀ (y : A), p y → eq y x) → b) → b"},
{name: "Exists", value: "Exists", meta: "Π {A : Type}, (A → Prop) → Prop"},
{name: "forall_true_iff_true", value: "forall_true_iff_true", meta: "∀ (A : Type), iff (A → true) true"},
{name: "Exists.rec", value: "Exists.rec", meta: "∀ {A : Type} {P : A → Prop} {C : Prop}, (∀ (a : A), P a → C) → Exists P → C"},
{name: "nonempty.elim", value: "nonempty.elim", meta: "∀ {A : Type} {B : Prop}, nonempty A → (A → B) → B"},
{name: "nonempty.rec", value: "nonempty.rec", meta: "∀ {A : Type} {C : Prop}, (A → C) → nonempty A → C"},
{name: "nonempty.inhabited_imp_nonempty", value: "nonempty.inhabited_imp_nonempty", meta: "∀ {A : Type}, inhabited A → nonempty A"},
{name: "nonempty", value: "nonempty", meta: "Type → Prop"},
{name: "nonempty.intro", value: "nonempty.intro", meta: "∀ {A : Type}, A → nonempty A"},
{name: "epsilon", value: "epsilon", meta: "Π {A : Type} [H : nonempty A], (A → Prop) → A"},
{name: "epsilon_singleton", value: "epsilon_singleton", meta: "∀ {A : Type} (a : A), eq (epsilon (λ (x : A), eq x a)) a"},
{name: "axiom_of_choice", value: "axiom_of_choice", meta: "∀ {A : Type} {B : A → Type} {R : Π (x : A), B x → Prop}, (∀ (x : A), Exists (λ (y : B x), R x y)) → Exists (λ (f : Π (x : A), B x), ∀ (x : A), R x (f x))"},
{name: "nonempty_imp_exists_true", value: "nonempty_imp_exists_true", meta: "∀ {A : Type}, nonempty A → Exists (λ (x : A), true)"},
{name: "exists_imp_inhabited", value: "exists_imp_inhabited", meta: "Π {A : Type} {P : A → Prop}, Exists (λ (x : A), P x) → inhabited A"},
{name: "epsilon_spec_aux", value: "epsilon_spec_aux", meta: "∀ {A : Type} (H : nonempty A) (P : A → Prop), Exists (λ (x : A), P x) → P (epsilon P)"},
{name: "epsilon_spec", value: "epsilon_spec", meta: "∀ {A : Type} {P : A → Prop} (Hex : Exists (λ (x : A), P x)), P (epsilon P)"},
{name: "skolem", value: "skolem", meta: "∀ {A : Type} {B : A → Type} {P : Π (x : A), B x → Prop}, iff (∀ (x : A), Exists (λ (y : B x), P x y)) (Exists (λ (f : Π (x : A), B x), ∀ (x : A), P x (f x)))"},
{name: "nonempty_imp_inhabited", value: "nonempty_imp_inhabited", meta: "Π {A : Type}, nonempty A → inhabited A"},
{name: "strong_indefinite_description", value: "strong_indefinite_description", meta: "Π {A : Type} (P : A → Prop), nonempty A → subtype (λ (x : A), Exists (λ (x : A), P x) → P x)"},
{name: "em", value: "em", meta: "(∀ {a b : Prop}, (a → b) → (b → a) → eq a b) → (∀ (p : Prop), or p (not p))"},
{name: "iff_congruence", value: "iff_congruence", meta: "∀ (P : Prop → Prop), congruence iff iff P"},
{name: "em", value: "em", meta: "∀ (a : Prop), or a (not a)"},
{name: "iff_eq_eq", value: "iff_eq_eq", meta: "∀ {a b : Prop}, eq (iff a b) (eq a b)"},
{name: "prop_complete", value: "prop_complete", meta: "∀ (a : Prop), or (eq a true) (eq a false)"},
{name: "cases", value: "cases", meta: "∀ (P : Prop → Prop), P true → P false → (∀ (a : Prop), P a)"},
{name: "iff_to_eq", value: "iff_to_eq", meta: "∀ {a b : Prop}, iff a b → eq a b"},
{name: "cases_on", value: "cases_on", meta: "∀ (a : Prop) {P : Prop → Prop}, P true → P false → P a"},
{name: "prop_complete_swapped", value: "prop_complete_swapped", meta: "∀ (a : Prop), or (eq a false) (eq a true)"},
{name: "propext", value: "propext", meta: "∀ {a b : Prop}, (a → b) → (b → a) → eq a b"},
{name: "prop_decidable", value: "prop_decidable", meta: "Π (a : Prop), decidable a"},
{name: "decidable_inhabited", value: "decidable_inhabited", meta: "Π (a : Prop), inhabited (decidable a)"},
{name: "hcongr_fun", value: "hcongr_fun", meta: "∀ {A : Type} {B B' : A → Type} {f : Π (x : A), B x} {f' : Π (x : A), B' x} (a : A), heq f f' → heq (f a) (f' a)"},
{name: "cast_app", value: "cast_app", meta: "∀ {A : Type} {B B' : A → Type} (H : eq (Π (x : A), B x) (Π (x : A), B' x)) (f : Π (x : A), B x) (a : A), heq (cast H f a) (f a)"},
{name: "hcongr", value: "hcongr", meta: "∀ {A A' : Type} {B : A → Type} {B' : A' → Type} {f : Π (x : A), B x} {f' : Π (x : A'), B' x} {a : A} {a' : A'}, heq f f' → heq a a' → heq (f a) (f' a')"},
{name: "piext", value: "piext", meta: "∀ {A : Type} {B B' : A → Type} [H : inhabited (Π (x : A), B x)], eq (Π (x : A), B x) (Π (x : A), B' x) → eq B B'"},
{name: "funext", value: "funext", meta: "∀ {A : Type} {B : A → Type} {f g : Π (x : A), B x}, (∀ (x : A), eq (f x) (g x)) → eq f g"},
{name: "function.compose_assoc", value: "function.compose_assoc", meta: "∀ {A : Type} {B : Type} {C : Type} {D : Type} (f : C → D) (g : B → C) (h : A → B), eq (compose (compose f g) h) (compose f (compose g h))"},
{name: "function.compose_id_right", value: "function.compose_id_right", meta: "∀ {A : Type} {B : Type} (f : A → B), eq (compose f id) f"},
{name: "function.compose_const_right", value: "function.compose_const_right", meta: "∀ {A : Type} {B : Type} {C : Type} (f : B → C) (b : B), eq (compose f (const A b)) (const A (f b))"},
{name: "function.compose_id_left", value: "function.compose_id_left", meta: "∀ {A : Type} {B : Type} (f : A → B), eq (compose id f) f"},
{name: "relation.congruence_or_compose", value: "relation.congruence_or_compose", meta: "∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f1 : T1 → Prop}, relation.congruence R1 iff f1 → (∀ {f2 : T1 → Prop}, relation.congruence R1 iff f2 → relation.congruence R1 iff (λ (x : T1), or (f1 x) (f2 x)))"},
{name: "relation.iff_ops.mp", value: "relation.iff_ops.mp", meta: "∀ {a b : Prop}, iff a b → a → b"},
{name: "relation.is_reflexive_eq", value: "relation.is_reflexive_eq", meta: "∀ (T : Type), relation.is_reflexive eq"},
{name: "relation.is_transitive_iff", value: "relation.is_transitive_iff", meta: "relation.is_transitive iff"},
{name: "relation.congruence_and", value: "relation.congruence_and", meta: "relation.congruence2 iff iff iff and"},
{name: "relation.is_transitive_eq", value: "relation.is_transitive_eq", meta: "∀ (T : Type), relation.is_transitive eq"},
{name: "relation.congruence_implies_compose", value: "relation.congruence_implies_compose", meta: "∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f1 : T1 → Prop}, relation.congruence R1 iff f1 → (∀ {f2 : T1 → Prop}, relation.congruence R1 iff f2 → relation.congruence R1 iff (λ (x : T1), imp (f1 x) (f2 x)))"},
{name: "relation.congruence_or", value: "relation.congruence_or", meta: "relation.congruence2 iff iff iff or"},
{name: "relation.is_reflexive_iff", value: "relation.is_reflexive_iff", meta: "relation.is_reflexive iff"},
{name: "relation.is_equivalence_eq", value: "relation.is_equivalence_eq", meta: "∀ (T : Type), relation.is_equivalence eq"},
{name: "relation.congruence_not", value: "relation.congruence_not", meta: "relation.congruence iff iff not"},
{name: "relation.general_operations.subst", value: "relation.general_operations.subst", meta: "∀ {T : Type} (R : T → T → Prop) ⦃P : T → Prop⦄ [C : relation.congruence R iff P] {a b : T}, R a b → P a → P b"},
{name: "relation.congruence_iff_compose", value: "relation.congruence_iff_compose", meta: "∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f1 : T1 → Prop}, relation.congruence R1 iff f1 → (∀ {f2 : T1 → Prop}, relation.congruence R1 iff f2 → relation.congruence R1 iff (λ (x : T1), iff (f1 x) (f2 x)))"},
{name: "relation.iff_ops.subst", value: "relation.iff_ops.subst", meta: "∀ {P : Prop → Prop} [C : relation.congruence iff iff P] {a b : Prop}, iff a b → P a → P b"},
{name: "relation.iff_ops.trans", value: "relation.iff_ops.trans", meta: "∀ {a b c : Prop}, iff a b → iff b c → iff a c"},
{name: "relation.congruence_iff", value: "relation.congruence_iff", meta: "relation.congruence2 iff iff iff iff"},
{name: "relation.iff_ops.refl", value: "relation.iff_ops.refl", meta: "∀ (a : Prop), iff a a"},
{name: "relation.iff.subst", value: "relation.iff.subst", meta: "∀ {P : Prop → Prop} [C : relation.congruence iff iff P] {a b : Prop}, iff a b → P a → P b"},
{name: "relation.congruence_not_compose", value: "relation.congruence_not_compose", meta: "∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f : T1 → Prop}, relation.congruence R1 iff f → relation.congruence R1 iff (λ (x : T1), not (f x))"},
{name: "relation.congruence_imp", value: "relation.congruence_imp", meta: "relation.congruence2 iff iff iff imp"},
{name: "relation.congruence_and_compose", value: "relation.congruence_and_compose", meta: "∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f1 : T1 → Prop}, relation.congruence R1 iff f1 → (∀ {f2 : T1 → Prop}, relation.congruence R1 iff f2 → relation.congruence R1 iff (λ (x : T1), and (f1 x) (f2 x)))"},
{name: "relation.iff_ops.symm", value: "relation.iff_ops.symm", meta: "∀ {a b : Prop}, iff a b → iff b a"},
{name: "relation.is_symmetric_iff", value: "relation.is_symmetric_iff", meta: "relation.is_symmetric iff"},
{name: "relation.mp_like_iff", value: "relation.mp_like_iff", meta: "Π (a b : Prop) (H : iff a b), relation.mp_like H"},
{name: "relation.is_symmetric_eq", value: "relation.is_symmetric_eq", meta: "∀ (T : Type), relation.is_symmetric eq"},
{name: "priority.max", value: "priority.max", meta: "num"},
{name: "priority.default", value: "priority.default", meta: "num"},
{name: "prod.pr1", value: "prod.pr1", meta: "Π {A : Type} {B : Type}, prod A B → A"},
{name: "prod.mk", value: "prod.mk", meta: "Π {A : Type} {B : Type}, A → B → prod A B"},
{name: "prod.pr2", value: "prod.pr2", meta: "Π {A : Type} {B : Type}, prod A B → B"},
{name: "prod.destruct", value: "prod.destruct", meta: "∀ {A : Type} {B : Type} {P : prod A B → Prop} (p : prod A B), (∀ (a : A) (b : B), P (prod.mk a b)) → P p"},
{name: "prod.prod_ext", value: "prod.prod_ext", meta: "∀ {A : Type} {B : Type} (p : prod A B), eq (pair (prod.pr1 p) (prod.pr2 p)) p"},
{name: "prod.equal", value: "prod.equal", meta: "∀ {A : Type} {B : Type} {p₁ p₂ : prod A B}, eq (prod.pr1 p₁) (prod.pr1 p₂) → eq (prod.pr2 p₁) (prod.pr2 p₂) → eq p₁ p₂"},
{name: "pair", value: "pair", meta: "Π {A : Type} {B : Type}, A → B → prod A B"},
{name: "prod.is_inhabited", value: "prod.is_inhabited", meta: "Π {A : Type} {B : Type}, inhabited A → inhabited B → inhabited (prod A B)"},
{name: "prod.pr2.pair", value: "prod.pr2.pair", meta: "∀ {A : Type} {B : Type} (a : A) (b : B), eq (prod.pr2 (prod.mk a b)) b"},
{name: "prod.pair_eq", value: "prod.pair_eq", meta: "∀ {A : Type} {B : Type} {a₁ a₂ : A} {b₁ b₂ : B}, eq a₁ a₂ → eq b₁ b₂ → eq (prod.mk a₁ b₁) (prod.mk a₂ b₂)"},
{name: "prod.rec", value: "prod.rec", meta: "Π {A : Type} {B : Type} {C : prod A B → Type}, (Π (a : A) (a_1 : B), C (prod.mk a a_1)) → (Π (n : prod A B), C n)"},
{name: "prod.pr1.pair", value: "prod.pr1.pair", meta: "∀ {A : Type} {B : Type} (a : A) (b : B), eq (prod.pr1 (prod.mk a b)) a"},
{name: "prod.has_decidable_eq", value: "prod.has_decidable_eq", meta: "Π {A : Type} {B : Type}, decidable_eq A → decidable_eq B → decidable_eq (prod A B)"},
{name: "prod", value: "prod", meta: "Type → Type → Type"},
{name: "nat.gcd_dvd_left", value: "nat.gcd_dvd_left", meta: "∀ (m n : nat), nat.dvd (nat.gcd m n) m"},
{name: "nat.mod_mul_mul", value: "nat.mod_mul_mul", meta: "∀ {z x y : nat}, gt z 0 → eq (nat.modulo (mul z x) (mul z y)) (mul z (nat.modulo x y))"},
{name: "nat.div_rec", value: "nat.div_rec", meta: "∀ {x y : nat}, gt y 0 → ge x y → eq (nat.idivide x y) (succ (nat.idivide (sub x y) y))"},
{name: "nat.gcd_greatest", value: "nat.gcd_greatest", meta: "∀ {m n k : nat}, nat.dvd k m → nat.dvd k n → nat.dvd k (nat.gcd m n)"},
{name: "nat.rec_measure_aux_spec", value: "nat.rec_measure_aux_spec", meta: "∀ {dom : Type} {codom : Type} (default : codom) (measure : dom → nat) (rec_val : dom → (dom → codom) → codom), (∀ (g1 g2 : dom → codom) (x : dom), (∀ (z : dom), lt (measure z) (measure x) → eq (g1 z) (g2 z)) → eq (rec_val x g1) (rec_val x g2)) → (∀ (m : nat), let f' := nat.rec_measure_aux default measure rec_val, f := nat.rec_measure default measure rec_val in ∀ (x : dom), eq (f' m x) (nat.restrict default measure f m x))"},
{name: "nat.gcd_one", value: "nat.gcd_one", meta: "∀ (n : nat), eq (nat.gcd n 1) 1"},
{name: "nat.mod_zero", value: "nat.mod_zero", meta: "∀ {x : nat}, eq (nat.modulo x 0) x"},
{name: "nat.gcd_dvd_right", value: "nat.gcd_dvd_right", meta: "∀ (m n : nat), nat.dvd (nat.gcd m n) n"},
{name: "nat.mod_add_mul_self_right", value: "nat.mod_add_mul_self_right", meta: "∀ {x y z : nat}, gt z 0 → eq (nat.modulo (add x (mul y z)) z) (nat.modulo x z)"},
{name: "nat.mod_mul_self_right", value: "nat.mod_mul_self_right", meta: "∀ {m n : nat}, eq (nat.modulo (mul m n) n) 0"},
{name: "nat.restrict", value: "nat.restrict", meta: "Π {dom : Type} {codom : Type}, codom → (dom → nat) → (dom → codom) → nat → dom → codom"},
{name: "nat.zero_div", value: "nat.zero_div", meta: "∀ {y : nat}, eq (nat.idivide 0 y) 0"},
{name: "nat.remainder_unique", value: "nat.remainder_unique", meta: "∀ {y : nat}, gt y 0 → (∀ {q1 r1 q2 r2 : nat}, lt r1 y → lt r2 y → eq (add (mul q1 y) r1) (add (mul q2 y) r2) → eq r1 r2)"},
{name: "nat.div_aux_decreasing", value: "nat.div_aux_decreasing", meta: "∀ (y : nat) (g1 g2 : nat → nat) (x : nat), (∀ (z : nat), lt z x → eq (g1 z) (g2 z)) → eq (nat.div_aux_rec y x g1) (nat.div_aux_rec y x g2)"},
{name: "nat.dvd_trans", value: "nat.dvd_trans", meta: "∀ {m n k : nat}, nat.dvd m n → nat.dvd n k → nat.dvd m k"},
{name: "nat.modulo", value: "nat.modulo", meta: "nat → nat → nat"},
{name: "nat.mod_lt_eq", value: "nat.mod_lt_eq", meta: "∀ {x y : nat}, lt x y → eq (nat.modulo x y) x"},
{name: "nat.div_one", value: "nat.div_one", meta: "∀ {n : nat}, eq (nat.idivide n 1) n"},
{name: "nat.dvd_zero", value: "nat.dvd_zero", meta: "∀ {n : nat}, nat.dvd n 0"},
{name: "nat.mod_aux_spec", value: "nat.mod_aux_spec", meta: "∀ (y x : nat), eq (nat.mod_aux y x) (ite (or (eq y 0) (lt x y)) x (nat.mod_aux y (sub x y)))"},
{name: "nat.dvd_self", value: "nat.dvd_self", meta: "∀ {n : nat}, nat.dvd n n"},
{name: "nat.div_aux_rec", value: "nat.div_aux_rec", meta: "nat → nat → (nat → nat) → nat"},
{name: "nat.gcd_dvd", value: "nat.gcd_dvd", meta: "∀ (m n : nat), and (nat.dvd (nat.gcd m n) m) (nat.dvd (nat.gcd m n) n)"},
{name: "nat.dvd_add", value: "nat.dvd_add", meta: "∀ {m n1 n2 : nat}, nat.dvd m n1 → nat.dvd m n2 → nat.dvd m (add n1 n2)"},
{name: "nat.div_less", value: "nat.div_less", meta: "∀ {x y : nat}, lt x y → eq (nat.idivide x y) 0"},
{name: "nat.gcd_aux_rec", value: "nat.gcd_aux_rec", meta: "prod nat nat → (prod nat nat → nat) → nat"},
{name: "nat.gcd_induct", value: "nat.gcd_induct", meta: "∀ {P : nat → nat → Prop} (m n : nat), (∀ (m : nat), P m 0) → (∀ (m n : nat), lt 0 n → P n (nat.modulo m n) → P m n) → P m n"},
{name: "nat.gcd_aux_spec", value: "nat.gcd_aux_spec", meta: "∀ (p : prod nat nat), eq (nat.gcd_aux p) (let x := pr1 p, y := pr2 p in ite (eq y 0) x (nat.gcd_aux (pair y (nat.modulo x y))))"},
{name: "nat.dvd_imp_div_mul_eq", value: "nat.dvd_imp_div_mul_eq", meta: "∀ {x y : nat}, nat.dvd y x → eq (mul (nat.idivide x y) y) x"},
{name: "nat.dvd_add_cancel_right", value: "nat.dvd_add_cancel_right", meta: "∀ {m n1 n2 : nat}, nat.dvd m (add n1 n2) → nat.dvd m n2 → nat.dvd m n1"},
{name: "nat.gcd", value: "nat.gcd", meta: "nat → nat → nat"},
{name: "nat.mod_self", value: "nat.mod_self", meta: "∀ {n : nat}, eq (nat.modulo n n) 0"},
{name: "nat.div_mul_mul", value: "nat.div_mul_mul", meta: "∀ {z x y : nat}, gt z 0 → eq (nat.idivide (mul z x) (mul z y)) (nat.idivide x y)"},
{name: "nat.rec_measure_aux", value: "nat.rec_measure_aux", meta: "Π {dom : Type} {codom : Type}, codom → (dom → nat) → (dom → (dom → codom) → codom) → nat → dom → codom"},
{name: "nat.pos_div_self", value: "nat.pos_div_self", meta: "∀ {n : nat}, gt n 0 → eq (nat.idivide n n) 1"},
{name: "nat.div_mod_eq", value: "nat.div_mod_eq", meta: "∀ {x y : nat}, eq x (add (mul (nat.idivide x y) y) (nat.modulo x y))"},
{name: "nat.idivide", value: "nat.idivide", meta: "nat → nat → nat"},
{name: "nat.dvd", value: "nat.dvd", meta: "nat → nat → Prop"},
{name: "nat.dvd_iff_exists_mul", value: "nat.dvd_iff_exists_mul", meta: "∀ {x y : nat}, iff (nat.dvd x y) (Exists (λ (z : nat), eq (mul z x) y))"},
{name: "nat.div_aux", value: "nat.div_aux", meta: "nat → nat → nat"},
{name: "nat.mod_mul_self_left", value: "nat.mod_mul_self_left", meta: "∀ {m n : nat}, eq (nat.modulo (mul m n) m) 0"},
{name: "nat.gcd_zero_left", value: "nat.gcd_zero_left", meta: "∀ (x : nat), eq (nat.gcd 0 x) x"},
{name: "nat.quotient_unique", value: "nat.quotient_unique", meta: "∀ {y : nat}, gt y 0 → (∀ {q1 r1 q2 r2 : nat}, lt r1 y → lt r2 y → eq (add (mul q1 y) r1) (add (mul q2 y) r2) → eq q1 q2)"},
{name: "nat.dvd_add_cancel_left", value: "nat.dvd_add_cancel_left", meta: "∀ {m n1 n2 : nat}, nat.dvd m (add n1 n2) → nat.dvd m n1 → nat.dvd m n2"},
{name: "nat.gcd_self", value: "nat.gcd_self", meta: "∀ (n : nat), eq (nat.gcd n n) n"},
{name: "nat.mod_one", value: "nat.mod_one", meta: "∀ {x : nat}, eq (nat.modulo x 1) 0"},
{name: "nat.gcd_aux", value: "nat.gcd_aux", meta: "prod nat nat → nat"},
{name: "nat.rec_measure_spec", value: "nat.rec_measure_spec", meta: "∀ {dom : Type} {codom : Type} {default : codom} {measure : dom → nat} (rec_val : dom → (dom → codom) → codom), (∀ (g1 g2 : dom → codom) (x : dom), (∀ (z : dom), lt (measure z) (measure x) → eq (g1 z) (g2 z)) → eq (rec_val x g1) (rec_val x g2)) → (∀ (x : dom), let f := nat.rec_measure default measure rec_val in eq (f x) (rec_val x f))"},
{name: "nat.div_add_self_right", value: "nat.div_add_self_right", meta: "∀ {x z : nat}, gt z 0 → eq (nat.idivide (add x z) z) (succ (nat.idivide x z))"},
{name: "nat.mod_lt", value: "nat.mod_lt", meta: "∀ {x y : nat}, gt y 0 → lt (nat.modulo x y) y"},
{name: "nat.gcd_aux_decreasing", value: "nat.gcd_aux_decreasing", meta: "∀ (g1 g2 : prod nat nat → nat) (p : prod nat nat), (∀ (p' : prod nat nat), lt (nat.gcd_aux_measure p') (nat.gcd_aux_measure p) → eq (g1 p') (g2 p')) → eq (nat.gcd_aux_rec p g1) (nat.gcd_aux_rec p g2)"},
{name: "nat.mod_rec", value: "nat.mod_rec", meta: "∀ {x y : nat}, gt y 0 → ge x y → eq (nat.modulo x y) (nat.modulo (sub x y) y)"},
{name: "nat.mod_aux", value: "nat.mod_aux", meta: "nat → nat → nat"},
{name: "nat.mod_aux_rec", value: "nat.mod_aux_rec", meta: "nat → nat → (nat → nat) → nat"},
{name: "nat.mod_add_self_right", value: "nat.mod_add_self_right", meta: "∀ {x z : nat}, gt z 0 → eq (nat.modulo (add x z) z) (nat.modulo x z)"},
{name: "nat.dvd_mul_self_right", value: "nat.dvd_mul_self_right", meta: "∀ {m n : nat}, nat.dvd m (mul n m)"},
{name: "nat.one_dvd", value: "nat.one_dvd", meta: "∀ {n : nat}, nat.dvd 1 n"},
{name: "nat.dvd_mul_self_left", value: "nat.dvd_mul_self_left", meta: "∀ {m n : nat}, nat.dvd m (mul m n)"},
{name: "nat.restrict_not_lt_eq", value: "nat.restrict_not_lt_eq", meta: "∀ {dom : Type} {codom : Type} (default : codom) (measure : dom → nat) (f : dom → codom) (m : nat) (x : dom), not (lt (measure x) m) → eq (nat.restrict default measure f m x) default"},
{name: "nat.zero_mod", value: "nat.zero_mod", meta: "∀ {y : nat}, eq (nat.modulo 0 y) 0"},
{name: "nat.div_add_mul_self_right", value: "nat.div_add_mul_self_right", meta: "∀ {x y z : nat}, gt z 0 → eq (nat.idivide (add x (mul y z)) z) (add (nat.idivide x z) y)"},
{name: "nat.rec_measure", value: "nat.rec_measure", meta: "Π {dom : Type} {codom : Type}, codom → (dom → nat) → (dom → (dom → codom) → codom) → dom → codom"},
{name: "nat.div_aux_spec", value: "nat.div_aux_spec", meta: "∀ (y x : nat), eq (nat.div_aux y x) (ite (or (eq y 0) (lt x y)) 0 (succ (nat.div_aux y (sub x y))))"},
{name: "nat.mod_aux_decreasing", value: "nat.mod_aux_decreasing", meta: "∀ (y : nat) (g1 g2 : nat → nat) (x : nat), (∀ (z : nat), lt z x → eq (g1 z) (g2 z)) → eq (nat.mod_aux_rec y x g1) (nat.mod_aux_rec y x g2)"},
{name: "nat.gcd_zero", value: "nat.gcd_zero", meta: "∀ (x : nat), eq (nat.gcd x 0) x"},
{name: "nat.dvd_iff_mod_eq_zero", value: "nat.dvd_iff_mod_eq_zero", meta: "∀ {x y : nat}, iff (nat.dvd x y) (eq (nat.modulo y x) 0)"},
{name: "nat.gcd_pos", value: "nat.gcd_pos", meta: "∀ (m : nat) {n : nat}, gt n 0 → eq (nat.gcd m n) (nat.gcd n (nat.modulo m n))"},
{name: "nat.gcd_def", value: "nat.gcd_def", meta: "∀ (x y : nat), eq (nat.gcd x y) (ite (eq y 0) x (nat.gcd y (nat.modulo x y)))"},
{name: "nat.div_zero", value: "nat.div_zero", meta: "∀ {x : nat}, eq (nat.idivide x 0) 0"},
{name: "nat.restrict_lt_eq", value: "nat.restrict_lt_eq", meta: "∀ {dom : Type} {codom : Type} (default : codom) (measure : dom → nat) (f : dom → codom) (m : nat) (x : dom), lt (measure x) m → eq (nat.restrict default measure f m x) (f x)"},
{name: "nat.dvd_sub", value: "nat.dvd_sub", meta: "∀ {m n1 n2 : nat}, nat.dvd m n1 → nat.dvd m n2 → nat.dvd m (sub n1 n2)"},
{name: "nat.zero_dvd_iff", value: "nat.zero_dvd_iff", meta: "∀ {n : nat}, eq (nat.dvd 0 n) (eq n 0)"},
{name: "nat.mul_eq_imp_dvd", value: "nat.mul_eq_imp_dvd", meta: "∀ {z x y : nat}, eq (mul z y) x → nat.dvd y x"},
{name: "nat.mod_le", value: "nat.mod_le", meta: "∀ {x y : nat}, le (nat.modulo x y) x"},
{name: "nat.gcd_aux_measure", value: "nat.gcd_aux_measure", meta: "prod nat nat → nat"},
{name: "nat.gcd_succ", value: "nat.gcd_succ", meta: "∀ (m n : nat), eq (nat.gcd m (succ n)) (nat.gcd (succ n) (nat.modulo m (succ n)))"},
{name: "nat.dist_add_left", value: "nat.dist_add_left", meta: "∀ (k n m : nat), eq (nat.dist (add k n) (add k m)) (nat.dist n m)"},
{name: "nat.dist_sub_move_add", value: "nat.dist_sub_move_add", meta: "∀ {n m : nat}, ge n m → (∀ (k : nat), eq (nat.dist (nat.sub n m) k) (nat.dist n (add k m)))"},
{name: "nat.add_sub_le_left", value: "nat.add_sub_le_left", meta: "∀ {n m : nat}, le n m → eq (add (nat.sub n m) m) m"},
{name: "nat.sub_lt", value: "nat.sub_lt", meta: "∀ {x y : nat}, gt x 0 → gt y 0 → lt (nat.sub x y) x"},
{name: "nat.sub_intro", value: "nat.sub_intro", meta: "∀ {n m k : nat}, eq (add n m) k → eq (nat.sub k n) m"},
{name: "nat.dist_add_right", value: "nat.dist_add_right", meta: "∀ (n k m : nat), eq (nat.dist (add n k) (add m k)) (nat.dist n m)"},
{name: "nat.sub_sub_split", value: "nat.sub_sub_split", meta: "∀ {P : nat → nat → Prop} {n m : nat}, (∀ (k : nat), eq n (add m k) → P k 0) → (∀ (k : nat), eq m (add n k) → P 0 k) → P (nat.sub n m) (nat.sub m n)"},
{name: "nat.sub_add_left", value: "nat.sub_add_left", meta: "∀ (n m : nat), eq (nat.sub (add n m) m) n"},
{name: "nat.le_imp_sub_eq_zero", value: "nat.le_imp_sub_eq_zero", meta: "∀ {n m : nat}, le n m → eq (nat.sub n m) 0"},
{name: "nat.dist_intro", value: "nat.dist_intro", meta: "∀ {n m k : nat}, eq (add n m) k → eq (nat.dist k n) m"},
{name: "nat.left_le_max", value: "nat.left_le_max", meta: "∀ (n m : nat), le n (add n (nat.sub m n))"},
{name: "nat.sub_add_add_right", value: "nat.sub_add_add_right", meta: "∀ (n k m : nat), eq (nat.sub (add n k) (add m k)) (nat.sub n m)"},
{name: "nat.sub_one", value: "nat.sub_one", meta: "∀ (n : nat), eq (nat.sub n 1) (pred n)"},
{name: "nat.dist_self", value: "nat.dist_self", meta: "∀ (n : nat), eq (nat.dist n n) 0"},
{name: "nat.right_le_max", value: "nat.right_le_max", meta: "∀ (n m : nat), le m (nat.max n m)"},
{name: "nat.succ_sub", value: "nat.succ_sub", meta: "∀ {m n : nat}, ge m n → eq (nat.sub (succ m) n) (succ (nat.sub m n))"},
{name: "nat.sub_zero_right", value: "nat.sub_zero_right", meta: "∀ (n : nat), eq (nat.sub n 0) n"},
{name: "nat.dist_zero_right", value: "nat.dist_zero_right", meta: "∀ (n : nat), eq (nat.dist n 0) n"},
{name: "nat.sub_sub", value: "nat.sub_sub", meta: "∀ (n m k : nat), eq (nat.sub (nat.sub n m) k) (nat.sub n (add m k))"},
{name: "nat.sub_add_left2", value: "nat.sub_add_left2", meta: "∀ (n m : nat), eq (nat.sub (add n m) n) m"},
{name: "nat.mul_sub_distr_left", value: "nat.mul_sub_distr_left", meta: "∀ (n m k : nat), eq (mul n (nat.sub m k)) (nat.sub (mul n m) (mul n k))"},
{name: "nat.sub_self", value: "nat.sub_self", meta: "∀ (n : nat), eq (nat.sub n n) 0"},
{name: "nat.dist_mul_dist", value: "nat.dist_mul_dist", meta: "∀ (n m k l : nat), eq (mul (nat.dist n m) (nat.dist k l)) (nat.dist (add (mul n k) (mul m l)) (add (mul n l) (mul m k)))"},
{name: "nat.max_ge", value: "nat.max_ge", meta: "∀ {n m : nat}, ge n m → eq (add n (nat.sub m n)) n"},
{name: "nat.le_elim_sub", value: "nat.le_elim_sub", meta: "∀ {n m : nat}, le n m → Exists (λ (k : nat), eq (nat.sub m k) n)"},
{name: "nat.le_add_sub_right", value: "nat.le_add_sub_right", meta: "∀ (n m : nat), le m (add n (nat.sub m n))"},
{name: "nat.sub_succ_right", value: "nat.sub_succ_right", meta: "∀ (n m : nat), eq (nat.sub n (succ m)) (pred (nat.sub n m))"},
{name: "nat.sub_zero_left", value: "nat.sub_zero_left", meta: "∀ (n : nat), eq (nat.sub 0 n) 0"},
{name: "nat.dist_le", value: "nat.dist_le", meta: "∀ {n m : nat}, le n m → eq (nat.dist n m) (nat.sub m n)"},
{name: "nat.mul_sub_distr_right", value: "nat.mul_sub_distr_right", meta: "∀ (n m k : nat), eq (mul (nat.sub n m) k) (nat.sub (mul n k) (mul m k))"},
{name: "nat.mul_pred_left", value: "nat.mul_pred_left", meta: "∀ (n m : nat), eq (mul (pred n) m) (nat.sub (mul n m) m)"},
{name: "nat.max_le", value: "nat.max_le", meta: "∀ {n m : nat}, le n m → eq (add n (nat.sub m n)) m"},
{name: "nat.dist_mul_left", value: "nat.dist_mul_left", meta: "∀ (k n m : nat), eq (nat.dist (mul k n) (mul k m)) (mul k (nat.dist n m))"},
{name: "nat.dist_ge", value: "nat.dist_ge", meta: "∀ {n m : nat}, ge n m → eq (nat.dist n m) (nat.sub n m)"},
{name: "nat.dist", value: "nat.dist", meta: "nat → nat → nat"},
{name: "nat.triangle_inequality", value: "nat.triangle_inequality", meta: "∀ (n m k : nat), le (nat.dist n k) (add (nat.dist n m) (nat.dist m k))"},
{name: "nat.sub_eq_zero_imp_le", value: "nat.sub_eq_zero_imp_le", meta: "∀ {n m : nat}, eq (nat.sub n m) 0 → le n m"},
{name: "nat.max", value: "nat.max", meta: "nat → nat → nat"},
{name: "nat.mul_pred_right", value: "nat.mul_pred_right", meta: "∀ (n m : nat), eq (mul n (pred m)) (nat.sub (mul n m) n)"},
{name: "nat.dist_zero_left", value: "nat.dist_zero_left", meta: "∀ (n : nat), eq (nat.dist 0 n) n"},
{name: "nat.sub_triangle_inequality", value: "nat.sub_triangle_inequality", meta: "∀ (n m k : nat), le (nat.sub n k) (add (nat.sub n m) (nat.sub m k))"},
{name: "nat.sub_le_self", value: "nat.sub_le_self", meta: "∀ (n m : nat), le (nat.sub n m) n"},
{name: "nat.add_sub_assoc", value: "nat.add_sub_assoc", meta: "∀ {m k : nat}, le k m → (∀ (n : nat), eq (nat.sub (add n m) k) (add n (nat.sub m k)))"},
{name: "nat.add_sub_le", value: "nat.add_sub_le", meta: "∀ {n m : nat}, le n m → eq (add n (nat.sub m n)) m"},
{name: "nat.sub_split", value: "nat.sub_split", meta: "∀ {P : nat → Prop} {n m : nat}, (le n m → P 0) → (∀ (k : nat), eq (add m k) n → P k) → P (nat.sub n m)"},
{name: "nat.succ_sub_sub", value: "nat.succ_sub_sub", meta: "∀ (n m k : nat), eq (nat.sub (nat.sub (succ n) m) (succ k)) (nat.sub (nat.sub n m) k)"},
{name: "nat.sub_succ_succ", value: "nat.sub_succ_succ", meta: "∀ (n m : nat), eq (nat.sub (succ n) (succ m)) (nat.sub n m)"},
{name: "nat.add_sub_ge_left", value: "nat.add_sub_ge_left", meta: "∀ {n m : nat}, ge n m → eq (add (nat.sub n m) m) n"},
{name: "nat.sub_le_right", value: "nat.sub_le_right", meta: "∀ {n m : nat}, le n m → (∀ (k : nat), le (nat.sub n k) (nat.sub m k))"},
{name: "nat.dist_comm", value: "nat.dist_comm", meta: "∀ (n m : nat), eq (nat.dist n m) (nat.dist m n)"},
{name: "nat.dist_eq_intro", value: "nat.dist_eq_intro", meta: "∀ {n m k l : nat}, eq (add n m) (add k l) → eq (nat.dist n k) (nat.dist l m)"},
{name: "nat.dist_mul_right", value: "nat.dist_mul_right", meta: "∀ (n k m : nat), eq (nat.dist (mul n k) (mul m k)) (mul (nat.dist n m) k)"},
{name: "nat.sub", value: "nat.sub", meta: "nat → nat → nat"},
{name: "nat.dist_eq_zero", value: "nat.dist_eq_zero", meta: "∀ {n m : nat}, eq (nat.dist n m) 0 → eq n m"},
{name: "nat.succ_sub_one", value: "nat.succ_sub_one", meta: "∀ (n : nat), eq (nat.sub (succ n) 1) n"},
{name: "nat.dist_add_le_add_dist", value: "nat.dist_add_le_add_dist", meta: "∀ (n m k l : nat), le (nat.dist (add n m) (add k l)) (add (nat.dist n k) (nat.dist m l))"},
{name: "nat.dist_sub_move_add'", value: "nat.dist_sub_move_add'", meta: "∀ {k m : nat}, ge k m → (∀ (n : nat), eq (nat.dist n (nat.sub k m)) (nat.dist (add n m) k))"},
{name: "nat.add_sub_ge", value: "nat.add_sub_ge", meta: "∀ {n m : nat}, ge n m → eq (add n (nat.sub m n)) n"},
{name: "nat.sub_comm", value: "nat.sub_comm", meta: "∀ (m n k : nat), eq (nat.sub (nat.sub m n) k) (nat.sub (nat.sub m k) n)"},
{name: "nat.dist_ge_add_right", value: "nat.dist_ge_add_right", meta: "∀ {n m : nat}, ge n m → eq (add (nat.dist n m) m) n"},
{name: "nat.sub_add_right_eq_zero", value: "nat.sub_add_right_eq_zero", meta: "∀ (n m : nat), eq (nat.sub n (add n m)) 0"},
{name: "nat.sub_add_add_left", value: "nat.sub_add_add_left", meta: "∀ (k n m : nat), eq (nat.sub (add k n) (add k m)) (nat.sub n m)"},
{name: "nat.min", value: "nat.min", meta: "nat → nat → nat"},
{name: "nat.le_add_sub_left", value: "nat.le_add_sub_left", meta: "∀ (n m : nat), le n (add n (nat.sub m n))"},
{name: "nat.sub_le_left", value: "nat.sub_le_left", meta: "∀ {n m : nat}, le n m → (∀ (k : nat), le (nat.sub k m) (nat.sub k n))"},
{name: "nat.succ", value: "nat.succ", meta: "nat → nat"},
{name: "nat.add.one", value: "nat.add.one", meta: "∀ (n : nat), eq (nat.add n (nat.of_num 1)) (nat.succ n)"},
{name: "nat.add.succ_right", value: "nat.add.succ_right", meta: "∀ (n m : nat), eq (nat.add n (nat.succ m)) (nat.succ (nat.add n m))"},
{name: "nat.mul.succ_right", value: "nat.mul.succ_right", meta: "∀ (n m : nat), eq (nat.mul n (nat.succ m)) (nat.add (nat.mul n m) n)"},
{name: "nat.add.succ_left", value: "nat.add.succ_left", meta: "∀ (n m : nat), eq (nat.add (nat.succ n) m) (nat.succ (nat.add n m))"},
{name: "nat.add.eq_zero_right", value: "nat.add.eq_zero_right", meta: "∀ {n m : nat}, eq (nat.add n m) (nat.of_num 0) → eq m (nat.of_num 0)"},
{name: "nat.pred.zero", value: "nat.pred.zero", meta: "eq (nat.pred (nat.of_num 0)) (nat.of_num 0)"},
{name: "nat.add.comm_succ", value: "nat.add.comm_succ", meta: "∀ (n m : nat), eq (nat.add n (nat.succ m)) (nat.add m (nat.succ n))"},
{name: "nat.case", value: "nat.case", meta: "∀ {P : nat → Prop} (n : nat), P (nat.of_num 0) → (∀ (m : nat), P (nat.succ m)) → P n"},
{name: "nat.add.zero_right", value: "nat.add.zero_right", meta: "∀ (n : nat), eq (nat.add n (nat.of_num 0)) n"},
{name: "nat.rec_succ", value: "nat.rec_succ", meta: "∀ {P : nat → Type} (x : P nat.zero) (f : Π (m : nat), P m → P (nat.succ m)) (n : nat), eq (nat.rec x f (nat.succ n)) (f n (nat.rec x f n))"},
{name: "nat.mul", value: "nat.mul", meta: "nat → nat → nat"},
{name: "nat.add.comm", value: "nat.add.comm", meta: "∀ (n m : nat), eq (nat.add n m) (nat.add m n)"},
{name: "nat.add.eq_zero", value: "nat.add.eq_zero", meta: "∀ {n m : nat}, eq (nat.add n m) (nat.of_num 0) → and (eq n (nat.of_num 0)) (eq m (nat.of_num 0))"},
{name: "nat.add.eq_zero_left", value: "nat.add.eq_zero_left", meta: "∀ {n m : nat}, eq (nat.add n m) (nat.of_num 0) → eq n (nat.of_num 0)"},
{name: "nat.zero", value: "nat.zero", meta: "nat"},
{name: "nat.add.one_left", value: "nat.add.one_left", meta: "∀ (n : nat), eq (nat.add (nat.of_num 1) n) (nat.succ n)"},
{name: "nat.succ_ne_zero", value: "nat.succ_ne_zero", meta: "∀ (n : nat), ne (nat.succ n) (nat.of_num 0)"},
{name: "nat.mul.succ_left", value: "nat.mul.succ_left", meta: "∀ (n m : nat), eq (nat.mul (nat.succ n) m) (nat.add (nat.mul n m) m)"},
{name: "nat.add.move_succ", value: "nat.add.move_succ", meta: "∀ (n m : nat), eq (nat.add (nat.succ n) m) (nat.add n (nat.succ m))"},
{name: "nat.pred.succ", value: "nat.pred.succ", meta: "∀ (n : nat), eq (nat.pred (nat.succ n)) n"},
{name: "nat.rec_on", value: "nat.rec_on", meta: "Π {P : nat → Type} (n : nat), P nat.zero → (Π (m : nat), P m → P (nat.succ m)) → P n"},
{name: "nat.add.cancel_left", value: "nat.add.cancel_left", meta: "∀ {n m k : nat}, eq (nat.add n m) (nat.add n k) → eq m k"},
{name: "nat.mul.one_left", value: "nat.mul.one_left", meta: "∀ (n : nat), eq (nat.mul (nat.of_num 1) n) n"},
{name: "nat.mul.distr_left", value: "nat.mul.distr_left", meta: "∀ (n m k : nat), eq (nat.mul n (nat.add m k)) (nat.add (nat.mul n m) (nat.mul n k))"},
{name: "nat.pred", value: "nat.pred", meta: "nat → nat"},
{name: "nat.has_decidable_eq", value: "nat.has_decidable_eq", meta: "decidable_eq nat"},
{name: "nat.discriminate", value: "nat.discriminate", meta: "∀ {B : Prop} {n : nat}, (eq n (nat.of_num 0) → B) → (∀ (m : nat), eq n (nat.succ m) → B) → B"},
{name: "nat.add.zero_left", value: "nat.add.zero_left", meta: "∀ (n : nat), eq (nat.add (nat.of_num 0) n) n"},
{name: "nat.rec_zero", value: "nat.rec_zero", meta: "∀ {P : nat → Type} (x : P nat.zero) (f : Π (m : nat), P m → P (nat.succ m)), eq (nat.rec x f nat.zero) x"},
{name: "nat.induction_on", value: "nat.induction_on", meta: "∀ {P : nat → Prop} (a : nat), P nat.zero → (∀ (n : nat), P n → P (nat.succ n)) → P a"},
{name: "nat.succ.ne_self", value: "nat.succ.ne_self", meta: "∀ {n : nat}, ne (nat.succ n) n"},
{name: "nat.add", value: "nat.add", meta: "nat → nat → nat"},
{name: "nat.mul.assoc", value: "nat.mul.assoc", meta: "∀ (n m k : nat), eq (nat.mul (nat.mul n m) k) (nat.mul n (nat.mul m k))"},
{name: "nat.induction_plus_one", value: "nat.induction_plus_one", meta: "∀ {P : nat → Prop} (a : nat), P (nat.of_num 0) → (∀ (n : nat), P n → P (nat.add n (nat.of_num 1))) → P a"},
{name: "nat.mul.zero_right", value: "nat.mul.zero_right", meta: "∀ (n : nat), eq (nat.mul n (nat.of_num 0)) (nat.of_num 0)"},
{name: "nat.mul.zero_left", value: "nat.mul.zero_left", meta: "∀ (n : nat), eq (nat.mul (nat.of_num 0) n) (nat.of_num 0)"},
{name: "nat.mul.eq_zero", value: "nat.mul.eq_zero", meta: "∀ {n m : nat}, eq (nat.mul n m) (nat.of_num 0) → or (eq n (nat.of_num 0)) (eq m (nat.of_num 0))"},
{name: "nat.rec", value: "nat.rec", meta: "Π {C : nat → Type}, C nat.zero → (Π (a : nat), C a → C (nat.succ a)) → (Π (n : nat), C n)"},
{name: "nat.mul.right_comm", value: "nat.mul.right_comm", meta: "∀ (n m k : nat), eq (nat.mul (nat.mul n m) k) (nat.mul (nat.mul n k) m)"},
{name: "nat.mul.one_right", value: "nat.mul.one_right", meta: "∀ (n : nat), eq (nat.mul n (nat.of_num 1)) n"},
{name: "nat.add.right_comm", value: "nat.add.right_comm", meta: "∀ (n m k : nat), eq (nat.add (nat.add n m) k) (nat.add (nat.add n k) m)"},
{name: "nat.zero_or_succ_pred", value: "nat.zero_or_succ_pred", meta: "∀ (n : nat), or (eq n (nat.of_num 0)) (eq n (nat.succ (nat.pred n)))"},
{name: "nat.add.left_comm", value: "nat.add.left_comm", meta: "∀ (n m k : nat), eq (nat.add n (nat.add m k)) (nat.add m (nat.add n k))"},
{name: "nat.add.assoc", value: "nat.add.assoc", meta: "∀ (n m k : nat), eq (nat.add (nat.add n m) k) (nat.add n (nat.add m k))"},
{name: "nat.succ.inj", value: "nat.succ.inj", meta: "∀ {n m : nat}, eq (nat.succ n) (nat.succ m) → eq n m"},
{name: "nat", value: "nat", meta: "Type"},
{name: "nat.zero_or_exists_succ", value: "nat.zero_or_exists_succ", meta: "∀ (n : nat), or (eq n (nat.of_num 0)) (Exists (λ (k : nat), eq n (nat.succ k)))"},
{name: "nat.add.cancel_right", value: "nat.add.cancel_right", meta: "∀ {n m k : nat}, eq (nat.add n m) (nat.add k m) → eq n k"},
{name: "nat.sub_induction", value: "nat.sub_induction", meta: "∀ {P : nat → nat → Prop} (n m : nat), (∀ (m : nat), P (nat.of_num 0) m) → (∀ (n : nat), P (nat.succ n) (nat.of_num 0)) → (∀ (n m : nat), P n m → P (nat.succ n) (nat.succ m)) → P n m"},
{name: "nat.mul.distr_right", value: "nat.mul.distr_right", meta: "∀ (n m k : nat), eq (nat.mul (nat.add n m) k) (nat.add (nat.mul n k) (nat.mul m k))"},
{name: "nat.two_step_induction_on", value: "nat.two_step_induction_on", meta: "∀ {P : nat → Prop} (a : nat), P (nat.of_num 0) → P (nat.of_num 1) → (∀ (n : nat), P n → P (nat.succ n) → P (nat.succ (nat.succ n))) → P a"},
{name: "nat.mul.comm", value: "nat.mul.comm", meta: "∀ (n m : nat), eq (nat.mul n m) (nat.mul m n)"},
{name: "nat.of_num", value: "nat.of_num", meta: "num → nat"},
{name: "nat.mul.left_comm", value: "nat.mul.left_comm", meta: "∀ (n m k : nat), eq (nat.mul n (nat.mul m k)) (nat.mul m (nat.mul n k))"},
{name: "nat.is_inhabited", value: "nat.is_inhabited", meta: "inhabited nat"},
{name: "nat.mul_le_cancel_left", value: "nat.mul_le_cancel_left", meta: "∀ {n m k : nat}, nat.gt k 0 → nat.le (mul k n) (mul k m) → nat.le n m"},
{name: "nat.le_elim", value: "nat.le_elim", meta: "∀ {n m : nat}, nat.le n m → Exists (λ (k : nat), eq (add n k) m)"},
{name: "nat.lt", value: "nat.lt", meta: "nat → nat → Prop"},
{name: "nat.pred_le_imp_le_or_eq", value: "nat.pred_le_imp_le_or_eq", meta: "∀ {n m : nat}, nat.le (pred n) m → or (nat.le n m) (eq n (succ m))"},
{name: "nat.succ_le_cancel", value: "nat.succ_le_cancel", meta: "∀ {n m : nat}, nat.le (succ n) (succ m) → nat.le n m"},
{name: "nat.le_imp_lt_or_eq", value: "nat.le_imp_lt_or_eq", meta: "∀ {n m : nat}, nat.le n m → or (nat.lt n m) (eq n m)"},
{name: "nat.add_pos_right", value: "nat.add_pos_right", meta: "∀ {n k : nat}, nat.gt k 0 → nat.gt (add n k) n"},
{name: "nat.add_le_right", value: "nat.add_le_right", meta: "∀ {n m : nat}, nat.le n m → (∀ (k : nat), nat.le (add n k) (add m k))"},
{name: "nat.le_pred_self", value: "nat.le_pred_self", meta: "∀ (n : nat), nat.le (pred n) n"},
{name: "nat.lt_def", value: "nat.lt_def", meta: "∀ (n m : nat), eq (nat.lt n m) (nat.le (succ n) m)"},
{name: "nat.pos_imp_eq_succ", value: "nat.pos_imp_eq_succ", meta: "∀ {n : nat}, nat.gt n 0 → Exists (λ (l : nat), eq n (succ l))"},
{name: "nat.ge_decidable", value: "nat.ge_decidable", meta: "Π (n m : nat), decidable (nat.ge n m)"},
{name: "nat.mul_pos_imp_pos_right", value: "nat.mul_pos_imp_pos_right", meta: "∀ {m n : nat}, nat.gt (mul n m) 0 → nat.gt m 0"},
{name: "nat.add_le_inv", value: "nat.add_le_inv", meta: "∀ {n m k l : nat}, nat.le (add n m) (add k l) → nat.le k n → nat.le m l"},
{name: "nat.mul_eq_one_left", value: "nat.mul_eq_one_left", meta: "∀ {n m : nat}, eq (mul n m) 1 → eq n 1"},
{name: "nat.lt_add_succ", value: "nat.lt_add_succ", meta: "∀ (n m : nat), nat.lt n (add n (succ m))"},
{name: "nat.lt_imp_not_ge", value: "nat.lt_imp_not_ge", meta: "∀ {n m : nat}, nat.lt n m → not (nat.ge n m)"},
{name: "nat.add_lt_cancel_left", value: "nat.add_lt_cancel_left", meta: "∀ {n m k : nat}, nat.lt (add k n) (add k m) → nat.lt n m"},
{name: "nat.pred_le", value: "nat.pred_le", meta: "∀ {n m : nat}, nat.le n m → nat.le (pred n) (pred m)"},
{name: "nat.lt_imp_le", value: "nat.lt_imp_le", meta: "∀ {n m : nat}, nat.lt n m → nat.le n m"},
{name: "nat.self_le_succ", value: "nat.self_le_succ", meta: "∀ (n : nat), nat.le n (succ n)"},
{name: "nat.lt_imp_le_succ", value: "nat.lt_imp_le_succ", meta: "∀ {n m : nat}, nat.lt n m → nat.le (succ n) m"},
{name: "nat.succ_imp_pos", value: "nat.succ_imp_pos", meta: "∀ {n m : nat}, eq n (succ m) → nat.gt n 0"},
{name: "nat.lt_antisym", value: "nat.lt_antisym", meta: "∀ {n m : nat}, nat.lt n m → not (nat.lt m n)"},
{name: "nat.add_le_cancel_left", value: "nat.add_le_cancel_left", meta: "∀ {n m k : nat}, nat.le (add k n) (add k m) → nat.le n m"},
{name: "nat.not_lt_zero", value: "nat.not_lt_zero", meta: "∀ (n : nat), not (nat.lt n 0)"},
{name: "nat.succ_pos", value: "nat.succ_pos", meta: "∀ (n : nat), nat.lt 0 (succ n)"},
{name: "nat.add_lt_cancel_right", value: "nat.add_lt_cancel_right", meta: "∀ {n m k : nat}, nat.lt (add n k) (add m k) → nat.lt n m"},
{name: "nat.lt_imp_ne", value: "nat.lt_imp_ne", meta: "∀ {n m : nat}, nat.lt n m → ne n m"},
{name: "nat.mul_cancel_left_or", value: "nat.mul_cancel_left_or", meta: "∀ {n m k : nat}, eq (mul n m) (mul n k) → or (eq n 0) (eq m k)"},
{name: "nat.mul_cancel_left", value: "nat.mul_cancel_left", meta: "∀ {m k n : nat}, nat.gt n 0 → eq (mul n m) (mul n k) → eq m k"},
{name: "nat.mul_eq_one_right", value: "nat.mul_eq_one_right", meta: "∀ {n m : nat}, eq (mul n m) 1 → eq m 1"},
{name: "nat.mul_cancel_right", value: "nat.mul_cancel_right", meta: "∀ {n m k : nat}, nat.gt m 0 → eq (mul n m) (mul k m) → eq n k"},
{name: "nat.add_le_left", value: "nat.add_le_left", meta: "∀ {n m : nat}, nat.le n m → (∀ (k : nat), nat.le (add k n) (add k m))"},
{name: "nat.not_le_imp_gt", value: "nat.not_le_imp_gt", meta: "∀ {n m : nat}, not (nat.le n m) → nat.gt n m"},
{name: "nat.case_zero_pos", value: "nat.case_zero_pos", meta: "∀ {P : nat → Prop} (y : nat), P 0 → (∀ {y : nat}, nat.gt y 0 → P y) → P y"},
{name: "nat.le_add_left", value: "nat.le_add_left", meta: "∀ (n m : nat), nat.le n (add m n)"},
{name: "nat.succ_le", value: "nat.succ_le", meta: "∀ {n m : nat}, nat.le n m → nat.le (succ n) (succ m)"},
{name: "nat.le_total", value: "nat.le_total", meta: "∀ (n m : nat), or (nat.le n m) (nat.le m n)"},
{name: "nat.lt_succ_imp_le", value: "nat.lt_succ_imp_le", meta: "∀ {n m : nat}, nat.lt n (succ m) → nat.le n m"},
{name: "nat.mul_le_cancel_right", value: "nat.mul_le_cancel_right", meta: "∀ {n k m : nat}, nat.gt m 0 → nat.le (mul n m) (mul k m) → nat.le n k"},
{name: "nat.mul_cancel_right_or", value: "nat.mul_cancel_right_or", meta: "∀ {n m k : nat}, eq (mul n m) (mul k m) → or (eq m 0) (eq n k)"},
{name: "nat.ne_zero_imp_pos", value: "nat.ne_zero_imp_pos", meta: "∀ {n : nat}, ne n 0 → nat.gt n 0"},
{name: "nat.add_le", value: "nat.add_le", meta: "∀ {n m k l : nat}, nat.le n k → nat.le m l → nat.le (add n m) (add k l)"},
{name: "nat.add_le_cancel_right", value: "nat.add_le_cancel_right", meta: "∀ {n m k : nat}, nat.le (add n k) (add m k) → nat.le n m"},
{name: "nat.le_zero", value: "nat.le_zero", meta: "∀ {n : nat}, nat.le n 0 → eq n 0"},
{name: "nat.not_succ_zero_le", value: "nat.not_succ_zero_le", meta: "∀ (n : nat), not (nat.le (succ n) 0)"},
{name: "nat.trichotomy", value: "nat.trichotomy", meta: "∀ (n m : nat), or (nat.lt n m) (or (eq n m) (nat.gt n m))"},
{name: "nat.le_imp_lt_succ", value: "nat.le_imp_lt_succ", meta: "∀ {n m : nat}, nat.le n m → nat.lt n (succ m)"},
{name: "nat.add_lt_le", value: "nat.add_lt_le", meta: "∀ {n m k l : nat}, nat.lt n k → nat.le m l → nat.lt (add n m) (add k l)"},
{name: "nat.trichotomy_alt", value: "nat.trichotomy_alt", meta: "∀ (n m : nat), or (or (nat.lt n m) (eq n m)) (nat.gt n m)"},
{name: "nat.case_strong_induction_on", value: "nat.case_strong_induction_on", meta: "∀ {P : nat → Prop} (a : nat), P 0 → (∀ (n : nat), (∀ (m : nat), nat.le m n → P m) → P (succ n)) → P a"},
{name: "nat.add_pos_left", value: "nat.add_pos_left", meta: "∀ {n k : nat}, nat.gt k 0 → nat.gt (add k n) n"},
{name: "nat.mul_lt_cancel_left", value: "nat.mul_lt_cancel_left", meta: "∀ {n m k : nat}, nat.lt (mul k n) (mul k m) → nat.lt n m"},
{name: "nat.lt_decidable", value: "nat.lt_decidable", meta: "Π (n m : nat), decidable (nat.lt n m)"},
{name: "nat.le_imp_not_gt", value: "nat.le_imp_not_gt", meta: "∀ {n m : nat}, nat.le n m → not (nat.gt n m)"},
{name: "nat.add_lt", value: "nat.add_lt", meta: "∀ {n m k l : nat}, nat.lt n k → nat.lt m l → nat.lt (add n m) (add k l)"},
{name: "nat.gt", value: "nat.gt", meta: "nat → nat → Prop"},
{name: "nat.le_imp_succ_le_or_eq", value: "nat.le_imp_succ_le_or_eq", meta: "∀ {n m : nat}, nat.le n m → or (nat.le (succ n) m) (eq n m)"},
{name: "nat.not_lt_imp_ge", value: "nat.not_lt_imp_ge", meta: "∀ {n m : nat}, not (nat.lt n m) → nat.ge n m"},
{name: "nat.mul_pos", value: "nat.mul_pos", meta: "∀ {n m : nat}, nat.gt n 0 → nat.gt m 0 → nat.gt (mul n m) 0"},
{name: "nat.strong_induction_on", value: "nat.strong_induction_on", meta: "∀ {P : nat → Prop} (n : nat), (∀ (n : nat), (∀ (m : nat), nat.lt m n → P m) → P n) → P n"},
{name: "nat.le_ne_imp_lt", value: "nat.le_ne_imp_lt", meta: "∀ {n m : nat}, nat.le n m → ne n m → nat.lt n m"},
{name: "nat.le_succ_imp_lt", value: "nat.le_succ_imp_lt", meta: "∀ {n m : nat}, nat.le (succ n) m → nat.lt n m"},
{name: "nat.add_lt_right", value: "nat.add_lt_right", meta: "∀ {n m : nat}, nat.lt n m → (∀ (k : nat), nat.lt (add n k) (add m k))"},
{name: "nat.lt_le_trans", value: "nat.lt_le_trans", meta: "∀ {n m k : nat}, nat.lt n m → nat.le m k → nat.lt n k"},
{name: "nat.le_intro", value: "nat.le_intro", meta: "∀ {n m k : nat}, eq (add n k) m → nat.le n m"},
{name: "nat.succ_lt_cancel", value: "nat.succ_lt_cancel", meta: "∀ {n m : nat}, nat.lt (succ n) (succ m) → nat.lt n m"},
{name: "nat.mul_lt_right", value: "nat.mul_lt_right", meta: "∀ {n m k : nat}, nat.gt k 0 → nat.lt n m → nat.lt (mul n k) (mul m k)"},
{name: "nat.le_lt_trans", value: "nat.le_lt_trans", meta: "∀ {n m k : nat}, nat.le n m → nat.lt m k → nat.lt n k"},
{name: "nat.le_refl", value: "nat.le_refl", meta: "∀ (n : nat), nat.le n n"},
{name: "nat.add_le_lt", value: "nat.add_le_lt", meta: "∀ {n m k l : nat}, nat.le n k → nat.lt m l → nat.lt (add n m) (add k l)"},
{name: "nat.zero_or_pos", value: "nat.zero_or_pos", meta: "∀ {n : nat}, or (eq n 0) (nat.gt n 0)"},
{name: "nat.mul_le", value: "nat.mul_le", meta: "∀ {n m k l : nat}, nat.le n k → nat.le m l → nat.le (mul n m) (mul k l)"},
{name: "nat.le_trans", value: "nat.le_trans", meta: "∀ {n m k : nat}, nat.le n m → nat.le m k → nat.le n k"},
{name: "nat.le_ne_imp_succ_le", value: "nat.le_ne_imp_succ_le", meta: "∀ {n m : nat}, nat.le n m → ne n m → nat.le (succ n) m"},
{name: "nat.pos_imp_ne_zero", value: "nat.pos_imp_ne_zero", meta: "∀ {n : nat}, nat.gt n 0 → ne n 0"},
{name: "nat.le_add_right", value: "nat.le_add_right", meta: "∀ (n m : nat), nat.le n (add n m)"},
{name: "nat.zero_le", value: "nat.zero_le", meta: "∀ (n : nat), nat.le 0 n"},
{name: "nat.gt_decidable", value: "nat.gt_decidable", meta: "Π (n m : nat), decidable (nat.gt n m)"},
{name: "nat.mul_lt_cancel_right", value: "nat.mul_lt_cancel_right", meta: "∀ {n m k : nat}, nat.lt (mul n k) (mul m k) → nat.lt n m"},
{name: "nat.mul_lt_le", value: "nat.mul_lt_le", meta: "∀ {n m k l : nat}, nat.gt l 0 → nat.lt n k → nat.le m l → nat.lt (mul n m) (mul k l)"},
{name: "nat.le_imp_le_succ", value: "nat.le_imp_le_succ", meta: "∀ {n m : nat}, nat.le n m → nat.le n (succ m)"},
{name: "nat.le", value: "nat.le", meta: "nat → nat → Prop"},
{name: "nat.lt_imp_lt_succ", value: "nat.lt_imp_lt_succ", meta: "∀ {n m : nat}, nat.lt n m → nat.lt n (succ m)"},
{name: "nat.mul_lt_left", value: "nat.mul_lt_left", meta: "∀ {n m k : nat}, nat.gt k 0 → nat.lt n m → nat.lt (mul k n) (mul k m)"},
{name: "nat.lt_trans", value: "nat.lt_trans", meta: "∀ {n m k : nat}, nat.lt n m → nat.lt m k → nat.lt n k"},
{name: "nat.le_or_gt", value: "nat.le_or_gt", meta: "∀ {n m : nat}, or (nat.le n m) (nat.gt n m)"},
{name: "nat.mul_le_left", value: "nat.mul_le_left", meta: "∀ {n m : nat}, nat.le n m → (∀ (k : nat), nat.le (mul k n) (mul k m))"},
{name: "nat.mul_le_right", value: "nat.mul_le_right", meta: "∀ {n m : nat}, nat.le n m → (∀ (k : nat), nat.le (mul n k) (mul m k))"},
{name: "nat.mul_lt", value: "nat.mul_lt", meta: "∀ {n m k l : nat}, nat.lt n k → nat.lt m l → nat.lt (mul n m) (mul k l)"},
{name: "nat.mul_pos_imp_pos_left", value: "nat.mul_pos_imp_pos_left", meta: "∀ {n m : nat}, nat.gt (mul n m) 0 → nat.gt n 0"},
{name: "nat.lt_irrefl", value: "nat.lt_irrefl", meta: "∀ (n : nat), not (nat.lt n n)"},
{name: "nat.lt_imp_eq_succ", value: "nat.lt_imp_eq_succ", meta: "∀ {n m : nat}, nat.lt n m → Exists (λ (k : nat), eq m (succ k))"},
{name: "nat.succ_lt", value: "nat.succ_lt", meta: "∀ {n m : nat}, nat.lt n m → nat.lt (succ n) (succ m)"},
{name: "nat.lt_elim", value: "nat.lt_elim", meta: "∀ {n m : nat}, nat.lt n m → Exists (λ (k : nat), eq (add (succ n) k) m)"},
{name: "nat.mul_le_lt", value: "nat.mul_le_lt", meta: "∀ {n m k l : nat}, nat.gt k 0 → nat.le n k → nat.lt m l → nat.lt (mul n m) (mul k l)"},
{name: "nat.lt_intro", value: "nat.lt_intro", meta: "∀ {n m k : nat}, eq (add (succ n) k) m → nat.lt n m"},
{name: "nat.le_antisym", value: "nat.le_antisym", meta: "∀ {n m : nat}, nat.le n m → nat.le m n → eq n m"},
{name: "nat.add_lt_left", value: "nat.add_lt_left", meta: "∀ {n m : nat}, nat.lt n m → (∀ (k : nat), nat.lt (add k n) (add k m))"},
{name: "nat.le_succ_imp_le_or_eq", value: "nat.le_succ_imp_le_or_eq", meta: "∀ {n m : nat}, nat.le n (succ m) → or (nat.le n m) (eq n (succ m))"},
{name: "nat.succ_le_imp_le_and_ne", value: "nat.succ_le_imp_le_and_ne", meta: "∀ {n m : nat}, nat.le (succ n) m → and (nat.le n m) (ne n m)"},
{name: "nat.ge", value: "nat.ge", meta: "nat → nat → Prop"},
{name: "nat.le_decidable", value: "nat.le_decidable", meta: "Π (n m : nat), decidable (nat.le n m)"},
{name: "nat.self_lt_succ", value: "nat.self_lt_succ", meta: "∀ (n : nat), nat.lt n (succ n)"},
{name: "list.nth.succ", value: "list.nth.succ", meta: "∀ {T : Type} (x : T) (l : list T) (n : nat), eq (list.nth x l (succ n)) (list.nth x (list.tail l) n)"},
{name: "list.cases_on", value: "list.cases_on", meta: "∀ {T : Type} {P : list T → Prop} (l : list T), P list.nil → (∀ (x : T) (l : list T), P (list.cons x l)) → P l"},
{name: "list.head", value: "list.head", meta: "Π {T : Type}, T → list T → T"},
{name: "list.tail", value: "list.tail", meta: "Π {T : Type}, list T → list T"},
{name: "list.append.nil_left", value: "list.append.nil_left", meta: "∀ {T : Type} (t : list T), eq (list.append list.nil t) t"},
{name: "list.find.not_mem", value: "list.find.not_mem", meta: "∀ {T : Type} [H : decidable_eq T] {l : list T} {x : T}, not (list.mem x l) → eq (list.find x l) (list.length l)"},
{name: "list.cons_head_tail", value: "list.cons_head_tail", meta: "∀ {T : Type} {l : list T} (x : T), ne l list.nil → eq (list.cons (list.head x l) (list.tail l)) l"},
{name: "list.rec_on", value: "list.rec_on", meta: "Π {A : Type} {C : list A → Type} (l : list A), C list.nil → (Π (h : A) (t : list A), C t → C (list.cons h t)) → C l"},
{name: "list.induction_on", value: "list.induction_on", meta: "∀ {T : Type} {P : list T → Prop} (l : list T), P list.nil → (∀ (x : T) (l : list T), P l → P (list.cons x l)) → P l"},
{name: "list.reverse.nil", value: "list.reverse.nil", meta: "∀ {T : Type}, eq (list.reverse list.nil) list.nil"},
{name: "list.cons", value: "list.cons", meta: "Π {T : Type}, T → list T → list T"},
{name: "list.mem.nil", value: "list.mem.nil", meta: "∀ {T : Type} (x : T), iff (list.mem x list.nil) false"},
{name: "list.append.cons", value: "list.append.cons", meta: "∀ {T : Type} (x : T) (s t : list T), eq (list.append (list.cons x s) t) (list.cons x (list.append s t))"},
{name: "list.mem", value: "list.mem", meta: "Π {T : Type}, T → list T → Prop"},
{name: "list.mem.or_imp_concat", value: "list.mem.or_imp_concat", meta: "∀ {T : Type} {x : T} {s t : list T}, or (list.mem x s) (list.mem x t) → list.mem x (list.append s t)"},
{name: "list.reverse.cons", value: "list.reverse.cons", meta: "∀ {T : Type} (x : T) (l : list T), eq (list.reverse (list.cons x l)) (list.concat x (list.reverse l))"},
{name: "list.append.assoc", value: "list.append.assoc", meta: "∀ {T : Type} (s t u : list T), eq (list.append (list.append s t) u) (list.append s (list.append t u))"},
{name: "list.reverse.reverse", value: "list.reverse.reverse", meta: "∀ {T : Type} (l : list T), eq (list.reverse (list.reverse l)) l"},
{name: "list.reverse.append", value: "list.reverse.append", meta: "∀ {T : Type} (s t : list T), eq (list.reverse (list.append s t)) (list.append (list.reverse t) (list.reverse s))"},
{name: "list.nth", value: "list.nth", meta: "Π {T : Type}, T → list T → nat → T"},
{name: "list.mem.concat_imp_or", value: "list.mem.concat_imp_or", meta: "∀ {T : Type} {x : T} {s t : list T}, list.mem x (list.append s t) → or (list.mem x s) (list.mem x t)"},
{name: "list.head.concat", value: "list.head.concat", meta: "∀ {T : Type} {s : list T} (t : list T) (x : T), ne s list.nil → eq (list.head x (list.append s t)) (list.head x s)"},
{name: "list.reverse.singleton", value: "list.reverse.singleton", meta: "∀ {T : Type} (x : T), eq (list.reverse (list.cons x list.nil)) (list.cons x list.nil)"},
{name: "list.append.nil_right", value: "list.append.nil_right", meta: "∀ {T : Type} (t : list T), eq (list.append t list.nil) t"},
{name: "list.reverse", value: "list.reverse", meta: "Π {T : Type}, list T → list T"},
{name: "list.append", value: "list.append", meta: "Π {T : Type}, list T → list T → list T"},
{name: "list.find.nil", value: "list.find.nil", meta: "∀ {T : Type} [H : decidable_eq T] (x : T), eq (list.find x list.nil) 0"},
{name: "list.concat.cons", value: "list.concat.cons", meta: "∀ {T : Type} (x y : T) (l : list T), eq (list.concat x (list.cons y l)) (list.cons y (list.concat x l))"},
{name: "list.concat", value: "list.concat", meta: "Π {T : Type}, T → list T → list T"},
{name: "list.head.cons", value: "list.head.cons", meta: "∀ {T : Type} (x x' : T) (t : list T), eq (list.head x' (list.cons x t)) x"},
{name: "list.mem.split", value: "list.mem.split", meta: "∀ {T : Type} {x : T} {l : list T}, list.mem x l → Exists (λ (s : list T), Exists (λ (t : list T), eq l (list.append s (list.cons x t))))"},
{name: "list.length", value: "list.length", meta: "Π {T : Type}, list T → nat"},
{name: "list.find.cons", value: "list.find.cons", meta: "∀ {T : Type} [H : decidable_eq T] (x y : T) (l : list T), eq (list.find x (list.cons y l)) (ite (eq x y) 0 (succ (list.find x l)))"},
{name: "list.tail.cons", value: "list.tail.cons", meta: "∀ {T : Type} (x : T) (l : list T), eq (list.tail (list.cons x l)) l"},
{name: "list.mem.cons", value: "list.mem.cons", meta: "∀ {T : Type} (x y : T) (l : list T), iff (list.mem x (list.cons y l)) (or (eq x y) (list.mem x l))"},
{name: "list.length.append", value: "list.length.append", meta: "∀ {T : Type} (s t : list T), eq (list.length (list.append s t)) (add (list.length s) (list.length t))"},
{name: "list.length.cons", value: "list.length.cons", meta: "∀ {T : Type} (x : T) (t : list T), eq (list.length (list.cons x t)) (succ (list.length t))"},
{name: "list.concat.eq_append", value: "list.concat.eq_append", meta: "∀ {T : Type} (x : T) (l : list T), eq (list.concat x l) (list.append l (list.cons x list.nil))"},
{name: "list.find", value: "list.find", meta: "Π {T : Type} [H : decidable_eq T], T → list T → nat"},
{name: "list.mem.concat", value: "list.mem.concat", meta: "∀ {T : Type} (x : T) (s t : list T), iff (list.mem x (list.append s t)) (or (list.mem x s) (list.mem x t))"},
{name: "list.nil", value: "list.nil", meta: "Π {T : Type}, list T"},
{name: "list.mem.is_decidable", value: "list.mem.is_decidable", meta: "Π {T : Type}, decidable_eq T → (Π (x : T) (l : list T), decidable (list.mem x l))"},
{name: "list.concat.nil", value: "list.concat.nil", meta: "∀ {T : Type} (x : T), eq (list.concat x list.nil) (list.cons x list.nil)"},
{name: "list", value: "list", meta: "Type → Type"},
{name: "list.length.nil", value: "list.length.nil", meta: "∀ {T : Type}, eq (list.length list.nil) 0"},
{name: "list.rec", value: "list.rec", meta: "Π {T : Type} {C : list T → Type}, C list.nil → (Π (a : T) (a_1 : list T), C a_1 → C (list.cons a a_1)) → (Π (n : list T), C n)"},
{name: "list.concat.eq_reverse_cons", value: "list.concat.eq_reverse_cons", meta: "∀ {T : Type} (x : T) (l : list T), eq (list.concat x l) (list.reverse (list.cons x (list.reverse l)))"},
{name: "list.head.nil", value: "list.head.nil", meta: "∀ {T : Type} (x : T), eq (list.head x list.nil) x"},
{name: "list.nth.zero", value: "list.nth.zero", meta: "∀ {T : Type} (x : T) (l : list T), eq (list.nth x l 0) (list.head x l)"},
{name: "list.tail.nil", value: "list.tail.nil", meta: "∀ {T : Type}, eq (list.tail list.nil) list.nil"},
{name: "unit.has_decidable_eq", value: "unit.has_decidable_eq", meta: "decidable_eq unit"},
{name: "unit.eq_star", value: "unit.eq_star", meta: "∀ (a : unit), eq a unit.star"},
{name: "unit", value: "unit", meta: "Type"},
{name: "unit.subsingleton", value: "unit.subsingleton", meta: "subsingleton unit"},
{name: "unit.equal", value: "unit.equal", meta: "∀ (a b : unit), eq a b"},
{name: "unit.rec", value: "unit.rec", meta: "Π {C : unit → Type}, C unit.star → (Π (n : unit), C n)"},
{name: "unit.is_inhabited", value: "unit.is_inhabited", meta: "inhabited unit"},
{name: "unit.star", value: "unit.star", meta: "unit"},
{name: "false.to_empty", value: "false.to_empty", meta: "false → empty"},
{name: "empty.elim", value: "empty.elim", meta: "Π (A : Type), empty → A"},
{name: "empty.subsingleton", value: "empty.subsingleton", meta: "subsingleton empty"},
{name: "empty", value: "empty", meta: "Type"},
{name: "false.rec_type", value: "false.rec_type", meta: "Π (A : Type), false → A"},
{name: "empty.rec", value: "empty.rec", meta: "Π (C : empty → Type) (n : empty), C n"},
{name: "pos_num.rec", value: "pos_num.rec", meta: "Π {C : pos_num → Type}, C pos_num.one → (Π (a : pos_num), C a → C (pos_num.bit1 a)) → (Π (a : pos_num), C a → C (pos_num.bit0 a)) → (Π (n : pos_num), C n)"},
{name: "pos_num.add.bit0_one", value: "pos_num.add.bit0_one", meta: "∀ (a : pos_num), eq (pos_num.add (pos_num.bit0 a) pos_num.one) (pos_num.bit1 a)"},
{name: "num.add", value: "num.add", meta: "num → num → num"},
{name: "pos_num.one", value: "pos_num.one", meta: "pos_num"},
{name: "pos_num.add.one_bit0", value: "pos_num.add.one_bit0", meta: "∀ (a : pos_num), eq (pos_num.add pos_num.one (pos_num.bit0 a)) (pos_num.bit1 a)"},
{name: "pos_num.bit0", value: "pos_num.bit0", meta: "pos_num → pos_num"},
{name: "pos_num.add.bit0_bit0", value: "pos_num.add.bit0_bit0", meta: "∀ (a b : pos_num), eq (pos_num.add (pos_num.bit0 a) (pos_num.bit0 b)) (pos_num.bit0 (pos_num.add a b))"},
{name: "num.induction_on", value: "num.induction_on", meta: "∀ {P : num → Prop} (a : num), P 0 → (∀ (p : pos_num), P (num.pos p)) → P a"},
{name: "num.pos", value: "num.pos", meta: "pos_num → num"},
{name: "num.pred.succ", value: "num.pred.succ", meta: "∀ (a : num), eq (num.pred (num.succ a)) a"},
{name: "pos_num.add.bit1_bit0", value: "pos_num.add.bit1_bit0", meta: "∀ (a b : pos_num), eq (pos_num.add (pos_num.bit1 a) (pos_num.bit0 b)) (pos_num.bit1 (pos_num.add a b))"},
{name: "num", value: "num", meta: "Type"},
{name: "num.size", value: "num.size", meta: "num → num"},
{name: "pos_num.add.one_one", value: "pos_num.add.one_one", meta: "eq (pos_num.add pos_num.one pos_num.one) (pos_num.bit0 pos_num.one)"},
{name: "pos_num.is_inhabited", value: "pos_num.is_inhabited", meta: "inhabited pos_num"},
{name: "pos_num", value: "pos_num", meta: "Type"},
{name: "num.mul", value: "num.mul", meta: "num → num → num"},
{name: "pos_num.is_one", value: "pos_num.is_one", meta: "pos_num → bool"},
{name: "pos_num.pred", value: "pos_num.pred", meta: "pos_num → pos_num"},
{name: "pos_num.pred.succ", value: "pos_num.pred.succ", meta: "∀ (a : pos_num), eq (pos_num.pred (pos_num.succ a)) a"},
{name: "pos_num.mul.one_left", value: "pos_num.mul.one_left", meta: "∀ (a : pos_num), eq (pos_num.mul pos_num.one a) a"},
{name: "num.succ", value: "num.succ", meta: "num → num"},
{name: "pos_num.mul", value: "pos_num.mul", meta: "pos_num → pos_num → pos_num"},
{name: "num.rec_on", value: "num.rec_on", meta: "Π {P : num → Type} (a : num), P 0 → (Π (p : pos_num), P (num.pos p)) → P a"},
{name: "pos_num.mul.one_right", value: "pos_num.mul.one_right", meta: "∀ (a : pos_num), eq (pos_num.mul a pos_num.one) a"},
{name: "num.rec", value: "num.rec", meta: "Π {C : num → Type}, C 0 → (Π (a : pos_num), C (num.pos a)) → (Π (n : num), C n)"},
{name: "pos_num.add.one_bit1", value: "pos_num.add.one_bit1", meta: "∀ (a : pos_num), eq (pos_num.add pos_num.one (pos_num.bit1 a)) (pos_num.succ (pos_num.bit1 a))"},
{name: "pos_num.induction_on", value: "pos_num.induction_on", meta: "∀ {P : pos_num → Prop} (a : pos_num), P pos_num.one → (∀ (n : pos_num), P n → P (pos_num.bit1 n)) → (∀ (n : pos_num), P n → P (pos_num.bit0 n)) → P a"},
{name: "pos_num.succ", value: "pos_num.succ", meta: "pos_num → pos_num"},
{name: "pos_num.rec_on", value: "pos_num.rec_on", meta: "Π {P : pos_num → Type} (a : pos_num), P pos_num.one → (Π (n : pos_num), P n → P (pos_num.bit1 n)) → (Π (n : pos_num), P n → P (pos_num.bit0 n)) → P a"},
{name: "num.is_inhabited", value: "num.is_inhabited", meta: "inhabited num"},
{name: "num.zero", value: "num.zero", meta: "num"},
{name: "pos_num.add.bit0_bit1", value: "pos_num.add.bit0_bit1", meta: "∀ (a b : pos_num), eq (pos_num.add (pos_num.bit0 a) (pos_num.bit1 b)) (pos_num.bit1 (pos_num.add a b))"},
{name: "pos_num.add", value: "pos_num.add", meta: "pos_num → pos_num → pos_num"},
{name: "pos_num.add.bit1_bit1", value: "pos_num.add.bit1_bit1", meta: "∀ (a b : pos_num), eq (pos_num.add (pos_num.bit1 a) (pos_num.bit1 b)) (pos_num.succ (pos_num.bit1 (pos_num.add a b)))"},
{name: "pos_num.bit1", value: "pos_num.bit1", meta: "pos_num → pos_num"},
{name: "num.pred", value: "num.pred", meta: "num → num"},
{name: "pos_num.succ_not_is_one", value: "pos_num.succ_not_is_one", meta: "∀ (a : pos_num), eq (pos_num.is_one (pos_num.succ a)) ff"},
{name: "pos_num.size", value: "pos_num.size", meta: "pos_num → pos_num"},
{name: "pos_num.add.bit1_one", value: "pos_num.add.bit1_one", meta: "∀ (a : pos_num), eq (pos_num.add (pos_num.bit1 a) pos_num.one) (pos_num.succ (pos_num.bit1 a))"},
{name: "sum.is_inhabited_left", value: "sum.is_inhabited_left", meta: "Π {A : Type} {B : Type}, inhabited A → inhabited (sum A B)"},
{name: "sum.inl_neq_inr", value: "sum.inl_neq_inr", meta: "∀ {A : Type} {B : Type} {a : A} {b : B}, ne (sum.inl B a) (sum.inr A b)"},
{name: "sum.inr_inj", value: "sum.inr_inj", meta: "∀ {A : Type} {B : Type} {b₁ b₂ : B}, eq (sum.inr A b₁) (sum.inr A b₂) → eq b₁ b₂"},
{name: "sum.inl", value: "sum.inl", meta: "Π {A : Type} (B : Type), A → sum A B"},
{name: "sum.inr", value: "sum.inr", meta: "Π (A : Type) {B : Type}, B → sum A B"},
{name: "sum.has_eq_decidable", value: "sum.has_eq_decidable", meta: "Π {A : Type} {B : Type}, decidable_eq A → decidable_eq B → decidable_eq (sum A B)"},
{name: "sum.rec", value: "sum.rec", meta: "Π {A : Type} {B : Type} {C : sum A B → Type}, (Π (a : A), C (sum.inl B a)) → (Π (a : B), C (sum.inr A a)) → (Π (n : sum A B), C n)"},
{name: "sum.cases_on", value: "sum.cases_on", meta: "∀ {A : Type} {B : Type} {P : sum A B → Prop} (s : sum A B), (∀ (a : A), P (sum.inl B a)) → (∀ (b : B), P (sum.inr A b)) → P s"},
{name: "sum.rec_on", value: "sum.rec_on", meta: "Π {A : Type} {B : Type} {C : sum A B → Type} (s : sum A B), (Π (a : A), C (sum.inl B a)) → (Π (b : B), C (sum.inr A b)) → C s"},
{name: "sum.inl_inj", value: "sum.inl_inj", meta: "∀ {A : Type} {B : Type} {a₁ a₂ : A}, eq (sum.inl B a₁) (sum.inl B a₂) → eq a₁ a₂"},
{name: "sum.is_inhabited_right", value: "sum.is_inhabited_right", meta: "Π {A : Type} {B : Type}, inhabited B → inhabited (sum A B)"},
{name: "sum", value: "sum", meta: "Type → Type → Type"},
{name: "bool.bor.assoc", value: "bool.bor.assoc", meta: "∀ (a b c : bool), eq (bool.bor (bool.bor a b) c) (bool.bor a (bool.bor b c))"},
{name: "bool.bor.id", value: "bool.bor.id", meta: "∀ (a : bool), eq (bool.bor a a) a"},
{name: "bool.bor.to_or", value: "bool.bor.to_or", meta: "∀ {a b : bool}, eq (bool.bor a b) bool.tt → or (eq a bool.tt) (eq b bool.tt)"},
{name: "bool.band.tt_left", value: "bool.band.tt_left", meta: "∀ (a : bool), eq (bool.band bool.tt a) a"},
{name: "bool.bor.comm", value: "bool.bor.comm", meta: "∀ (a b : bool), eq (bool.bor a b) (bool.bor b a)"},
{name: "bool.cond.ff", value: "bool.cond.ff", meta: "∀ {A : Type} (t e : A), eq (bool.cond bool.ff t e) e"},
{name: "bool.tt", value: "bool.tt", meta: "bool"},
{name: "bool.band", value: "bool.band", meta: "bool → bool → bool"},
{name: "bool.bor", value: "bool.bor", meta: "bool → bool → bool"},
{name: "bool.band.eq_tt_elim_right", value: "bool.band.eq_tt_elim_right", meta: "∀ {a b : bool}, eq (bool.band a b) bool.tt → eq b bool.tt"},
{name: "bool.is_inhabited", value: "bool.is_inhabited", meta: "inhabited bool"},
{name: "bool.band.eq_tt_elim_left", value: "bool.band.eq_tt_elim_left", meta: "∀ {a b : bool}, eq (bool.band a b) bool.tt → eq a bool.tt"},
{name: "bool.cond", value: "bool.cond", meta: "Π {A : Type}, bool → A → A → A"},
{name: "bool.rec", value: "bool.rec", meta: "Π {C : bool → Type}, C bool.ff → C bool.tt → (Π (n : bool), C n)"},
{name: "bool.band.tt_right", value: "bool.band.tt_right", meta: "∀ (a : bool), eq (bool.band a bool.tt) a"},
{name: "bool.bnot.true", value: "bool.bnot.true", meta: "eq (bool.bnot bool.tt) bool.ff"},
{name: "bool.ff", value: "bool.ff", meta: "bool"},
{name: "bool.band.ff_left", value: "bool.band.ff_left", meta: "∀ (a : bool), eq (bool.band bool.ff a) bool.ff"},
{name: "bool.cases_on", value: "bool.cases_on", meta: "∀ {p : bool → Prop} (b : bool), p bool.ff → p bool.tt → p b"},
{name: "bool.bor.tt_right", value: "bool.bor.tt_right", meta: "∀ (a : bool), eq (bool.bor a bool.tt) bool.tt"},
{name: "bool.has_decidable_eq", value: "bool.has_decidable_eq", meta: "decidable_eq bool"},
{name: "bool.rec_on", value: "bool.rec_on", meta: "Π {C : bool → Type} (b : bool), C bool.ff → C bool.tt → C b"},
{name: "bool.bor.tt_left", value: "bool.bor.tt_left", meta: "∀ (a : bool), eq (bool.bor bool.tt a) bool.tt"},
{name: "bool.bnot.bnot", value: "bool.bnot.bnot", meta: "∀ (a : bool), eq (bool.bnot (bool.bnot a)) a"},
{name: "bool.band.ff_right", value: "bool.band.ff_right", meta: "∀ (a : bool), eq (bool.band a bool.ff) bool.ff"},
{name: "bool.bnot", value: "bool.bnot", meta: "bool → bool"},
{name: "bool.bor.ff_left", value: "bool.bor.ff_left", meta: "∀ (a : bool), eq (bool.bor bool.ff a) a"},
{name: "bool", value: "bool", meta: "Type"},
{name: "bool.bnot.false", value: "bool.bnot.false", meta: "eq (bool.bnot bool.ff) bool.tt"},
{name: "bool.bor.ff_right", value: "bool.bor.ff_right", meta: "∀ (a : bool), eq (bool.bor a bool.ff) a"},
{name: "bool.band.comm", value: "bool.band.comm", meta: "∀ (a b : bool), eq (bool.band a b) (bool.band b a)"},
{name: "bool.ff_ne_tt", value: "bool.ff_ne_tt", meta: "not (eq bool.ff bool.tt)"},
{name: "bool.band.id", value: "bool.band.id", meta: "∀ (a : bool), eq (bool.band a a) a"},
{name: "bool.dichotomy", value: "bool.dichotomy", meta: "∀ (b : bool), or (eq b bool.ff) (eq b bool.tt)"},
{name: "bool.cond.tt", value: "bool.cond.tt", meta: "∀ {A : Type} (t e : A), eq (bool.cond bool.tt t e) t"},
{name: "bool.band.assoc", value: "bool.band.assoc", meta: "∀ (a b c : bool), eq (bool.band (bool.band a b) c) (bool.band a (bool.band b c))"},
{name: "int.proj_flip", value: "int.proj_flip", meta: "∀ (a : prod nat nat), eq (int.proj (flip a)) (flip (int.proj a))"},
{name: "int.neg_neg", value: "int.neg_neg", meta: "∀ (a : int.int), eq (int.neg (int.neg a)) a"},
{name: "int.mul_ne_zero", value: "int.mul_ne_zero", meta: "∀ {a b : int.int}, ne a (int.of_num 0) → ne b (int.of_num 0) → ne (int.mul a b) (int.of_num 0)"},
{name: "int.add_eq_self", value: "int.add_eq_self", meta: "∀ {a b : int.int}, eq (int.add a b) a → eq b (int.of_num 0)"},
{name: "int.rel_refl", value: "int.rel_refl", meta: "∀ {a : prod nat nat}, int.rel a a"},
{name: "int.proj_inj", value: "int.proj_inj", meta: "∀ {a b : prod nat nat}, eq (int.proj a) (int.proj b) → int.rel a b"},
{name: "int.mul_of_nat", value: "int.mul_of_nat", meta: "∀ (n m : nat), eq (int.mul (int.of_nat n) (int.of_nat m)) (int.mul (int.of_nat n) (int.of_nat m))"},
{name: "int.sub_imp_sub", value: "int.sub_imp_sub", meta: "∀ {a b c : int.int}, eq (int.sub a b) c → eq (int.sub a c) b"},
{name: "int.rep", value: "int.rep", meta: "int.int → prod nat nat"},
{name: "int.add", value: "int.add", meta: "int.int → int.int → int.int"},
{name: "int.of_nat_succ", value: "int.of_nat_succ", meta: "∀ (n : nat), eq (int.of_nat (succ n)) (int.add (int.of_nat n) (int.of_num 1))"},
{name: "int.sub_sub_assoc", value: "int.sub_sub_assoc", meta: "∀ (a b c : int.int), eq (int.sub (int.sub a b) c) (int.sub a (int.add b c))"},
{name: "int.neg_move", value: "int.neg_move", meta: "∀ {a b : int.int}, eq (int.neg a) b → eq (int.neg b) a"},
{name: "int.sub_def", value: "int.sub_def", meta: "∀ (a b : int.int), eq (int.sub a b) (int.add a (int.neg b))"},
{name: "int.mul_right_comm", value: "int.mul_right_comm", meta: "∀ (a b c : int.int), eq (int.mul (int.mul a b) c) (int.mul (int.mul a c) b)"},
{name: "int.sub_inj_left", value: "int.sub_inj_left", meta: "∀ {a b c : int.int}, eq (int.sub a b) (int.sub a c) → eq b c"},
{name: "int.to_nat_of_nat", value: "int.to_nat_of_nat", meta: "∀ (n : nat), eq (int.to_nat (int.of_nat n)) n"},
{name: "int.mul_left_distr", value: "int.mul_left_distr", meta: "∀ (a b c : int.int), eq (int.mul a (int.add b c)) (int.add (int.mul a b) (int.mul a c))"},
{name: "int.add_cancel_left", value: "int.add_cancel_left", meta: "∀ {a b c : int.int}, eq (int.add a b) (int.add a c) → eq b c"},
{name: "int.has_decidable_eq", value: "int.has_decidable_eq", meta: "decidable_eq int.int"},
{name: "int.neg_zero", value: "int.neg_zero", meta: "eq (int.neg (int.of_num 0)) (int.of_num 0)"},
{name: "int.sub_eq_zero", value: "int.sub_eq_zero", meta: "∀ {a b : int.int}, eq (int.sub a b) (int.of_num 0) → eq a b"},
{name: "int.add_inverse_right", value: "int.add_inverse_right", meta: "∀ (a : int.int), eq (int.add a (int.neg a)) (int.of_num 0)"},
{name: "int.mul_cancel_right_or", value: "int.mul_cancel_right_or", meta: "∀ {a b c : int.int}, eq (int.mul b a) (int.mul c a) → or (eq a (int.of_num 0)) (eq b c)"},
{name: "int.mul_zero_right", value: "int.mul_zero_right", meta: "∀ (a : int.int), eq (int.mul a (int.of_num 0)) (int.of_num 0)"},
{name: "int.proj_le", value: "int.proj_le", meta: "∀ {a : prod nat nat}, le (pr1 a) (pr2 a) → eq (int.proj a) (pair 0 (sub (pr2 a) (pr1 a)))"},
{name: "int.mul_neg_neg", value: "int.mul_neg_neg", meta: "∀ (a b : int.int), eq (int.mul (int.neg a) (int.neg b)) (int.mul a b)"},
{name: "int.mul_cancel_right", value: "int.mul_cancel_right", meta: "∀ {a b c : int.int}, ne c (int.of_num 0) → eq (int.mul a c) (int.mul b c) → eq a b"},
{name: "int.pos_eq_neg", value: "int.pos_eq_neg", meta: "∀ {n m : nat}, eq (int.of_nat n) (int.neg (int.of_nat m)) → and (eq n 0) (eq m 0)"},
{name: "int.proj_ge_pr2", value: "int.proj_ge_pr2", meta: "∀ {a : prod nat nat}, ge (pr1 a) (pr2 a) → eq (pr2 (int.proj a)) 0"},
{name: "int.to_nat_comp", value: "int.to_nat_comp", meta: "∀ (n m : nat), eq (int.to_nat (int.psub (pair n m))) (dist n m)"},
{name: "int.mul_neg_right", value: "int.mul_neg_right", meta: "∀ (a b : int.int), eq (int.mul a (int.neg b)) (int.neg (int.mul a b))"},
{name: "int.mul_ne_zero_right", value: "int.mul_ne_zero_right", meta: "∀ {a b : int.int}, ne (int.mul a b) (int.of_num 0) → ne b (int.of_num 0)"},
{name: "int.proj_rel", value: "int.proj_rel", meta: "∀ (a : prod nat nat), int.rel a (int.proj a)"},
{name: "int.of_num", value: "int.of_num", meta: "num → int.int"},
{name: "int.proj_le_pr1", value: "int.proj_le_pr1", meta: "∀ {a : prod nat nat}, le (pr1 a) (pr2 a) → eq (pr1 (int.proj a)) 0"},
{name: "int.proj_ge", value: "int.proj_ge", meta: "∀ {a : prod nat nat}, ge (pr1 a) (pr2 a) → eq (int.proj a) (pair (sub (pr1 a) (pr2 a)) 0)"},
{name: "int.sub_add_add_right", value: "int.sub_add_add_right", meta: "∀ (a b c : int.int), eq (int.sub (int.add a c) (int.add b c)) (int.sub a b)"},
{name: "int.sub_zero_right", value: "int.sub_zero_right", meta: "∀ (a : int.int), eq (int.sub a (int.of_num 0)) a"},
{name: "int.sub", value: "int.sub", meta: "int.int → int.int → int.int"},
{name: "int.sub_neg_neg", value: "int.sub_neg_neg", meta: "∀ (a b : int.int), eq (int.sub (int.neg a) (int.neg b)) (int.sub b a)"},
{name: "int.add_inverse_left", value: "int.add_inverse_left", meta: "∀ (a : int.int), eq (int.add (int.neg a) a) (int.of_num 0)"},
{name: "int.mul_sub_left_distr", value: "int.mul_sub_left_distr", meta: "∀ (a b c : int.int), eq (int.mul a (int.sub b c)) (int.sub (int.mul a b) (int.mul a c))"},
{name: "int.sub_imp_add", value: "int.sub_imp_add", meta: "∀ {a b c : int.int}, eq (int.sub a b) c → eq (int.add c b) a"},
{name: "int.rel_mul", value: "int.rel_mul", meta: "∀ {u u' v v' : prod nat nat}, int.rel u u' → int.rel v v' → int.rel (pair (add (mul (pr1 u) (pr1 v)) (mul (pr2 u) (pr2 v))) (add (mul (pr1 u) (pr2 v)) (mul (pr2 u) (pr1 v)))) (pair (add (mul (pr1 u') (pr1 v')) (mul (pr2 u') (pr2 v'))) (add (mul (pr1 u') (pr2 v')) (mul (pr2 u') (pr1 v'))))"},
{name: "int.of_nat_inj", value: "int.of_nat_inj", meta: "∀ {n m : nat}, eq (int.of_nat n) (int.of_nat m) → eq n m"},
{name: "int.add_comm", value: "int.add_comm", meta: "∀ (a b : int.int), eq (int.add a b) (int.add b a)"},
{name: "int.neg", value: "int.neg", meta: "int.int → int.int"},
{name: "int.mul_one_right", value: "int.mul_one_right", meta: "∀ (a : int.int), eq (int.mul a (int.of_num 1)) a"},
{name: "int.proj_le_pr2", value: "int.proj_le_pr2", meta: "∀ {a : prod nat nat}, le (pr1 a) (pr2 a) → eq (pr2 (int.proj a)) (sub (pr2 a) (pr1 a))"},
{name: "int.mul_right_distr", value: "int.mul_right_distr", meta: "∀ (a b c : int.int), eq (int.mul (int.add a b) c) (int.add (int.mul a c) (int.mul b c))"},
{name: "int.to_nat_eq_zero", value: "int.to_nat_eq_zero", meta: "∀ {a : int.int}, eq (int.to_nat a) 0 → eq a (int.of_num 0)"},
{name: "int.neg_comp", value: "int.neg_comp", meta: "∀ (n m : nat), eq (int.neg (int.psub (pair n m))) (int.psub (pair m n))"},
{name: "int.add_imp_sub_left", value: "int.add_imp_sub_left", meta: "∀ {a b c : int.int}, eq (int.add a b) c → eq (int.sub c a) b"},
{name: "int.add_comp", value: "int.add_comp", meta: "∀ (n m k l : nat), eq (int.add (int.psub (pair n m)) (int.psub (pair k l))) (int.psub (pair (add n k) (add m l)))"},
{name: "int.to_nat_add_le", value: "int.to_nat_add_le", meta: "∀ (a b : int.int), le (int.to_nat (int.add a b)) (add (int.to_nat a) (int.to_nat b))"},
{name: "int.mul_neg_left", value: "int.mul_neg_left", meta: "∀ (a b : int.int), eq (int.mul (int.neg a) b) (int.neg (int.mul a b))"},
{name: "int.add_assoc", value: "int.add_assoc", meta: "∀ (a b c : int.int), eq (int.add (int.add a b) c) (int.add a (int.add b c))"},
{name: "int.to_nat_neg", value: "int.to_nat_neg", meta: "∀ (a : int.int), eq (int.to_nat (int.neg a)) (int.to_nat a)"},
{name: "int.psub", value: "int.psub", meta: "prod nat nat → int.int"},
{name: "int", value: "int", meta: "Type"},
{name: "int.int_by_cases", value: "int.int_by_cases", meta: "∀ {P : int.int → Prop} (a : int.int), (∀ (n : nat), P (int.of_nat n)) → (∀ (n : nat), P (int.neg (int.of_nat n))) → P a"},
{name: "int.quotient", value: "int.quotient", meta: "is_quotient int.rel int.psub int.rep"},
{name: "int.proj_lt", value: "int.proj_lt", meta: "∀ {a : prod nat nat}, lt (pr1 a) (pr2 a) → eq (int.proj a) (pair 0 (sub (pr2 a) (pr1 a)))"},
{name: "int.add_zero_left", value: "int.add_zero_left", meta: "∀ (a : int.int), eq (int.add (int.of_num 0) a) a"},
{name: "int.sub_add_add_left", value: "int.sub_add_add_left", meta: "∀ (a b c : int.int), eq (int.sub (int.add c a) (int.add c b)) (int.sub a b)"},
{name: "int.mul_to_nat", value: "int.mul_to_nat", meta: "∀ (a b : int.int), eq (int.to_nat (int.mul a b)) (mul (int.to_nat a) (int.to_nat b))"},
{name: "int.add_eq_zero_right", value: "int.add_eq_zero_right", meta: "∀ {a b : int.int}, eq (int.add a b) (int.of_num 0) → eq (int.neg a) b"},
{name: "int.add_sub_assoc", value: "int.add_sub_assoc", meta: "∀ (a b c : int.int), eq (int.sub (int.add a b) c) (int.add a (int.sub b c))"},
{name: "int.mul_ne_zero_left", value: "int.mul_ne_zero_left", meta: "∀ {a b : int.int}, ne (int.mul a b) (int.of_num 0) → ne a (int.of_num 0)"},
{name: "int.sub_zero_left", value: "int.sub_zero_left", meta: "∀ (a : int.int), eq (int.sub (int.of_num 0) a) (int.neg a)"},
{name: "int.rel_add", value: "int.rel_add", meta: "∀ {a a' b b' : prod nat nat}, int.rel a a' → int.rel b b' → int.rel (map_pair2 add a b) (map_pair2 add a' b')"},
{name: "int.rel_symm", value: "int.rel_symm", meta: "∀ {a b : prod nat nat}, int.rel a b → int.rel b a"},
{name: "int.eq_zero_intro", value: "int.eq_zero_intro", meta: "∀ (n : nat), eq (int.psub (pair n n)) (int.of_num 0)"},
{name: "int.proj", value: "int.proj", meta: "prod nat nat → prod nat nat"},
{name: "int.rel_trans", value: "int.rel_trans", meta: "∀ {a b c : prod nat nat}, int.rel a b → int.rel b c → int.rel a c"},
{name: "int.mul_eq_zero", value: "int.mul_eq_zero", meta: "∀ {a b : int.int}, eq (int.mul a b) (int.of_num 0) → or (eq a (int.of_num 0)) (eq b (int.of_num 0))"},
{name: "int.add_zero_right", value: "int.add_zero_right", meta: "∀ (a : int.int), eq (int.add a (int.of_num 0)) a"},
{name: "int.neg_inj", value: "int.neg_inj", meta: "∀ {a b : int.int}, eq (int.neg a) (int.neg b) → eq a b"},
{name: "int.mul_left_comm", value: "int.mul_left_comm", meta: "∀ (a b c : int.int), eq (int.mul a (int.mul b c)) (int.mul b (int.mul a c))"},
{name: "int.of_nat", value: "int.of_nat", meta: "nat → int.int"},
{name: "int.proj_idempotent", value: "int.proj_idempotent", meta: "∀ (a : prod nat nat), eq (int.proj (int.proj a)) (int.proj a)"},
{name: "int.add_of_nat", value: "int.add_of_nat", meta: "∀ (n m : nat), eq (int.add (int.of_nat n) (int.of_nat m)) (int.of_nat (add n m))"},
{name: "int.add_sub_inverse2", value: "int.add_sub_inverse2", meta: "∀ (a b : int.int), eq (int.sub (int.add a b) a) b"},
{name: "int.neg_add_distr", value: "int.neg_add_distr", meta: "∀ (a b : int.int), eq (int.neg (int.add a b)) (int.add (int.neg a) (int.neg b))"},
{name: "int.mul_cancel_left_or", value: "int.mul_cancel_left_or", meta: "∀ {a b c : int.int}, eq (int.mul a b) (int.mul a c) → or (eq a (int.of_num 0)) (eq b c)"},
{name: "int.rel_comp", value: "int.rel_comp", meta: "∀ (n m k l : nat), iff (int.rel (pair n m) (pair k l)) (eq (add n l) (add m k))"},
{name: "int.mul", value: "int.mul", meta: "int.int → int.int → int.int"},
{name: "int.proj_zero_or", value: "int.proj_zero_or", meta: "∀ (a : prod nat nat), or (eq (pr1 (int.proj a)) 0) (eq (pr2 (int.proj a)) 0)"},
{name: "int.cases_succ", value: "int.cases_succ", meta: "∀ (a : int.int), or (Exists (λ (n : nat), eq a (int.of_nat n))) (Exists (λ (n : nat), eq a (int.neg (int.of_nat (succ n)))))"},
{name: "int.add_sub_inverse", value: "int.add_sub_inverse", meta: "∀ (a b : int.int), eq (int.sub (int.add a b) b) a"},
{name: "int.mul_cancel_left", value: "int.mul_cancel_left", meta: "∀ {a b c : int.int}, ne a (int.of_num 0) → eq (int.mul a b) (int.mul a c) → eq b c"},
{name: "int.sub_inj_right", value: "int.sub_inj_right", meta: "∀ {a b c : int.int}, eq (int.sub a b) (int.sub c b) → eq a c"},
{name: "int.int", value: "int.int", meta: "Type"},
{name: "int.mul_one_left", value: "int.mul_one_left", meta: "∀ (a : int.int), eq (int.mul (int.of_num 1) a) a"},
{name: "int.add_eq_zero_left", value: "int.add_eq_zero_left", meta: "∀ {a b : int.int}, eq (int.add a b) (int.of_num 0) → eq (int.neg b) a"},
{name: "int.int_by_cases_succ", value: "int.int_by_cases_succ", meta: "∀ {P : int.int → Prop} (a : int.int), (∀ (n : nat), P (int.of_nat n)) → (∀ (n : nat), P (int.neg (int.of_nat (succ n)))) → P a"},
{name: "int.add_right_comm", value: "int.add_right_comm", meta: "∀ (a b c : int.int), eq (int.add (int.add a b) c) (int.add (int.add a c) b)"},
{name: "int.mul_assoc", value: "int.mul_assoc", meta: "∀ (a b c : int.int), eq (int.mul (int.mul a b) c) (int.mul a (int.mul b c))"},
{name: "int.rel_mul_prep", value: "int.rel_mul_prep", meta: "∀ {xa ya xb yb xn yn xm ym : nat}, eq (add xa yb) (add ya xb) → eq (add xn ym) (add yn xm) → eq (add (add (mul xa xn) (mul ya yn)) (add (mul xb ym) (mul yb xm))) (add (add (mul xa yn) (mul ya xn)) (add (mul xb xm) (mul yb ym)))"},
{name: "int.add_imp_sub_right", value: "int.add_imp_sub_right", meta: "∀ {a b c : int.int}, eq (int.add a b) c → eq (int.sub c b) a"},
{name: "int.sub_add_assoc", value: "int.sub_add_assoc", meta: "∀ (a b c : int.int), eq (int.add (int.sub a b) c) (int.sub a (int.sub b c))"},
{name: "int.cases", value: "int.cases", meta: "∀ (a : int.int), or (Exists (λ (n : nat), eq a (int.of_nat n))) (Exists (λ (n : nat), eq a (int.neg (int.of_nat n))))"},
{name: "int.sub_add_inverse", value: "int.sub_add_inverse", meta: "∀ (a b : int.int), eq (int.add (int.sub a b) b) a"},
{name: "int.proj_congr", value: "int.proj_congr", meta: "∀ {a b : prod nat nat}, int.rel a b → eq (int.proj a) (int.proj b)"},
{name: "int.add_left_comm", value: "int.add_left_comm", meta: "∀ (a b c : int.int), eq (int.add a (int.add b c)) (int.add b (int.add a c))"},
{name: "int.add_neg_left", value: "int.add_neg_left", meta: "∀ (a b : int.int), eq (int.add (int.neg a) b) (int.sub b a)"},
{name: "int.neg_sub_flip", value: "int.neg_sub_flip", meta: "∀ (a b : int.int), eq (int.neg (int.sub a b)) (int.sub b a)"},
{name: "int.sub_self", value: "int.sub_self", meta: "∀ (a : int.int), eq (int.sub a a) (int.of_num 0)"},
{name: "int.mul_sub_right_distr", value: "int.mul_sub_right_distr", meta: "∀ (a b c : int.int), eq (int.mul (int.sub a b) c) (int.sub (int.mul a c) (int.mul b c))"},
{name: "int.mul_comp", value: "int.mul_comp", meta: "∀ (n m k l : nat), eq (int.mul (int.psub (pair n m)) (int.psub (pair k l))) (int.psub (pair (add (mul n k) (mul m l)) (add (mul n l) (mul m k))))"},
{name: "int.sub_neg_right", value: "int.sub_neg_right", meta: "∀ (a b : int.int), eq (int.sub a (int.neg b)) (int.add a b)"},
{name: "int.mul_comm", value: "int.mul_comm", meta: "∀ (a b : int.int), eq (int.mul a b) (int.mul b a)"},
{name: "int.add_neg_right", value: "int.add_neg_right", meta: "∀ (a b : int.int), eq (int.add a (int.neg b)) (int.sub a b)"},
{name: "int.destruct", value: "int.destruct", meta: "∀ (a : int.int), Exists (λ (n : nat), Exists (λ (m : nat), eq a (int.psub (pair n m))))"},
{name: "int.add_cancel_right", value: "int.add_cancel_right", meta: "∀ {a b c : int.int}, eq (int.add a c) (int.add b c) → eq a b"},
{name: "int.mul_zero_left", value: "int.mul_zero_left", meta: "∀ (a : int.int), eq (int.mul (int.of_num 0) a) (int.of_num 0)"},
{name: "int.rel_flip", value: "int.rel_flip", meta: "∀ {a b : prod nat nat}, int.rel a b → int.rel (flip a) (flip b)"},
{name: "int.neg_sub", value: "int.neg_sub", meta: "∀ (a b : int.int), eq (int.neg (int.sub a b)) (int.add (int.neg a) b)"},
{name: "int.proj_ge_pr1", value: "int.proj_ge_pr1", meta: "∀ {a : prod nat nat}, ge (pr1 a) (pr2 a) → eq (pr1 (int.proj a)) (sub (pr1 a) (pr2 a))"},
{name: "int.dist_def", value: "int.dist_def", meta: "∀ (n m : nat), eq (dist n m) (int.to_nat (int.sub (int.of_nat n) (int.of_nat m)))"},
{name: "int.to_nat", value: "int.to_nat", meta: "int.int → nat"},
{name: "int.rel", value: "int.rel", meta: "prod nat nat → prod nat nat → Prop"},
{name: "int.psub_rep", value: "int.psub_rep", meta: "∀ (a : int.int), eq (int.psub (int.rep a)) a"},
{name: "int.rel_equiv", value: "int.rel_equiv", meta: "is_equivalence int.rel"},
{name: "int.trichotomy", value: "int.trichotomy", meta: "∀ (a b : int.int), or (int.lt a b) (or (eq a b) (int.gt a b))"},
{name: "int.neg_lt_zero", value: "int.neg_lt_zero", meta: "∀ {a : int.int}, int.lt 0 a → int.lt (neg a) 0"},
{name: "int.mul_lt_right_pos", value: "int.mul_lt_right_pos", meta: "∀ {a b c : int.int}, int.gt b 0 → int.lt a c → int.lt (mul a b) (mul c b)"},
{name: "int.mul_lt_cancel_right_nonpos", value: "int.mul_lt_cancel_right_nonpos", meta: "∀ {a b c : int.int}, int.le c 0 → int.lt (mul b c) (mul a c) → int.lt a b"},
{name: "int.lt_sub_of_nat_succ", value: "int.lt_sub_of_nat_succ", meta: "∀ (a : int.int) (n : nat), int.lt (sub a (succ n)) a"},
{name: "int.add_le", value: "int.add_le", meta: "∀ {a b c d : int.int}, int.le a b → int.le c d → int.le (add a c) (add b d)"},
{name: "int.le_iff_sub_nonneg", value: "int.le_iff_sub_nonneg", meta: "∀ (a b : int.int), iff (int.le a b) (int.le 0 (sub b a))"},
{name: "int.sign_idempotent", value: "int.sign_idempotent", meta: "∀ (a : int.int), eq (int.sign (int.sign a)) (int.sign a)"},
{name: "int.sub_lt_right", value: "int.sub_lt_right", meta: "∀ {a b : int.int}, int.lt a b → (∀ (c : int.int), int.lt (sub a c) (sub b c))"},
{name: "int.le_imp_succ_le_or_eq", value: "int.le_imp_succ_le_or_eq", meta: "∀ {a b : int.int}, int.le a b → or (int.le (add a 1) b) (eq a b)"},
{name: "int.le_add_of_nat_right", value: "int.le_add_of_nat_right", meta: "∀ (a : int.int) (n : nat), int.le a (add a n)"},
{name: "int.add_lt_cancel_left", value: "int.add_lt_cancel_left", meta: "∀ {a b c : int.int}, int.lt (add c a) (add c b) → int.lt a b"},
{name: "int.le_imp_lt_or_eq", value: "int.le_imp_lt_or_eq", meta: "∀ {a b : int.int}, int.le a b → or (int.lt a b) (eq a b)"},
{name: "int.mul_lt_cancel_right_nonneg", value: "int.mul_lt_cancel_right_nonneg", meta: "∀ {a b c : int.int}, int.ge c 0 → int.lt (mul a c) (mul b c) → int.lt a b"},
{name: "int.mul_le_cancel_right_pos", value: "int.mul_le_cancel_right_pos", meta: "∀ {a b c : int.int}, int.gt c 0 → int.le (mul a c) (mul b c) → int.le a b"},
{name: "int.lt_neg", value: "int.lt_neg", meta: "∀ {a b : int.int}, int.lt a b → int.lt (neg b) (neg a)"},
{name: "int.to_nat_nonneg_eq", value: "int.to_nat_nonneg_eq", meta: "∀ {a : int.int}, int.ge a 0 → eq (to_nat a) a"},
{name: "int.ge_def", value: "int.ge_def", meta: "∀ (n m : nat), iff (ge n m) (le m n)"},
{name: "int.of_nat_nonneg", value: "int.of_nat_nonneg", meta: "∀ (n : nat), int.ge n 0"},
{name: "int.mul_le_cancel_left_neg", value: "int.mul_le_cancel_left_neg", meta: "∀ {a b c : int.int}, int.lt c 0 → int.le (mul c b) (mul c a) → int.le a b"},
{name: "int.le_neg_inv", value: "int.le_neg_inv", meta: "∀ {a b : int.int}, int.le (neg a) (neg b) → int.le b a"},
{name: "int.gt", value: "int.gt", meta: "int.int → int.int → Prop"},
{name: "int.lt_of_nat", value: "int.lt_of_nat", meta: "∀ (n m : nat), iff (int.lt n m) (lt n m)"},
{name: "int.ge_decidable", value: "int.ge_decidable", meta: "Π {a b : int.int}, decidable (int.ge a b)"},
{name: "int.zero_le_neg", value: "int.zero_le_neg", meta: "∀ {a : int.int}, int.le a 0 → int.le 0 (neg a)"},
{name: "int.trichotomy_alt", value: "int.trichotomy_alt", meta: "∀ (a b : int.int), or (or (int.lt a b) (eq a b)) (int.gt a b)"},
{name: "int.lt_irrefl", value: "int.lt_irrefl", meta: "∀ (a : int.int), not (int.lt a a)"},
{name: "int.not_lt_imp_le", value: "int.not_lt_imp_le", meta: "∀ {a b : int.int}, not (int.lt a b) → int.le b a"},
{name: "int.sub_lt_left", value: "int.sub_lt_left", meta: "∀ {a b : int.int}, int.lt a b → (∀ (c : int.int), int.lt (sub c b) (sub c a))"},
{name: "int.mul_lt_left_pos", value: "int.mul_lt_left_pos", meta: "∀ {a b c : int.int}, int.gt a 0 → int.lt b c → int.lt (mul a b) (mul a c)"},
{name: "int.sub_le_left", value: "int.sub_le_left", meta: "∀ {a b : int.int}, int.le a b → (∀ (c : int.int), int.le (sub c b) (sub c a))"},
{name: "int.le_of_nat", value: "int.le_of_nat", meta: "∀ (n m : nat), iff (int.le n m) (le n m)"},
{name: "int.mul_le_right_nonpos", value: "int.mul_le_right_nonpos", meta: "∀ {a b c : int.int}, int.le b 0 → int.le c a → int.le (mul a b) (mul c b)"},
{name: "int.add_le_inv", value: "int.add_le_inv", meta: "∀ {a b c d : int.int}, int.le (add a b) (add c d) → int.le c a → int.le b d"},
{name: "int.sign", value: "int.sign", meta: "int.int → int.int"},
{name: "int.lt_elim", value: "int.lt_elim", meta: "∀ {a b : int.int}, int.lt a b → Exists (λ (n : nat), eq (add a (succ n)) b)"},
{name: "int.sign_zero", value: "int.sign_zero", meta: "eq (int.sign 0) 0"},
{name: "int.le_add_of_nat_left", value: "int.le_add_of_nat_left", meta: "∀ (a : int.int) (n : nat), int.le a (add n a)"},
{name: "int.le_trans", value: "int.le_trans", meta: "∀ {a b c : int.int}, int.le a b → int.le b c → int.le a c"},
{name: "int.lt_trans", value: "int.lt_trans", meta: "∀ {a b c : int.int}, int.lt a b → int.lt b c → int.lt a c"},
{name: "int.sign_succ", value: "int.sign_succ", meta: "∀ (n : nat), eq (int.sign (succ n)) 1"},
{name: "int.mul_lt_neg", value: "int.mul_lt_neg", meta: "∀ {a b c d : int.int}, int.lt a 0 → int.lt b 0 → int.lt c a → int.lt d b → int.lt (mul a b) (mul c d)"},
{name: "int.lt_intro", value: "int.lt_intro", meta: "∀ {a b : int.int} {n : nat}, eq (add a (succ n)) b → int.lt a b"},
{name: "int.add_le_left", value: "int.add_le_left", meta: "∀ {a b : int.int}, int.le a b → (∀ (c : int.int), int.le (add c a) (add c b))"},
{name: "int.sign_to_nat", value: "int.sign_to_nat", meta: "∀ (a : int.int), eq (int.sign (to_nat a)) (to_nat (int.sign a))"},
{name: "int.lt_imp_not_ge", value: "int.lt_imp_not_ge", meta: "∀ {a b : int.int}, int.lt a b → not (int.ge a b)"},
{name: "int.mul_lt_cancel_left_nonpos", value: "int.mul_lt_cancel_left_nonpos", meta: "∀ {a b c : int.int}, int.le c 0 → int.lt (mul c b) (mul c a) → int.lt a b"},
{name: "int.add_le_cancel_right", value: "int.add_le_cancel_right", meta: "∀ {a b c : int.int}, int.le (add a c) (add b c) → int.le a b"},
{name: "int.sub_lt_left_inv", value: "int.sub_lt_left_inv", meta: "∀ {a b c : int.int}, int.lt (sub c a) (sub c b) → int.lt b a"},
{name: "int.lt_imp_le", value: "int.lt_imp_le", meta: "∀ {a b : int.int}, int.lt a b → int.le a b"},
{name: "int.add_lt_cancel_right", value: "int.add_lt_cancel_right", meta: "∀ {a b c : int.int}, int.lt (add a c) (add b c) → int.lt a b"},
{name: "int.mul_le_left_nonpos", value: "int.mul_le_left_nonpos", meta: "∀ {a b c : int.int}, int.le a 0 → int.le b c → int.le (mul a c) (mul a b)"},
{name: "int.lt_add_succ", value: "int.lt_add_succ", meta: "∀ (a : int.int) (n : nat), int.lt a (add a (succ n))"},
{name: "int.pos_imp_exists_nat", value: "int.pos_imp_exists_nat", meta: "∀ {a : int.int}, int.ge a 0 → Exists (λ (n : nat), eq a n)"},
{name: "int.to_nat_sign_ne_zero", value: "int.to_nat_sign_ne_zero", meta: "∀ {a : int.int}, ne a 0 → eq (to_nat (int.sign a)) 1"},
{name: "int.le_imp_lt_succ", value: "int.le_imp_lt_succ", meta: "∀ {a b : int.int}, int.le a b → int.lt a (add b 1)"},
{name: "int.ge", value: "int.ge", meta: "int.int → int.int → Prop"},
{name: "int.mul_eq_one_right", value: "int.mul_eq_one_right", meta: "∀ {a b : int.int}, eq (mul a b) 1 → or (eq b 1) (eq b (neg 1))"},
{name: "int.to_nat_negative", value: "int.to_nat_negative", meta: "∀ {a : int.int}, int.le a 0 → eq (to_nat a) (neg a)"},
{name: "int.mul_sign_to_nat", value: "int.mul_sign_to_nat", meta: "∀ (a : int.int), eq (mul (int.sign a) (to_nat a)) a"},
{name: "int.sub_le_right", value: "int.sub_le_right", meta: "∀ {a b : int.int}, int.le a b → (∀ (c : int.int), int.le (sub a c) (sub b c))"},
{name: "int.not_le_imp_lt", value: "int.not_le_imp_lt", meta: "∀ {a b : int.int}, not (int.le a b) → int.lt b a"},
{name: "int.lt_imp_le_succ", value: "int.lt_imp_le_succ", meta: "∀ {a b : int.int}, int.lt a b → int.le (add a 1) b"},
{name: "int.zero_lt_neg", value: "int.zero_lt_neg", meta: "∀ {a : int.int}, int.lt a 0 → int.lt 0 (neg a)"},
{name: "int.mul_le_right_nonneg", value: "int.mul_le_right_nonneg", meta: "∀ {a b c : int.int}, int.ge b 0 → int.le a c → int.le (mul a b) (mul c b)"},
{name: "int.le_neg", value: "int.le_neg", meta: "∀ {a b : int.int}, int.le a b → int.le (neg b) (neg a)"},
{name: "int.sign_mul", value: "int.sign_mul", meta: "∀ (a b : int.int), eq (int.sign (mul a b)) (mul (int.sign a) (int.sign b))"},
{name: "int.gt_def", value: "int.gt_def", meta: "∀ (n m : nat), iff (gt n m) (lt m n)"},
{name: "int.le_imp_not_gt", value: "int.le_imp_not_gt", meta: "∀ {a b : int.int}, int.le a b → not (int.gt a b)"},
{name: "int.neg_le_zero", value: "int.neg_le_zero", meta: "∀ {a : int.int}, int.le 0 a → int.le (neg a) 0"},
{name: "int.self_lt_succ", value: "int.self_lt_succ", meta: "∀ (a : int.int), int.lt a (add a 1)"},
{name: "int.mul_lt_left_neg", value: "int.mul_lt_left_neg", meta: "∀ {a b c : int.int}, int.lt a 0 → int.lt b c → int.lt (mul a c) (mul a b)"},
{name: "int.sub_le_right_inv", value: "int.sub_le_right_inv", meta: "∀ {a b c : int.int}, int.le (sub a c) (sub b c) → int.le a b"},
{name: "int.gt_decidable", value: "int.gt_decidable", meta: "Π {a b : int.int}, decidable (int.gt a b)"},
{name: "int.lt_imp_ne", value: "int.lt_imp_ne", meta: "∀ {a b : int.int}, int.lt a b → ne a b"},
{name: "int.lt_neg_inv", value: "int.lt_neg_inv", meta: "∀ {a b : int.int}, int.lt (neg a) (neg b) → int.lt b a"},
{name: "int.add_le_lt", value: "int.add_le_lt", meta: "∀ {a b c d : int.int}, int.le a c → int.lt b d → int.lt (add a b) (add c d)"},
{name: "int.le_intro", value: "int.le_intro", meta: "∀ {a b : int.int} {n : nat}, eq (add a n) b → int.le a b"},
{name: "int.mul_le_nonneg", value: "int.mul_le_nonneg", meta: "∀ {a b c d : int.int}, int.ge a 0 → int.ge b 0 → int.le a c → int.le b d → int.le (mul a b) (mul c d)"},
{name: "int.mul_lt_right_neg", value: "int.mul_lt_right_neg", meta: "∀ {a b c : int.int}, int.lt b 0 → int.lt c a → int.lt (mul a b) (mul c b)"},
{name: "int.mul_le_left_nonneg", value: "int.mul_le_left_nonneg", meta: "∀ {a b c : int.int}, int.ge a 0 → int.le b c → int.le (mul a b) (mul a c)"},
{name: "int.sign_pos", value: "int.sign_pos", meta: "∀ {a : int.int}, int.gt a 0 → eq (int.sign a) 1"},
{name: "int.lt_antisym", value: "int.lt_antisym", meta: "∀ {a b : int.int}, int.lt a b → not (int.lt b a)"},
{name: "int.mul_le_cancel_left_pos", value: "int.mul_le_cancel_left_pos", meta: "∀ {a b c : int.int}, int.gt c 0 → int.le (mul c a) (mul c b) → int.le a b"},
{name: "int.le_antisym", value: "int.le_antisym", meta: "∀ {a b : int.int}, int.le a b → int.le b a → eq a b"},
{name: "int.lt_succ_imp_le", value: "int.lt_succ_imp_le", meta: "∀ {a b : int.int}, int.lt a (add b 1) → int.le a b"},
{name: "int.add_le_right", value: "int.add_le_right", meta: "∀ {a b : int.int}, int.le a b → (∀ (c : int.int), int.le (add a c) (add b c))"},
{name: "int.add_le_cancel_left", value: "int.add_le_cancel_left", meta: "∀ {a b c : int.int}, int.le (add c a) (add c b) → int.le a b"},
{name: "int.sign_negative", value: "int.sign_negative", meta: "∀ {a : int.int}, int.lt a 0 → eq (int.sign a) (neg 1)"},
{name: "int.lt_decidable", value: "int.lt_decidable", meta: "Π {a b : int.int}, decidable (int.lt a b)"},
{name: "int.sub_le_left_inv", value: "int.sub_le_left_inv", meta: "∀ {a b c : int.int}, int.le (sub c a) (sub c b) → int.le b a"},
{name: "int.to_nat_cases", value: "int.to_nat_cases", meta: "∀ (a : int.int), or (eq a (to_nat a)) (eq a (neg (to_nat a)))"},
{name: "int.le", value: "int.le", meta: "int.int → int.int → Prop"},
{name: "int.neg_le_pos", value: "int.neg_le_pos", meta: "∀ (n m : nat), int.le (neg n) m"},
{name: "int.mul_le_nonpos", value: "int.mul_le_nonpos", meta: "∀ {a b c d : int.int}, int.le a 0 → int.le b 0 → int.le c a → int.le d b → int.le (mul a b) (mul c d)"},
{name: "int.mul_eq_one_left", value: "int.mul_eq_one_left", meta: "∀ {a b : int.int}, eq (mul a b) 1 → or (eq a 1) (eq a (neg 1))"},
{name: "int.le_total", value: "int.le_total", meta: "∀ (a b : int.int), or (int.le a b) (int.le b a)"},
{name: "int.add_lt", value: "int.add_lt", meta: "∀ {a b c d : int.int}, int.lt a c → int.lt b d → int.lt (add a b) (add c d)"},
{name: "int.le_refl", value: "int.le_refl", meta: "∀ (a : int.int), int.le a a"},
{name: "int.mul_lt_cancel_left_nonneg", value: "int.mul_lt_cancel_left_nonneg", meta: "∀ {a b c : int.int}, int.ge c 0 → int.lt (mul c a) (mul c b) → int.lt a b"},
{name: "int.le_ne_imp_lt", value: "int.le_ne_imp_lt", meta: "∀ {a b : int.int}, int.le a b → ne a b → int.lt a b"},
{name: "int.le_succ_imp_lt", value: "int.le_succ_imp_lt", meta: "∀ {a b : int.int}, int.le (add a 1) b → int.lt a b"},
{name: "int.mul_le_cancel_right_neg", value: "int.mul_le_cancel_right_neg", meta: "∀ {a b c : int.int}, int.lt c 0 → int.le (mul b c) (mul a c) → int.le a b"},
{name: "int.le_decidable", value: "int.le_decidable", meta: "Π {a b : int.int}, decidable (int.le a b)"},
{name: "int.le_sub_of_nat", value: "int.le_sub_of_nat", meta: "∀ (a : int.int) (n : nat), int.le (sub a n) a"},
{name: "int.gt_of_nat", value: "int.gt_of_nat", meta: "∀ (n m : nat), iff (int.gt n m) (gt n m)"},
{name: "int.lt_le_trans", value: "int.lt_le_trans", meta: "∀ {a b c : int.int}, int.lt a b → int.le b c → int.lt a c"},
{name: "int.le_lt_trans", value: "int.le_lt_trans", meta: "∀ {a b c : int.int}, int.le a b → int.lt b c → int.lt a c"},
{name: "int.add_lt_left", value: "int.add_lt_left", meta: "∀ {a b : int.int}, int.lt a b → (∀ (c : int.int), int.lt (add c a) (add c b))"},
{name: "int.lt_def", value: "int.lt_def", meta: "∀ (a b : int.int), iff (int.lt a b) (int.le (add a 1) b)"},
{name: "int.sub_lt_right_inv", value: "int.sub_lt_right_inv", meta: "∀ {a b c : int.int}, int.lt (sub a c) (sub b c) → int.lt a b"},
{name: "int.le_or_gt", value: "int.le_or_gt", meta: "∀ (a b : int.int), or (int.le a b) (int.gt a b)"},
{name: "int.mul_lt_le_pos", value: "int.mul_lt_le_pos", meta: "∀ {a b c d : int.int}, int.ge a 0 → int.gt b 0 → int.lt a c → int.le b d → int.lt (mul a b) (mul c d)"},
{name: "int.mul_lt_pos", value: "int.mul_lt_pos", meta: "∀ {a b c d : int.int}, int.gt a 0 → int.gt b 0 → int.lt a c → int.lt b d → int.lt (mul a b) (mul c d)"},
{name: "int.add_lt_le", value: "int.add_lt_le", meta: "∀ {a b c d : int.int}, int.lt a c → int.le b d → int.lt (add a b) (add c d)"},
{name: "int.add_lt_right", value: "int.add_lt_right", meta: "∀ {a b : int.int}, int.lt a b → (∀ (c : int.int), int.lt (add a c) (add b c))"},
{name: "int.mul_le_lt_pos", value: "int.mul_le_lt_pos", meta: "∀ {a b c d : int.int}, int.gt a 0 → int.ge b 0 → int.le a c → int.lt b d → int.lt (mul a b) (mul c d)"},
{name: "int.neg_imp_exists_nat", value: "int.neg_imp_exists_nat", meta: "∀ {a : int.int}, int.le a 0 → Exists (λ (n : nat), eq a (neg n))"},
{name: "int.sub_le", value: "int.sub_le", meta: "∀ {a b c d : int.int}, int.le a b → int.le d c → int.le (sub a c) (sub b d)"},
{name: "int.lt", value: "int.lt", meta: "int.int → int.int → Prop"},
{name: "int.le_elim", value: "int.le_elim", meta: "∀ {a b : int.int}, int.le a b → Exists (λ (n : nat), eq (add a n) b)"},
{name: "int.le_add_of_nat_right_trans", value: "int.le_add_of_nat_right_trans", meta: "∀ {a b : int.int}, int.le a b → (∀ (n : nat), int.le a (add b n))"},
{name: "int.sub_lt", value: "int.sub_lt", meta: "∀ {a b c d : int.int}, int.lt a b → int.lt d c → int.lt (sub a c) (sub b d)"},
{name: "int.sign_neg", value: "int.sign_neg", meta: "∀ (a : int.int), eq (int.sign (neg a)) (neg (int.sign a))"},
{name: "char.is_inhabited", value: "char.is_inhabited", meta: "inhabited char"},
{name: "string.empty", value: "string.empty", meta: "string"},
{name: "string.is_inhabited", value: "string.is_inhabited", meta: "inhabited string"},
{name: "string", value: "string", meta: "Type"},
{name: "string.rec", value: "string.rec", meta: "Π {C : string → Type}, C string.empty → (Π (a : char) (a_1 : string), C a_1 → C (string.str a a_1)) → (Π (n : string), C n)"},
{name: "char", value: "char", meta: "Type"},
{name: "char.rec", value: "char.rec", meta: "Π {C : char → Type}, (Π (a a_1 a_2 a_3 a_4 a_5 a_6 a_7 : bool), C (char.mk a a_1 a_2 a_3 a_4 a_5 a_6 a_7)) → (Π (n : char), C n)"},
{name: "char.mk", value: "char.mk", meta: "bool → bool → bool → bool → bool → bool → bool → bool → char"},
{name: "string.str", value: "string.str", meta: "char → string → string"},
{name: "option.is_inhabited", value: "option.is_inhabited", meta: "Π (A : Type), inhabited (option A)"},
{name: "option.is_none_none", value: "option.is_none_none", meta: "∀ {A : Type}, option.is_none option.none"},
{name: "option.none", value: "option.none", meta: "Π {A : Type}, option A"},
{name: "option.none_ne_some", value: "option.none_ne_some", meta: "∀ {A : Type} (a : A), ne option.none (option.some a)"},
{name: "option.rec_on", value: "option.rec_on", meta: "Π {A : Type} {C : option A → Type} (o : option A), C option.none → (Π (a : A), C (option.some a)) → C o"},
{name: "option.induction_on", value: "option.induction_on", meta: "∀ {A : Type} {p : option A → Prop} (o : option A), p option.none → (∀ (a : A), p (option.some a)) → p o"},
{name: "option.not_is_none_some", value: "option.not_is_none_some", meta: "∀ {A : Type} (a : A), not (option.is_none (option.some a))"},
{name: "option.has_decidable_eq", value: "option.has_decidable_eq", meta: "Π {A : Type}, decidable_eq A → decidable_eq (option A)"},
{name: "option.some", value: "option.some", meta: "Π {A : Type}, A → option A"},
{name: "option.rec", value: "option.rec", meta: "Π {A : Type} {C : option A → Type}, C option.none → (Π (a : A), C (option.some a)) → (Π (n : option A), C n)"},
{name: "option.is_none", value: "option.is_none", meta: "Π {A : Type}, option A → Prop"},
{name: "option.equal", value: "option.equal", meta: "∀ {A : Type} {a₁ a₂ : A}, eq (option.some a₁) (option.some a₂) → eq a₁ a₂"},
{name: "option", value: "option", meta: "Type → Type"},
{name: "subtype.is_inhabited", value: "subtype.is_inhabited", meta: "Π {A : Type} {P : A → Prop} {a : A}, P a → inhabited (subtype (λ (x : A), P x))"},
{name: "subtype.has_decidable_eq", value: "subtype.has_decidable_eq", meta: "Π {A : Type} {P : A → Prop}, decidable_eq A → decidable_eq (subtype (λ (x : A), P x))"},
{name: "subtype.tag_elt_of", value: "subtype.tag_elt_of", meta: "∀ {A : Type} {P : A → Prop} (a : subtype P) (H : P (subtype.elt_of a)), eq (subtype.tag (subtype.elt_of a) H) a"},
{name: "subtype", value: "subtype", meta: "Π {A : Type}, (A → Prop) → Type"},
{name: "subtype.rec", value: "subtype.rec", meta: "Π {A : Type} {P : A → Prop} {C : subtype P → Type}, (Π (x : A) (a : P x), C (subtype.tag x a)) → (Π (n : subtype P), C n)"},
{name: "subtype.tag", value: "subtype.tag", meta: "Π {A : Type} {P : A → Prop} (x : A), P x → subtype P"},
{name: "subtype.tag_irrelevant", value: "subtype.tag_irrelevant", meta: "∀ {A : Type} {P : A → Prop} {a : A} (H1 H2 : P a), eq (subtype.tag a H1) (subtype.tag a H2)"},
{name: "subtype.has_property", value: "subtype.has_property", meta: "∀ {A : Type} {P : A → Prop} (a : subtype (λ (x : A), P x)), P (subtype.elt_of a)"},
{name: "subtype.elt_of", value: "subtype.elt_of", meta: "Π {A : Type} {P : A → Prop}, subtype (λ (x : A), P x) → A"},
{name: "subtype.tag_eq", value: "subtype.tag_eq", meta: "∀ {A : Type} {P : A → Prop} {a1 a2 : A} {H1 : P a1} {H2 : P a2}, eq a1 a2 → eq (subtype.tag a1 H1) (subtype.tag a2 H2)"},
{name: "subtype.equal", value: "subtype.equal", meta: "∀ {A : Type} {P : A → Prop} {a1 a2 : subtype (λ (x : A), P x)}, eq (subtype.elt_of a1) (subtype.elt_of a2) → eq a1 a2"},
{name: "subtype.elt_of_tag", value: "subtype.elt_of_tag", meta: "∀ {A : Type} {P : A → Prop} (a : A) (H : P a), eq (subtype.elt_of (subtype.tag a H)) a"},
{name: "subtype.destruct", value: "subtype.destruct", meta: "∀ {A : Type} {P : A → Prop} {Q : subtype (λ (x : A), P x) → Prop} (a : subtype (λ (x : A), P x)), (∀ (x : A) (H1 : P x), Q (subtype.tag x H1)) → Q a"},
{name: "set.union_id", value: "set.union_id", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.union A A) A"},
{name: "set.union_assoc", value: "set.union_assoc", meta: "∀ {T : Type} (A B C : set.set T), set.eqv (set.union (set.union A B) C) (set.union A (set.union B C))"},
{name: "set.empty", value: "set.empty", meta: "Π {T : Type}, set.set T"},
{name: "set.union_empty_right", value: "set.union_empty_right", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.union A set.empty) A"},
{name: "set.inter", value: "set.inter", meta: "Π {T : Type}, set.set T → set.set T → set.set T"},
{name: "set.inter_empty_right", value: "set.inter_empty_right", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.inter A set.empty) set.empty"},
{name: "set.eqv_trans", value: "set.eqv_trans", meta: "∀ {T : Type} {A B C : set.set T}, set.eqv A B → set.eqv B C → set.eqv A C"},
{name: "set.inter_comm", value: "set.inter_comm", meta: "∀ {T : Type} (A B : set.set T), set.eqv (set.inter A B) (set.inter B A)"},
{name: "set.mem", value: "set.mem", meta: "Π {T : Type}, T → set.set T → Prop"},
{name: "set.mem_inter", value: "set.mem_inter", meta: "∀ {T : Type} (x : T) (A B : set.set T), iff (set.mem x (set.inter A B)) (and (set.mem x A) (set.mem x B))"},
{name: "set.mem_empty", value: "set.mem_empty", meta: "∀ {T : Type} (x : T), not (set.mem x set.empty)"},
{name: "set.eqv", value: "set.eqv", meta: "Π {T : Type}, set.set T → set.set T → Prop"},
{name: "set.union_empty_left", value: "set.union_empty_left", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.union set.empty A) A"},
{name: "set.univ", value: "set.univ", meta: "Π {T : Type}, set.set T"},
{name: "set.eqv_symm", value: "set.eqv_symm", meta: "∀ {T : Type} {A B : set.set T}, set.eqv A B → set.eqv B A"},
{name: "set.eqv_refl", value: "set.eqv_refl", meta: "∀ {T : Type} (A : set.set T), set.eqv A A"},
{name: "set.mem_univ", value: "set.mem_univ", meta: "∀ {T : Type} (x : T), set.mem x set.univ"},
{name: "set.mem_union", value: "set.mem_union", meta: "∀ {T : Type} (x : T) (A B : set.set T), iff (set.mem x (set.union A B)) (or (set.mem x A) (set.mem x B))"},
{name: "set.inter_empty_left", value: "set.inter_empty_left", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.inter set.empty A) set.empty"},
{name: "set.inter_assoc", value: "set.inter_assoc", meta: "∀ {T : Type} (A B C : set.set T), set.eqv (set.inter (set.inter A B) C) (set.inter A (set.inter B C))"},
{name: "set.union_comm", value: "set.union_comm", meta: "∀ {T : Type} (A B : set.set T), set.eqv (set.union A B) (set.union B A)"},
{name: "set.union", value: "set.union", meta: "Π {T : Type}, set.set T → set.set T → set.set T"},
{name: "set.inter_id", value: "set.inter_id", meta: "∀ {T : Type} (A : set.set T), set.eqv (set.inter A A) A"},
{name: "set.set", value: "set.set", meta: "Type → Type"},
{name: "quotient.quotient", value: "quotient.quotient", meta: "Π {A : Type}, (A → A → Prop) → Type"},
{name: "quotient.quotient_is_quotient", value: "quotient.quotient_is_quotient", meta: "∀ {A : Type} (R : A → A → Prop), relation.is_equivalence R → quotient.is_quotient R (quotient.quotient_abs R) (quotient.quotient_elt_of R)"},
{name: "quotient.quotient_abs", value: "quotient.quotient_abs", meta: "Π {A : Type} (R : A → A → Prop), A → quotient.quotient R"},
{name: "quotient.quotient_elt_of", value: "quotient.quotient_elt_of", meta: "Π {A : Type} (R : A → A → Prop), quotient.quotient R → A"},
{name: "quotient.prelim_map", value: "quotient.prelim_map", meta: "Π {A : Type}, (A → A → Prop) → A → A"},
{name: "quotient.prelim_map_congr", value: "quotient.prelim_map_congr", meta: "∀ {A : Type} {R : A → A → Prop}, relation.is_equivalence R → (∀ {a b : A}, R a b → eq (quotient.prelim_map R a) (quotient.prelim_map R b))"},
{name: "quotient.prelim_map_rel", value: "quotient.prelim_map_rel", meta: "∀ {A : Type} {R : A → A → Prop}, relation.is_equivalence R → (∀ (a : A), R a (quotient.prelim_map R a))"},
{name: "quotient.image", value: "quotient.image", meta: "Π {A : Type} {B : Type}, (A → B) → Type"},
{name: "quotient.image_inhabited2", value: "quotient.image_inhabited2", meta: "Π {A : Type} {B : Type} (f : A → B), A → inhabited (quotient.image f)"},
{name: "quotient.comp_quotient_map_binary", value: "quotient.comp_quotient_map_binary", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {f : A → A → A}, (∀ (a a' b b' : A), R a a' → R b b' → R (f a b) (f a' b')) → (∀ {a b : A}, R a a → R b b → eq (quotient.quotient_map_binary Q f (abs a) (abs b)) (abs (f a b)))"},
{name: "quotient.comp_binary", value: "quotient.comp_binary", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {C : Type} {f : A → A → C}, (∀ (a a' b b' : A), R a a' → R b b' → eq (f a b) (f a' b')) → (∀ {a b : A}, R a a → R b b → eq (quotient.rec_binary Q f (abs a) (abs b)) (f a b))"},
{name: "quotient.abs_rep", value: "quotient.abs_rep", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ (b : B), eq (abs (rep b)) b)"},
{name: "quotient.representative_map_image_fix", value: "quotient.representative_map_image_fix", meta: "∀ {A : Type} {R : A → A → Prop} {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a a' : A), iff (R a a') (and (R a a) (and (R a' a') (eq (f a) (f a'))))) → (∀ (b : quotient.image f), eq (f (elt_of b)) (elt_of b))"},
{name: "quotient.image_tag", value: "quotient.image_tag", meta: "∀ {A : Type} {B : Type} {f : A → B} (u : quotient.image f), Exists (λ (a : A), Exists (λ (H : Exists (λ (a_1 : A), eq (f a_1) (f a))), eq (tag (f a) H) u))"},
{name: "quotient.quotient_map", value: "quotient.quotient_map", meta: "Π {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (A → A) → B → B"},
{name: "quotient.rec", value: "quotient.rec", meta: "Π {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (Π {C : B → Type}, (Π (a : A), C (abs a)) → (Π (b : B), C b))"},
{name: "quotient.refl_rep", value: "quotient.refl_rep", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ (b : B), R (rep b) (rep b))"},
{name: "quotient.quotient_map_binary", value: "quotient.quotient_map_binary", meta: "Π {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (A → A → A) → B → B → B"},
{name: "quotient.comp_quotient_map", value: "quotient.comp_quotient_map", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {f : A → A}, (∀ (a a' : A), R a a' → R (f a) (f a')) → (∀ {a : A}, R a a → eq (quotient.quotient_map Q f (abs a)) (abs (f a)))"},
{name: "quotient.rep_eq", value: "quotient.rep_eq", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {a b : B}, R (rep a) (rep b) → eq a b)"},
{name: "quotient.refl_right", value: "quotient.refl_right", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {r s : A}, R r s → R s s)"},
{name: "quotient.representative_map_idempotent_equiv", value: "quotient.representative_map_idempotent_equiv", meta: "∀ {A : Type} {R : A → A → Prop} {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a b : A), R a b → eq (f a) (f b)) → (∀ (a : A), eq (f (f a)) (f a))"},
{name: "quotient.and_absorb_left", value: "quotient.and_absorb_left", meta: "∀ {a : Prop} (b : Prop), a → iff (and a b) b"},
{name: "quotient.fun_image_def", value: "quotient.fun_image_def", meta: "∀ {A : Type} {B : Type} (f : A → B) (a : A), eq (quotient.fun_image f a) (tag (f a) (exists_intro a rfl))"},
{name: "quotient.R_rep_abs", value: "quotient.R_rep_abs", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {a : A}, R a a → R a (rep (abs a)))"},
{name: "quotient.quotient_imp_symm", value: "quotient.quotient_imp_symm", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → symmetric R"},
{name: "quotient.representative_map_to_quotient_equiv", value: "quotient.representative_map_to_quotient_equiv", meta: "∀ {A : Type} {R : A → A → Prop}, is_equivalence R → (∀ {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a b : A), R a b → eq (f a) (f b)) → quotient.is_quotient R (quotient.fun_image f) elt_of)"},
{name: "quotient.representative_map_to_quotient", value: "quotient.representative_map_to_quotient", meta: "∀ {A : Type} {R : A → A → Prop} {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a a' : A), iff (R a a') (and (R a a) (and (R a' a') (eq (f a) (f a'))))) → quotient.is_quotient R (quotient.fun_image f) elt_of"},
{name: "quotient.idempotent_image_fix", value: "quotient.idempotent_image_fix", meta: "∀ {A : Type} {f : A → A}, (∀ (a : A), eq (f (f a)) (f a)) → (∀ (b : quotient.image f), eq (f (elt_of b)) (elt_of b))"},
{name: "quotient.quotient_imp_trans", value: "quotient.quotient_imp_trans", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → transitive R"},
{name: "quotient.comp", value: "quotient.comp", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {C : B → Type} {f : Π (a : A), C (abs a)}, (∀ (r s : A) (H' : R r s), eq (eq.rec_on (quotient.eq_abs Q H') (f r)) (f s)) → (∀ {a : A}, R a a → eq (quotient.rec Q f (abs a)) (f a))"},
{name: "quotient.image_elt_of", value: "quotient.image_elt_of", meta: "∀ {A : Type} {B : Type} {f : A → B} (u : quotient.image f), Exists (λ (a : A), eq (f a) (elt_of u))"},
{name: "quotient.image_inhabited", value: "quotient.image_inhabited", meta: "Π {A : Type} {B : Type} (f : A → B), inhabited A → inhabited (quotient.image f)"},
{name: "quotient.is_quotient", value: "quotient.is_quotient", meta: "Π {A : Type} {B : Type}, (A → A → Prop) → (A → B) → (B → A) → Prop"},
{name: "quotient.elt_of_fun_image", value: "quotient.elt_of_fun_image", meta: "∀ {A : Type} {B : Type} (f : A → B) (a : A), eq (elt_of (quotient.fun_image f a)) (f a)"},
{name: "quotient.refl_left", value: "quotient.refl_left", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {r s : A}, R r s → R r r)"},
{name: "quotient.intro_refl", value: "quotient.intro_refl", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, reflexive R → (∀ (b : B), eq (abs (rep b)) b) → (∀ (r s : A), iff (R r s) (eq (abs r) (abs s))) → quotient.is_quotient R abs rep"},
{name: "quotient.R_intro", value: "quotient.R_intro", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {r s : A}, R r r → R s s → eq (abs r) (abs s) → R r s)"},
{name: "quotient.comp_constant", value: "quotient.comp_constant", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {C : Type} {f : A → C}, (∀ (r s : A), R r s → eq (f r) (f s)) → (∀ {a : A}, R a a → eq (quotient.rec_constant Q f (abs a)) (f a))"},
{name: "quotient.comp_binary_refl", value: "quotient.comp_binary_refl", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep), reflexive R → (∀ {C : Type} {f : A → A → C}, (∀ (a a' b b' : A), R a a' → R b b' → eq (f a b) (f a' b')) → (∀ (a b : A), eq (quotient.rec_binary Q f (abs a) (abs b)) (f a b)))"},
{name: "quotient.representative_map_equiv_inj", value: "quotient.representative_map_equiv_inj", meta: "∀ {A : Type} {R : A → A → Prop}, is_equivalence R → (∀ {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a b : A), R a b → eq (f a) (f b)) → (∀ {a b : A}, eq (f a) (f b) → R a b))"},
{name: "quotient.eq_abs", value: "quotient.eq_abs", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ {r s : A}, R r s → eq (abs r) (abs s))"},
{name: "quotient.representative_map_refl_rep", value: "quotient.representative_map_refl_rep", meta: "∀ {A : Type} {R : A → A → Prop} {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a a' : A), iff (R a a') (and (R a a) (and (R a' a') (eq (f a) (f a'))))) → (∀ (a : A), R (f a) (f a))"},
{name: "quotient.fun_image_eq", value: "quotient.fun_image_eq", meta: "∀ {A : Type} {B : Type} (f : A → B) (a a' : A), iff (eq (f a) (f a')) (eq (quotient.fun_image f a) (quotient.fun_image f a'))"},
{name: "quotient.intro", value: "quotient.intro", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, (∀ (b : B), eq (abs (rep b)) b) → (∀ (b : B), R (rep b) (rep b)) → (∀ (r s : A), iff (R r s) (and (R r r) (and (R s s) (eq (abs r) (abs s))))) → quotient.is_quotient R abs rep"},
{name: "quotient.comp_quotient_map_binary_refl", value: "quotient.comp_quotient_map_binary_refl", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop}, reflexive R → (∀ {abs : A → B} {rep : B → A} (Q : quotient.is_quotient R abs rep) {f : A → A → A}, (∀ (a a' b b' : A), R a a' → R b b' → R (f a b) (f a' b')) → (∀ (a b : A), eq (quotient.quotient_map_binary Q f (abs a) (abs b)) (abs (f a b))))"},
{name: "quotient.rec_binary", value: "quotient.rec_binary", meta: "Π {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (Π {C : Type}, (A → A → C) → B → B → C)"},
{name: "quotient.R_iff", value: "quotient.R_iff", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (∀ (r s : A), iff (R r s) (and (R r r) (and (R s s) (eq (abs r) (abs s)))))"},
{name: "quotient.idempotent_image_elt_of", value: "quotient.idempotent_image_elt_of", meta: "∀ {A : Type} {f : A → A}, (∀ (a : A), eq (f (f a)) (f a)) → (∀ (u : quotient.image f), eq (quotient.fun_image f (elt_of u)) u)"},
{name: "quotient.representative_map_idempotent", value: "quotient.representative_map_idempotent", meta: "∀ {A : Type} {R : A → A → Prop} {f : A → A}, (∀ (a : A), R a (f a)) → (∀ (a a' : A), iff (R a a') (and (R a a) (and (R a' a') (eq (f a) (f a'))))) → (∀ (a : A), eq (f (f a)) (f a))"},
{name: "quotient.R_intro_refl", value: "quotient.R_intro_refl", meta: "∀ {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → reflexive R → (∀ {r s : A}, eq (abs r) (abs s) → R r s)"},
{name: "quotient.rec_constant", value: "quotient.rec_constant", meta: "Π {A : Type} {B : Type} {R : A → A → Prop} {abs : A → B} {rep : B → A}, quotient.is_quotient R abs rep → (Π {C : Type}, (A → C) → B → C)"},
{name: "quotient.fun_image_surj", value: "quotient.fun_image_surj", meta: "∀ {A : Type} {B : Type} {f : A → B} (u : quotient.image f), Exists (λ (a : A), eq (quotient.fun_image f a) u)"},
{name: "quotient.fun_image", value: "quotient.fun_image", meta: "Π {A : Type} {B : Type} (f : A → B), A → quotient.image f"},
{name: "quotient.P_flip", value: "quotient.P_flip", meta: "∀ {A : Type} {B : Type} {P : A → B → Prop} (a : prod A B), P (pr1 a) (pr2 a) → P (pr2 (quotient.flip a)) (pr1 (quotient.flip a))"},
{name: "quotient.flip", value: "quotient.flip", meta: "Π {A : Type} {B : Type}, prod A B → prod B A"},
{name: "quotient.map_pair2_def", value: "quotient.map_pair2_def", meta: "∀ {A : Type} {B : Type} {C : Type} (f : A → B → C) (a : prod A A) (b : prod B B), eq (quotient.map_pair2 f a b) (pair (f (pr1 a) (pr1 b)) (f (pr2 a) (pr2 b)))"},
{name: "quotient.map_pair2_flip", value: "quotient.map_pair2_flip", meta: "∀ {A : Type} {B : Type} {C : Type} (f : A → B → C) (a : prod A A) (b : prod B B), eq (quotient.flip (quotient.map_pair2 f a b)) (quotient.map_pair2 f (quotient.flip a) (quotient.flip b))"},
{name: "quotient.map_pair2_comm", value: "quotient.map_pair2_comm", meta: "∀ {A : Type} {B : Type} {f : A → A → B}, (∀ (a b : A), eq (f a b) (f b a)) → (∀ (v w : prod A A), eq (quotient.map_pair2 f v w) (quotient.map_pair2 f w v))"},
{name: "quotient.map_pair_def", value: "quotient.map_pair_def", meta: "∀ {A : Type} {B : Type} (f : A → B) (a : prod A A), eq (quotient.map_pair f a) (pair (f (pr1 a)) (f (pr2 a)))"},
{name: "quotient.map_pair2_pr1", value: "quotient.map_pair2_pr1", meta: "∀ {A : Type} {B : Type} {C : Type} (f : A → B → C) (a : prod A A) (b : prod B B), eq (pr1 (quotient.map_pair2 f a b)) (f (pr1 a) (pr1 b))"},
{name: "quotient.flip_pr2", value: "quotient.flip_pr2", meta: "∀ {A : Type} {B : Type} (a : prod A B), eq (pr2 (quotient.flip a)) (pr1 a)"},
{name: "quotient.map_pair2_id_left", value: "quotient.map_pair2_id_left", meta: "∀ {A : Type} {B : Type} {f : B → A → A} {e : B}, (∀ (a : A), eq (f e a) a) → (∀ (v : prod A A), eq (quotient.map_pair2 f (pair e e) v) v)"},
{name: "quotient.flip_def", value: "quotient.flip_def", meta: "∀ {A : Type} {B : Type} (a : prod A B), eq (quotient.flip a) (pair (pr2 a) (pr1 a))"},
{name: "quotient.map_pair", value: "quotient.map_pair", meta: "Π {A : Type} {B : Type}, (A → B) → prod A A → prod B B"},
{name: "quotient.map_pair2_pr2", value: "quotient.map_pair2_pr2", meta: "∀ {A : Type} {B : Type} {C : Type} (f : A → B → C) (a : prod A A) (b : prod B B), eq (pr2 (quotient.map_pair2 f a b)) (f (pr2 a) (pr2 b))"},
{name: "quotient.map_pair2_assoc", value: "quotient.map_pair2_assoc", meta: "∀ {A : Type} {f : A → A → A}, (∀ (a b c : A), eq (f (f a b) c) (f a (f b c))) → (∀ (u v w : prod A A), eq (quotient.map_pair2 f (quotient.map_pair2 f u v) w) (quotient.map_pair2 f u (quotient.map_pair2 f v w)))"},
{name: "quotient.map_pair2_pair", value: "quotient.map_pair2_pair", meta: "∀ {A : Type} {B : Type} {C : Type} (f : A → B → C) (a a' : A) (b b' : B), eq (quotient.map_pair2 f (pair a a') (pair b b')) (pair (f a b) (f a' b'))"},
{name: "quotient.map_pair_pr2", value: "quotient.map_pair_pr2", meta: "∀ {A : Type} {B : Type} (f : A → B) (a : prod A A), eq (pr2 (quotient.map_pair f a)) (f (pr2 a))"},
{name: "quotient.map_pair2_id_right", value: "quotient.map_pair2_id_right", meta: "∀ {A : Type} {B : Type} {f : A → B → A} {e : B}, (∀ (a : A), eq (f a e) a) → (∀ (v : prod A A), eq (quotient.map_pair2 f v (pair e e)) v)"},
{name: "quotient.flip_flip", value: "quotient.flip_flip", meta: "∀ {A : Type} {B : Type} (a : prod A B), eq (quotient.flip (quotient.flip a)) a"},
{name: "quotient.flip_pair", value: "quotient.flip_pair", meta: "∀ {A : Type} {B : Type} (a : A) (b : B), eq (quotient.flip (pair a b)) (pair b a)"},
{name: "quotient.flip_inj", value: "quotient.flip_inj", meta: "∀ {A : Type} {B : Type} {a b : prod A B}, eq (quotient.flip a) (quotient.flip b) → eq a b"},
{name: "quotient.map_pair_pair", value: "quotient.map_pair_pair", meta: "∀ {A : Type} {B : Type} (f : A → B) (a a' : A), eq (quotient.map_pair f (pair a a')) (pair (f a) (f a'))"},
{name: "quotient.flip_pr1", value: "quotient.flip_pr1", meta: "∀ {A : Type} {B : Type} (a : prod A B), eq (pr1 (quotient.flip a)) (pr2 a)"},
{name: "quotient.map_pair_pr1", value: "quotient.map_pair_pr1", meta: "∀ {A : Type} {B : Type} (f : A → B) (a : prod A A), eq (pr1 (quotient.map_pair f a)) (f (pr1 a))"},
{name: "quotient.map_pair2", value: "quotient.map_pair2", meta: "Π {A : Type} {B : Type} {C : Type}, (A → B → C) → prod A A → prod B B → prod C C"},
{name: "vector.case_zero_lem_aux", value: "vector.case_zero_lem_aux", meta: "Π {T : Type} {C : vector T 0 → Type} {n : nat} (v : vector T n), C vector.nil → (Π (H : eq n 0), C (cast (congr_arg (vector T) H) v))"},
{name: "vector.nil", value: "vector.nil", meta: "Π {T : Type}, vector T 0"},
{name: "vector.nil_concat", value: "vector.nil_concat", meta: "∀ {T : Type} {n : nat} (v : vector T n), eq (vector.concat vector.nil v) (vector.cast_subst (eq.symm (add.zero_left n)) v)"},
{name: "vector.length", value: "vector.length", meta: "Π {T : Type} {n : nat}, vector T n → nat"},
{name: "vector.cons", value: "vector.cons", meta: "Π {T : Type}, T → (Π {n : nat}, vector T n → vector T (succ n))"},
{name: "vector.cast_subst", value: "vector.cast_subst", meta: "Π {A : Type} {P : A → Type} {a a' : A}, eq a a' → P a → P a'"},
{name: "vector.rec_nonempty", value: "vector.rec_nonempty", meta: "Π {T : Type} {C : Π {n : nat}, vector T (succ n) → Type} {n : nat} (v : vector T (succ n)), (Π (a : T), C (vector.cons a vector.nil)) → (Π (a : T) {n : nat} (v : vector T (succ n)), C v → C (vector.cons a v)) → C v"},
{name: "vector.is_inhabited", value: "vector.is_inhabited", meta: "Π (A : Type), inhabited A → (Π (n : nat), inhabited (vector A n))"},
{name: "vector.rec", value: "vector.rec", meta: "Π {T : Type} {C : Π (a : nat), vector T a → Type}, C 0 vector.nil → (Π (a : T) {n : nat} (a_1 : vector T n), C n a_1 → C (succ n) (vector.cons a a_1)) → (Π {a : nat} (n : vector T a), C a n)"},
{name: "vector.case_zero", value: "vector.case_zero", meta: "Π {T : Type} {C : vector T 0 → Type} (v : vector T 0), C vector.nil → C v"},
{name: "vector", value: "vector", meta: "Type → nat → Type"},
{name: "vector.length_nil", value: "vector.length_nil", meta: "∀ {T : Type}, eq (vector.length vector.nil) 0"},
{name: "vector.induction_on", value: "vector.induction_on", meta: "∀ {T : Type} {C : Π (n : nat), vector T n → Prop} {n : nat} (v : vector T n), C 0 vector.nil → (∀ (x : T) {n : nat} (w : vector T n), C n w → C (succ n) (vector.cons x w)) → C n v"},
{name: "vector.rec_on", value: "vector.rec_on", meta: "Π {T : Type} {C : Π (n : nat), vector T n → Type} {n : nat} (v : vector T n), C 0 vector.nil → (Π (x : T) {n : nat} (w : vector T n), C n w → C (succ n) (vector.cons x w)) → C n v"},
{name: "vector.case_succ", value: "vector.case_succ", meta: "Π {T : Type} {C : Π {n : nat}, vector T (succ n) → Type} {n : nat} (v : vector T (succ n)), (Π (a : T) {n : nat} (v : vector T n), C (vector.cons a v)) → C v"},
{name: "vector.vector0_eq_nil", value: "vector.vector0_eq_nil", meta: "∀ {T : Type} (v : vector T 0), eq v vector.nil"},
{name: "vector.cons_concat", value: "vector.cons_concat", meta: "∀ {T : Type} {n m : nat} (x : T) (v : vector T n) (w : vector T m), eq (vector.concat (vector.cons x v) w) (vector.cast_subst (eq.symm (add.succ_left n m)) (vector.cons x (vector.concat v w)))"},
{name: "vector.case_on", value: "vector.case_on", meta: "Π {T : Type} {C : Π (n : nat), vector T n → Type} {n : nat} (v : vector T n), C 0 vector.nil → (Π (x : T) {n : nat} (w : vector T n), C (succ n) (vector.cons x w)) → C n v"},
{name: "vector.concat", value: "vector.concat", meta: "Π {T : Type} {n m : nat}, vector T n → vector T m → vector T (add n m)"},
{name: "sigma.dtrip_eq", value: "sigma.dtrip_eq", meta: "∀ {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} {a₁ a₂ : A} {b₁ : B a₁} {b₂ : B a₂} {c₁ : C a₁ b₁} {c₂ : C a₂ b₂} (H₁ : eq a₁ a₂) (H₂ : eq (eq.rec_on H₁ b₁) b₂), eq (eq.rec_on (congr_arg2_dep C H₁ H₂) c₁) c₂ → eq (sigma.dtrip a₁ b₁ c₁) (sigma.dtrip a₂ b₂ c₂)"},
{name: "sigma.is_inhabited", value: "sigma.is_inhabited", meta: "Π {A : Type} {B : A → Type} (H₁ : inhabited A), inhabited (B (default A)) → inhabited (sigma B)"},
{name: "sigma.equal", value: "sigma.equal", meta: "∀ {A : Type} {B : A → Type} {p₁ p₂ : sigma (λ (a : A), B a)} (H₁ : eq (sigma.dpr1 p₁) (sigma.dpr1 p₂)), eq (eq.rec_on H₁ (sigma.dpr2 p₁)) (sigma.dpr2 p₂) → eq p₁ p₂"},
{name: "sigma.destruct", value: "sigma.destruct", meta: "∀ {A : Type} {B : A → Type} {P : sigma B → Prop} (p : sigma B), (∀ (a : A) (b : B a), P (sigma.dpair a b)) → P p"},
{name: "sigma.dpair_ext", value: "sigma.dpair_ext", meta: "∀ {A : Type} {B : A → Type} (p : sigma B), eq (sigma.dpair (sigma.dpr1 p) (sigma.dpr2 p)) p"},
{name: "sigma.dtrip_eq_ndep", value: "sigma.dtrip_eq_ndep", meta: "∀ {A : Type} {B : Type} {C : A → B → Type} {a₁ a₂ : A} {b₁ b₂ : B} {c₁ : C a₁ b₁} {c₂ : C a₂ b₂} (H₁ : eq a₁ a₂) (H₂ : eq b₁ b₂), eq (eq.rec_on (congr_arg2 C H₁ H₂) c₁) c₂ → eq (sigma.dtrip a₁ b₁ c₁) (sigma.dtrip a₂ b₂ c₂)"},
{name: "sigma", value: "sigma", meta: "Π {A : Type}, (A → Type) → Type"},
{name: "sigma.dpr2'", value: "sigma.dpr2'", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} (x : sigma (λ (a : A), sigma (λ (a_1 : B a), C a a_1))), B (sigma.dpr1 x)"},
{name: "sigma.dquad", value: "sigma.dquad", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} {D : Π (a : A) (b : B a), C a b → Type} (a : A) (b : B a) (c : C a b), D a b c → sigma (λ (a : A), sigma (λ (a_1 : B a), sigma (λ (a_2 : C a a_1), D a a_1 a_2)))"},
{name: "sigma.dpr2_dpair", value: "sigma.dpr2_dpair", meta: "∀ {A : Type} {B : A → Type} (a : A) (b : B a), eq (sigma.dpr2 (sigma.dpair a b)) b"},
{name: "sigma.dpr3", value: "sigma.dpr3", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} (x : sigma (λ (a : A), sigma (λ (a_1 : B a), C a a_1))), C (sigma.dpr1 x) (sigma.dpr1 (sigma.dpr2 x))"},
{name: "sigma.dpair_eq", value: "sigma.dpair_eq", meta: "∀ {A : Type} {B : A → Type} {a₁ a₂ : A} {b₁ : B a₁} {b₂ : B a₂} (H₁ : eq a₁ a₂), eq (eq.rec_on H₁ b₁) b₂ → eq (sigma.dpair a₁ b₁) (sigma.dpair a₂ b₂)"},
{name: "sigma.dpr2", value: "sigma.dpr2", meta: "Π {A : Type} {B : A → Type} (p : sigma (λ (a : A), B a)), B (sigma.dpr1 p)"},
{name: "sigma.rec", value: "sigma.rec", meta: "Π {A : Type} {B : A → Type} {C : sigma B → Type}, (Π (x : A) (a : B x), C (sigma.dpair x a)) → (Π (n : sigma B), C n)"},
{name: "sigma.dpair", value: "sigma.dpair", meta: "Π {A : Type} {B : A → Type} (x : A), B x → sigma B"},
{name: "sigma.dpr4", value: "sigma.dpr4", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} {D : Π (a : A) (b : B a), C a b → Type} (x : sigma (λ (a : A), sigma (λ (a_1 : B a), sigma (λ (a_2 : C a a_1), D a a_1 a_2)))), D (sigma.dpr1 x) (sigma.dpr1 (sigma.dpr2 x)) (sigma.dpr1 (sigma.dpr2 (sigma.dpr2 x)))"},
{name: "sigma.dpr1'", value: "sigma.dpr1'", meta: "Π {A : Type} {B : A → Type}, sigma (λ (a : A), B a) → A"},
{name: "sigma.dpr1_dpair", value: "sigma.dpr1_dpair", meta: "∀ {A : Type} {B : A → Type} (a : A) (b : B a), eq (sigma.dpr1 (sigma.dpair a b)) a"},
{name: "sigma.dpr3'", value: "sigma.dpr3'", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} {D : Π (a : A) (b : B a), C a b → Type} (x : sigma (λ (a : A), sigma (λ (a_1 : B a), sigma (λ (a_2 : C a a_1), D a a_1 a_2)))), C (sigma.dpr1 x) (sigma.dpr1 (sigma.dpr2 x))"},
{name: "sigma.trip.equal_ndep", value: "sigma.trip.equal_ndep", meta: "∀ {A : Type} {B : Type} {C : A → B → Type} {p₁ p₂ : sigma (λ (a : A), sigma (λ (a_1 : B), C a a_1))} (H₁ : eq (sigma.dpr1 p₁) (sigma.dpr1 p₂)) (H₂ : eq (sigma.dpr2' p₁) (sigma.dpr2' p₂)), eq (eq.rec_on (congr_arg2 C H₁ H₂) (sigma.dpr3 p₁)) (sigma.dpr3 p₂) → eq p₁ p₂"},
{name: "sigma.dtrip", value: "sigma.dtrip", meta: "Π {A : Type} {B : A → Type} {C : Π (a : A), B a → Type} (a : A) (b : B a), C a b → sigma (λ (a : A), sigma (λ (a_1 : B a), C a a_1))"},
{name: "sigma.dpr1", value: "sigma.dpr1", meta: "Π {A : Type} {B : A → Type}, sigma (λ (a : A), B a) → A"},
{name: "tactic.repeat1", value: "tactic.repeat1", meta: "tactic → tactic"},
{name: "tactic.try_for", value: "tactic.try_for", meta: "tactic → num → tactic"},
{name: "tactic.rec", value: "tactic.rec", meta: "Π {C : tactic → Type}, C tactic.builtin → (Π (n : tactic), C n)"},
{name: "tactic.par", value: "tactic.par", meta: "tactic → tactic → tactic"},
{name: "tactic.focus", value: "tactic.focus", meta: "tactic → tactic"},
{name: "tactic.exact", value: "tactic.exact", meta: "Π {B : Type}, B → tactic"},
{name: "tactic.id", value: "tactic.id", meta: "tactic"},
{name: "tactic.and_then", value: "tactic.and_then", meta: "tactic → tactic → tactic"},
{name: "tactic.interleave", value: "tactic.interleave", meta: "tactic → tactic → tactic"},
{name: "tactic.beta", value: "tactic.beta", meta: "tactic"},
{name: "tactic.at_most", value: "tactic.at_most", meta: "tactic → num → tactic"},
{name: "tactic.unfold", value: "tactic.unfold", meta: "Π {B : Type}, B → tactic"},
{name: "tactic", value: "tactic", meta: "Type"},
{name: "tactic.append", value: "tactic.append", meta: "tactic → tactic → tactic"},
{name: "tactic.discard", value: "tactic.discard", meta: "tactic → num → tactic"},
{name: "tactic.state", value: "tactic.state", meta: "tactic"},
{name: "tactic.now", value: "tactic.now", meta: "tactic"},
{name: "tactic.assumption", value: "tactic.assumption", meta: "tactic"},
{name: "tactic.or_else", value: "tactic.or_else", meta: "tactic → tactic → tactic"},
{name: "tactic.apply", value: "tactic.apply", meta: "Π {B : Type}, B → tactic"},
{name: "tactic.builtin", value: "tactic.builtin", meta: "tactic"},
{name: "tactic.repeat", value: "tactic.repeat", meta: "tactic → tactic"},
{name: "tactic.focus_at", value: "tactic.focus_at", meta: "tactic → num → tactic"},
{name: "tactic.trace", value: "tactic.trace", meta: "string → tactic"},
{name: "tactic.fail", value: "tactic.fail", meta: "tactic"},
{name: "tactic.determ", value: "tactic.determ", meta: "tactic → tactic"},
{name: "tactic.fixpoint", value: "tactic.fixpoint", meta: "(tactic → tactic) → tactic"},
{name: "tactic.eassumption", value: "tactic.eassumption", meta: "tactic"},
{name: "tactic.try", value: "tactic.try", meta: "tactic → tactic"},
{name: "helper_tactics.apply_refl", value: "helper_tactics.apply_refl", meta: "tactic"},
{name: "fake_simplifier.simp", value: "fake_simplifier.simp", meta: "tactic"},
{name: "binary.associative", value: "binary.associative", meta: "Π {A : Type}, (A → A → A) → Prop"},
{name: "binary.commutative", value: "binary.commutative", meta: "Π {A : Type}, (A → A → A) → Prop"},
{name: "binary.right_comm", value: "binary.right_comm", meta: "∀ {A : Type} {f : A → A → A}, binary.commutative f → binary.associative f → (∀ (a b c : A), eq (f (f a b) c) (f (f a c) b))"},
{name: "binary.assoc4helper", value: "binary.assoc4helper", meta: "∀ {A : Type} {f : A → A → A}, binary.associative f → (∀ (a b c d : A), eq (f (f a b) (f c d)) (f a (f (f b c) d)))"},
{name: "binary.left_comm", value: "binary.left_comm", meta: "∀ {A : Type} {f : A → A → A}, binary.commutative f → binary.associative f → (∀ (a b c : A), eq (f a (f b c)) (f b (f a c)))"},
{name: "wf_induction", value: "wf_induction", meta: "∀ {A : Type} {R : A → A → Prop} {P : A → Prop}, wf R → (∀ (x : A), (∀ (y : A), R y x → P y) → P x) → (∀ (x : A), P x)"},
{name: "wf", value: "wf", meta: "Π {A : Type}, (A → A → Prop) → Prop"},
{name: "relation.is_equivalence.rec", value: "relation.is_equivalence.rec", meta: "Π {T : Type} {R : T → T → Type} {C : Type}, (relation.is_reflexive R → relation.is_symmetric R → relation.is_transitive R → C) → relation.is_equivalence R → C"},
{name: "relation.is_reflexive.mk", value: "relation.is_reflexive.mk", meta: "∀ {T : Type} {R : T → T → Type}, relation.reflexive R → relation.is_reflexive R"},
{name: "relation.is_equivalence.mk", value: "relation.is_equivalence.mk", meta: "∀ {T : Type} {R : T → T → Type}, relation.is_reflexive R → relation.is_symmetric R → relation.is_transitive R → relation.is_equivalence R"},
{name: "relation.symmetric", value: "relation.symmetric", meta: "Π {T : Type}, (T → T → Type) → Type"},
{name: "relation.is_PER.is_symmetric", value: "relation.is_PER.is_symmetric", meta: "∀ {T : Type} {R : T → T → Type} {C : relation.is_PER R}, relation.is_symmetric R"},
{name: "relation.mp_like.infer", value: "relation.mp_like.infer", meta: "Π ⦃R : Type → Type → Prop⦄ {a : Type} {b : Type} (H : R a b) {C : relation.mp_like H}, a → b"},
{name: "relation.is_PER", value: "relation.is_PER", meta: "Π {T : Type}, (T → T → Type) → Prop"},
{name: "relation.rel_trans", value: "relation.rel_trans", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_transitive R], relation.transitive R"},
{name: "relation.mp_like.mk", value: "relation.mp_like.mk", meta: "Π {R : Type → Type → Prop} {a : Type} {b : Type} {H : R a b}, (a → b) → relation.mp_like H"},
{name: "relation.is_reflexive.infer", value: "relation.is_reflexive.infer", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_reflexive R], relation.reflexive R"},
{name: "relation.is_symmetric.rec", value: "relation.is_symmetric.rec", meta: "∀ {T : Type} {R : T → T → Type} {C : Prop}, (relation.symmetric R → C) → relation.is_symmetric R → C"},
{name: "relation.is_equivalence", value: "relation.is_equivalence", meta: "Π {T : Type}, (T → T → Type) → Prop"},
{name: "relation.congruence.app2", value: "relation.congruence.app2", meta: "∀ {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {T3 : Type} {R3 : T3 → T3 → Prop} {f : T1 → T2 → T3}, relation.congruence2 R1 R2 R3 f → (∀ ⦃x1 y1 : T1⦄ ⦃x2 y2 : T2⦄, R1 x1 y1 → R2 x2 y2 → R3 (f x1 x2) (f y1 y2))"},
{name: "relation.congruence.rec", value: "relation.congruence.rec", meta: "Π {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {f : T1 → T2} {C : Type}, ((∀ (x y : T1), R1 x y → R2 (f x) (f y)) → C) → relation.congruence R1 R2 f → C"},
{name: "relation.is_PER.mk", value: "relation.is_PER.mk", meta: "∀ {T : Type} {R : T → T → Type}, relation.is_symmetric R → relation.is_transitive R → relation.is_PER R"},
{name: "relation.is_transitive.infer", value: "relation.is_transitive.infer", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_transitive R], relation.transitive R"},
{name: "relation.is_equivalence.is_transitive", value: "relation.is_equivalence.is_transitive", meta: "∀ {T : Type} {R : T → T → Type} {C : relation.is_equivalence R}, relation.is_transitive R"},
{name: "relation.is_PER.is_transitive", value: "relation.is_PER.is_transitive", meta: "∀ {T : Type} {R : T → T → Type} {C : relation.is_PER R}, relation.is_transitive R"},
{name: "relation.rel_refl", value: "relation.rel_refl", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_reflexive R], relation.reflexive R"},
{name: "relation.congruence2.rec", value: "relation.congruence2.rec", meta: "Π {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {T3 : Type} {R3 : T3 → T3 → Prop} {f : T1 → T2 → T3} {C : Type}, ((∀ (x1 y1 : T1) (x2 y2 : T2), R1 x1 y1 → R2 x2 y2 → R3 (f x1 x2) (f y1 y2)) → C) → relation.congruence2 R1 R2 R3 f → C"},
{name: "relation.is_reflexive.rec", value: "relation.is_reflexive.rec", meta: "∀ {T : Type} {R : T → T → Type} {C : Prop}, (relation.reflexive R → C) → relation.is_reflexive R → C"},
{name: "relation.mp_like", value: "relation.mp_like", meta: "Π {R : Type → Type → Prop} {a : Type} {b : Type}, R a b → Type"},
{name: "relation.rel_mp", value: "relation.rel_mp", meta: "Π ⦃R : Type → Type → Prop⦄ {a : Type} {b : Type} (H : R a b) {C : relation.mp_like H}, a → b"},
{name: "relation.congruence.compose21", value: "relation.congruence.compose21", meta: "∀ {T2 : Type} {R2 : T2 → T2 → Prop} {T3 : Type} {R3 : T3 → T3 → Prop} {T4 : Type} {R4 : T4 → T4 → Prop} {g : T2 → T3 → T4}, relation.congruence2 R2 R3 R4 g → (∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f1 : T1 → T2}, relation.congruence R1 R2 f1 → (∀ {f2 : T1 → T3}, relation.congruence R1 R3 f2 → relation.congruence R1 R4 (λ (x : T1), g (f1 x) (f2 x))))"},
{name: "relation.is_reflexive", value: "relation.is_reflexive", meta: "Π {T : Type}, (T → T → Type) → Prop"},
{name: "relation.is_symmetric.app", value: "relation.is_symmetric.app", meta: "∀ ⦃T : Type⦄ {R : T → T → Prop}, relation.is_symmetric R → relation.symmetric R"},
{name: "relation.is_equivalence.is_reflexive", value: "relation.is_equivalence.is_reflexive", meta: "∀ {T : Type} (R : T → T → Type) {C : relation.is_equivalence R}, relation.is_reflexive R"},
{name: "relation.mp_like.app", value: "relation.mp_like.app", meta: "Π {R : Type → Type → Prop} {a : Type} {b : Type} {H : R a b}, relation.mp_like H → a → b"},
{name: "relation.is_transitive.rec", value: "relation.is_transitive.rec", meta: "∀ {T : Type} {R : T → T → Type} {C : Prop}, (relation.transitive R → C) → relation.is_transitive R → C"},
{name: "relation.congruence_trivial", value: "relation.congruence_trivial", meta: "∀ {T : Type} (R : T → T → Prop), relation.congruence R R (λ (u : T), u)"},
{name: "relation.rel_symm", value: "relation.rel_symm", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_symmetric R], relation.symmetric R"},
{name: "relation.is_transitive.mk", value: "relation.is_transitive.mk", meta: "∀ {T : Type} {R : T → T → Type}, relation.transitive R → relation.is_transitive R"},
{name: "relation.is_symmetric.mk", value: "relation.is_symmetric.mk", meta: "∀ {T : Type} {R : T → T → Type}, relation.symmetric R → relation.is_symmetric R"},
{name: "relation.congruence.const", value: "relation.congruence.const", meta: "∀ {T2 : Type} (R2 : T2 → T2 → Prop), relation.reflexive R2 → (∀ ⦃T1 : Type⦄ (R1 : T1 → T1 → Prop) (c : T2), relation.congruence R1 R2 (λ (u : T1), c))"},
{name: "relation.congruence_const", value: "relation.congruence_const", meta: "∀ {T2 : Type} (R2 : T2 → T2 → Prop) [C : relation.is_reflexive R2] ⦃T1 : Type⦄ (R1 : T1 → T1 → Prop) (c : T2), relation.congruence R1 R2 (λ (u : T1), c)"},
{name: "relation.is_symmetric.infer", value: "relation.is_symmetric.infer", meta: "∀ ⦃T : Type⦄ (R : T → T → Prop) [C : relation.is_symmetric R], relation.symmetric R"},
{name: "relation.congruence", value: "relation.congruence", meta: "Π {T1 : Type}, (T1 → T1 → Prop) → (Π {T2 : Type}, (T2 → T2 → Prop) → (T1 → T2) → Prop)"},
{name: "relation.transitive", value: "relation.transitive", meta: "Π {T : Type}, (T → T → Type) → Type"},
{name: "relation.is_equivalence.is_symmetric", value: "relation.is_equivalence.is_symmetric", meta: "∀ {T : Type} {R : T → T → Type} {C : relation.is_equivalence R}, relation.is_symmetric R"},
{name: "relation.mp_like.rec", value: "relation.mp_like.rec", meta: "Π {R : Type → Type → Prop} {a : Type} {b : Type} {H : R a b} {C : relation.mp_like H → Type}, (Π (a_1 : a → b), C (relation.mp_like.mk a_1)) → (Π (n : relation.mp_like H), C n)"},
{name: "relation.congruence2", value: "relation.congruence2", meta: "Π {T1 : Type}, (T1 → T1 → Prop) → (Π {T2 : Type}, (T2 → T2 → Prop) → (Π {T3 : Type}, (T3 → T3 → Prop) → (T1 → T2 → T3) → Prop))"},
{name: "relation.congruence.compose", value: "relation.congruence.compose", meta: "∀ {T2 : Type} {R2 : T2 → T2 → Prop} {T3 : Type} {R3 : T3 → T3 → Prop} {g : T2 → T3}, relation.congruence R2 R3 g → (∀ ⦃T1 : Type⦄ {R1 : T1 → T1 → Prop} {f : T1 → T2}, relation.congruence R1 R2 f → relation.congruence R1 R3 (λ (x : T1), g (f x)))"},
{name: "relation.is_PER.rec", value: "relation.is_PER.rec", meta: "Π {T : Type} {R : T → T → Type} {C : Type}, (relation.is_symmetric R → relation.is_transitive R → C) → relation.is_PER R → C"},
{name: "relation.is_symmetric", value: "relation.is_symmetric", meta: "Π {T : Type}, (T → T → Type) → Prop"},
{name: "relation.congruence.app", value: "relation.congruence.app", meta: "∀ {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {f : T1 → T2}, relation.congruence R1 R2 f → (∀ ⦃x y : T1⦄, R1 x y → R2 (f x) (f y))"},
{name: "relation.congruence2.mk", value: "relation.congruence2.mk", meta: "∀ {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {T3 : Type} {R3 : T3 → T3 → Prop} {f : T1 → T2 → T3}, (∀ (x1 y1 : T1) (x2 y2 : T2), R1 x1 y1 → R2 x2 y2 → R3 (f x1 x2) (f y1 y2)) → relation.congruence2 R1 R2 R3 f"},
{name: "relation.reflexive", value: "relation.reflexive", meta: "Π {T : Type}, (T → T → Type) → Type"},
{name: "relation.congruence.infer", value: "relation.congruence.infer", meta: "∀ {T1 : Type} (R1 : T1 → T1 → Prop) {T2 : Type} (R2 : T2 → T2 → Prop) (f : T1 → T2) [C : relation.congruence R1 R2 f] ⦃x y : T1⦄, R1 x y → R2 (f x) (f y)"},
{name: "relation.congruence.mk", value: "relation.congruence.mk", meta: "∀ {T1 : Type} {R1 : T1 → T1 → Prop} {T2 : Type} {R2 : T2 → T2 → Prop} {f : T1 → T2}, (∀ (x y : T1), R1 x y → R2 (f x) (f y)) → relation.congruence R1 R2 f"},
{name: "relation.is_transitive", value: "relation.is_transitive", meta: "Π {T : Type}, (T → T → Type) → Prop"},
{name: "relation.is_reflexive.app", value: "relation.is_reflexive.app", meta: "∀ ⦃T : Type⦄ {R : T → T → Prop}, relation.is_reflexive R → relation.reflexive R"},
{name: "relation.is_transitive.app", value: "relation.is_transitive.app", meta: "∀ ⦃T : Type⦄ {R : T → T → Prop}, relation.is_transitive R → relation.transitive R"},
{name: "yoneda.Hom", value: "yoneda.Hom", meta: "Π {ob : Type.{l_1}} {C : category.{l_1 l_2} ob}, functor.{(max 1 l_1) succ l_2 (max 1 l_2) l_2} (product.prod_category.{l_1 l_1 l_2 l_2} (opposite.opposite.{l_1 l_2} C) C) type_category.{l_2}"},
{name: "limits.cone", value: "limits.cone", meta: "Π {obI : Type} {ob : Type} {I : category obI} {C : category ob} {D : functor I C}, Type"},
{name: "limits.constant_diagram", value: "limits.constant_diagram", meta: "Π {obI : Type} {ob : Type} {I : category obI} {C : category ob}, ob → functor I C"},
{name: "functor.assoc", value: "functor.assoc", meta: "∀ {obA : Type} {obB : Type} {obC : Type} {obD : Type} {A : category obA} {B : category obB} {C : category obC} {D : category obD} (H : functor C D) (G : functor B C) (F : functor A B), eq (functor.compose H (functor.compose G F)) (functor.compose (functor.compose H G) F)"},
{name: "functor.id", value: "functor.id", meta: "Π {ob : Type} {C : category ob}, functor C C"},
{name: "category.left_id_unique", value: "category.left_id_unique", meta: "∀ {ob : Type} [C : category ob] {a : ob} {i : hom a a}, (∀ {b : ob} {f : hom b a}, eq (compose i f) f) → eq i id"},
{name: "category.right_id_unique", value: "category.right_id_unique", meta: "∀ {ob : Type} [C : category ob] {a : ob} {i : hom a a}, (∀ {b : ob} {f : hom a b}, eq (compose f i) f) → eq i id"},
{name: "functor.Id", value: "functor.Id", meta: "Π {C : Category}, Functor C C"},
{name: "functor.respect_comp", value: "functor.respect_comp", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D) ⦃a b c : obC⦄ (g : hom b c) (f : hom a b), eq (F (compose g f)) (compose (F g) (F f))"},
{name: "functor.Compose", value: "functor.Compose", meta: "Π {C₁ : Category} {C₂ : Category} {C₃ : Category}, Functor C₂ C₃ → Functor C₁ C₂ → Functor C₁ C₃"},
{name: "natural_transformation.assoc", value: "natural_transformation.assoc", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F₁ F₂ F₃ F₄ : functor C D} (η₃ : natural_transformation F₃ F₄) (η₂ : natural_transformation F₂ F₃) (η₁ : natural_transformation F₁ F₂), eq (natural_transformation.compose η₃ (natural_transformation.compose η₂ η₁)) (natural_transformation.compose (natural_transformation.compose η₃ η₂) η₁)"},
{name: "category.ID", value: "category.ID", meta: "Π {ob : Type} [C : category ob] (a : ob), hom a a"},
{name: "natural_transformation", value: "natural_transformation", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD}, functor C D → functor C D → Type"},
{name: "natural_transformation.ID", value: "natural_transformation.ID", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D), natural_transformation F F"},
{name: "functor.object", value: "functor.object", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD}, functor C D → obC → obD"},
{name: "functor.morphism", value: "functor.morphism", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D) {a b : obC}, hom a b → hom (F a) (F b)"},
{name: "natural_transformation.naturality", value: "natural_transformation.naturality", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F G : functor C D} (η : natural_transformation F G) {a b : obC} (f : hom a b), eq (compose (G f) (natural_transformation.natural_map η a)) (compose (natural_transformation.natural_map η b) (F f))"},
{name: "category.rec", value: "category.rec", meta: "Π {ob : Type} {C : category ob → Type}, (Π (hom : ob → ob → Type) (comp : Π ⦃a b c : ob⦄, hom b c → hom a b → hom a c) (id : Π {a : ob}, hom a a) (a : ∀ ⦃a b c d : ob⦄ {h : hom c d} {g : hom b c} {f : hom a b}, eq (comp h (comp g f)) (comp (comp h g) f)) (a_1 : ∀ ⦃a b : ob⦄ {f : hom a b}, eq (comp id f) f) (a_2 : ∀ ⦃a b : ob⦄ {f : hom a b}, eq (comp f id) f), C (mk hom comp id a a_1 a_2)) → (Π (n : category ob), C n)"},
{name: "category.mk", value: "category.mk", meta: "Π {ob : Type} (hom : ob → ob → Type) (comp : Π ⦃a b c : ob⦄, hom b c → hom a b → hom a c) (id : Π {a : ob}, hom a a), (∀ ⦃a b c d : ob⦄ {h : hom c d} {g : hom b c} {f : hom a b}, eq (comp h (comp g f)) (comp (comp h g) f)) → (∀ ⦃a b : ob⦄ {f : hom a b}, eq (comp id f) f) → (∀ ⦃a b : ob⦄ {f : hom a b}, eq (comp f id) f) → category ob"},
{name: "functor", value: "functor", meta: "Π {obC : Type} {obD : Type}, category obC → category obD → Type"},
{name: "functor.mk", value: "functor.mk", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} (obF : obC → obD) (homF : Π ⦃a b : obC⦄, hom a b → hom (obF a) (obF b)), (∀ ⦃a : obC⦄, eq (homF (ID a)) (ID (obF a))) → (∀ ⦃a b c : obC⦄ {g : hom b c} {f : hom a b}, eq (homF (compose g f)) (compose (homF g) (homF f))) → functor C D"},
{name: "category", value: "category", meta: "Type → Type"},
{name: "natural_transformation.compose", value: "natural_transformation.compose", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F G H : functor C D}, natural_transformation G H → natural_transformation F G → natural_transformation F H"},
{name: "Category.mk", value: "Category.mk", meta: "Π (ob : Type), category ob → Category"},
{name: "category.id", value: "category.id", meta: "Π {ob : Type} [C : category ob] {a : ob}, hom a a"},
{name: "category.assoc", value: "category.assoc", meta: "∀ {ob : Type} [C : category ob] ⦃a b c d : ob⦄ (h : hom c d) (g : hom b c) (f : hom a b), eq (compose h (compose g f)) (compose (compose h g) f)"},
{name: "functor.rec", value: "functor.rec", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {C_1 : functor C D → Type}, (Π (obF : obC → obD) (homF : Π ⦃a b : obC⦄, hom a b → hom (obF a) (obF b)) (a : ∀ ⦃a : obC⦄, eq (homF (ID a)) (ID (obF a))) (a_1 : ∀ ⦃a b c : obC⦄ {g : hom b c} {f : hom a b}, eq (homF (compose g f)) (compose (homF g) (homF f))), C_1 (mk obF homF a a_1)) → (Π (n : functor C D), C_1 n)"},
{name: "Functor", value: "Functor", meta: "Category → Category → Type"},
{name: "Functor.mk", value: "Functor.mk", meta: "Π {C : Category} {D : Category}, functor (category_instance C) (category_instance D) → Functor C D"},
{name: "Functor.rec", value: "Functor.rec", meta: "Π {C : Category} {D : Category} {C_1 : Functor C D → Type}, (Π (a : functor (category_instance C) (category_instance D)), C_1 (Functor.mk a)) → (Π (n : Functor C D), C_1 n)"},
{name: "category.compose", value: "category.compose", meta: "Π {ob : Type} [C : category ob] {a b c : ob}, hom b c → hom a b → hom a c"},
{name: "functor.iD", value: "functor.iD", meta: "Π (C : Category), Functor C C"},
{name: "natural_transformation.mk", value: "natural_transformation.mk", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F G : functor C D} (η : Π (a : obC), hom (F a) (G a)), (∀ {a b : obC} (f : hom a b), eq (compose (G f) (η a)) (compose (η b) (F f))) → natural_transformation F G"},
{name: "category.objects", value: "category.objects", meta: "Category → Type"},
{name: "natural_transformation.id_left", value: "natural_transformation.id_left", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F₁ F₂ : functor C D} (η : natural_transformation F₁ F₂), eq (natural_transformation.compose natural_transformation.id η) η"},
{name: "functor.Id_right", value: "functor.Id_right", meta: "∀ {C₁ : Category} {C₂ : Category} {F : Functor C₁ C₂}, eq (functor.Compose F functor.Id) F"},
{name: "Category", value: "Category", meta: "Type"},
{name: "natural_transformation.id", value: "natural_transformation.id", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F : functor C D}, natural_transformation F F"},
{name: "functor.respect_id", value: "functor.respect_id", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D) (a : obC), eq (F (ID a)) id"},
{name: "category.category_instance", value: "category.category_instance", meta: "Π (C : Category), category C"},
{name: "functor.ID", value: "functor.ID", meta: "Π {ob : Type} (C : category ob), functor C C"},
{name: "functor.id_right", value: "functor.id_right", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D), eq (functor.compose F functor.id) F"},
{name: "natural_transformation.id_right", value: "natural_transformation.id_right", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F₁ F₂ : functor C D} (η : natural_transformation F₁ F₂), eq (natural_transformation.compose η natural_transformation.id) η"},
{name: "functor.Assoc", value: "functor.Assoc", meta: "∀ {C₁ : Category} {C₂ : Category} {C₃ : Category} {C₄ : Category} (H : Functor C₃ C₄) (G : Functor C₂ C₃) (F : Functor C₁ C₂), eq (functor.Compose H (functor.Compose G F)) (functor.Compose (functor.Compose H G) F)"},
{name: "Category.rec", value: "Category.rec", meta: "Π {C : Category → Type}, (Π (ob : Type) (a : category ob), C (Category.mk ob a)) → (Π (n : Category), C n)"},
{name: "functor.Functor_functor", value: "functor.Functor_functor", meta: "Π {C₁ : Category} {C₂ : Category}, Functor C₁ C₂ → functor (category_instance C₁) (category_instance C₂)"},
{name: "functor.Id_left", value: "functor.Id_left", meta: "∀ {C₁ : Category} {C₂ : Category} (F : Functor C₁ C₂), eq (functor.Compose functor.Id F) F"},
{name: "natural_transformation.rec", value: "natural_transformation.rec", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F G : functor C D} {C_1 : natural_transformation F G → Type}, (Π (η : Π (a : obC), hom (F a) (G a)) (a : ∀ {a b : obC} (f : hom a b), eq (compose (G f) (η a)) (compose (η b) (F f))), C_1 (natural_transformation.mk η a)) → (Π (n : natural_transformation F G), C_1 n)"},
{name: "category.hom", value: "category.hom", meta: "Π {ob : Type} [C : category ob], ob → ob → Type"},
{name: "functor.compose", value: "functor.compose", meta: "Π {obC : Type} {obD : Type} {obE : Type} {C : category obC} {D : category obD} {E : category obE}, functor D E → functor C D → functor C E"},
{name: "category.id_left", value: "category.id_left", meta: "∀ {ob : Type} [C : category ob] ⦃a b : ob⦄ (f : hom a b), eq (compose id f) f"},
{name: "natural_transformation.natural_map", value: "natural_transformation.natural_map", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD} {F G : functor C D}, natural_transformation F G → (Π (a : obC), hom (F a) (G a))"},
{name: "category.id_right", value: "category.id_right", meta: "∀ {ob : Type} [C : category ob] ⦃a b : ob⦄ (f : hom a b), eq (compose f id) f"},
{name: "functor.id_left", value: "functor.id_left", meta: "∀ {obC : Type} {obD : Type} {C : category obC} {D : category obD} (F : functor C D), eq (functor.compose functor.id F) F"},
{name: "category.id_compose", value: "category.id_compose", meta: "∀ {ob : Type} [C : category ob] (a : ob), eq (compose (ID a) id) id"},
{name: "adjoint.foo", value: "adjoint.foo", meta: "Π {obC : Type} (C : category obC), functor (prod_category C C) (prod_category C C)"},
{name: "adjoint.Hom", value: "adjoint.Hom", meta: "Π {obC : Type} (C : category obC), functor (prod_category (opposite.opposite C) C) type_category"},
{name: "adjoint.adjoint", value: "adjoint.adjoint", meta: "Π {obC : Type} {obD : Type} (C : category obC) {D : category obD}, functor C D → functor D C → functor D type_category → Type"},
{name: "morphism.is_mono", value: "morphism.is_mono", meta: "Π {ob : Type} {C : category ob} {a b : ob}, hom a b → Prop"},
{name: "morphism.is_retraction", value: "morphism.is_retraction", meta: "Π {ob : Type} [C : category ob] {a b : ob}, hom a b → Type"},
{name: "morphism.id_is_mono", value: "morphism.id_is_mono", meta: "∀ {ob : Type} {C : category ob} {a : ob}, morphism.is_mono (ID a)"},
{name: "morphism.isomorphic.mk", value: "morphism.isomorphic.mk", meta: "Π {ob : Type} {C : category ob} {a b : ob} (g : hom a b) [H : morphism.is_iso g], morphism.isomorphic a b"},
{name: "morphism.is_retraction.mk", value: "morphism.is_retraction.mk", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {g : hom b a}, eq (compose f g) id → morphism.is_retraction f"},
{name: "morphism.id_is_iso", value: "morphism.id_is_iso", meta: "Π {ob : Type} [C : category ob] {a : ob}, morphism.is_iso (ID a)"},
{name: "morphism.isomorphic", value: "morphism.isomorphic", meta: "Π {ob : Type} [C : category ob], ob → ob → Type"},
{name: "morphism.retraction_is_epi", value: "morphism.retraction_is_epi", meta: "∀ {ob : Type} {C : category ob} {a b : ob} (f : hom a b) [H : morphism.is_retraction f], morphism.is_epi f"},
{name: "morphism.is_epi.mk", value: "morphism.is_epi.mk", meta: "∀ {ob : Type} {C : category ob} {a b : ob} {f : hom a b}, (∀ (c : ob) (g h : hom b c), eq (compose g f) (compose h f) → eq g h) → morphism.is_epi f"},
{name: "morphism.compose_section", value: "morphism.compose_section", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_retraction f], eq (compose f (morphism.section_of f)) id"},
{name: "morphism.isomorphic.rec", value: "morphism.isomorphic.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {C_1 : morphism.isomorphic a b → Type}, (Π (g : hom a b) [H : morphism.is_iso g], C_1 (morphism.isomorphic.mk g)) → (Π (n : morphism.isomorphic a b), C_1 n)"},
{name: "morphism.is_epi", value: "morphism.is_epi", meta: "Π {ob : Type} {C : category ob} {a b : ob}, hom a b → Prop"},
{name: "morphism.isomorphic.refl", value: "morphism.isomorphic.refl", meta: "Π {ob : Type} {C : category ob} (a : ob), morphism.isomorphic a a"},
{name: "morphism.isomorphic.trans", value: "morphism.isomorphic.trans", meta: "Π {ob : Type} {C : category ob} ⦃a b c : ob⦄, morphism.isomorphic a b → morphism.isomorphic b c → morphism.isomorphic a c"},
{name: "morphism.is_section.rec", value: "morphism.is_section.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {C_1 : morphism.is_section f → Type}, (Π {g : hom b a} (a_1 : eq (compose g f) id), C_1 (morphism.is_section.mk a_1)) → (Π (n : morphism.is_section f), C_1 n)"},
{name: "morphism.isomorphic.is_equivalence_eq", value: "morphism.isomorphic.is_equivalence_eq", meta: "∀ {ob : Type} {C : category ob}, Type → relation.is_equivalence morphism.isomorphic"},
{name: "morphism.iso.moveR_V1", value: "morphism.iso.moveR_V1", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {q : hom b c} {h : hom c b} [Hq : morphism.is_iso q], eq id (compose q h) → eq (morphism.inverse q) h"},
{name: "morphism.composition_is_retraction", value: "morphism.composition_is_retraction", meta: "Π {ob : Type} [C : category ob] {a b c : ob} {g : hom b c} {f : hom a b}, morphism.is_retraction f → morphism.is_retraction g → morphism.is_retraction (compose g f)"},
{name: "morphism.inverse_eq_intro_right", value: "morphism.inverse_eq_intro_right", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} {i : hom b a} [H : morphism.is_iso f], eq (compose f i) id → eq (morphism.inverse f) i"},
{name: "morphism.iso.moveR_1V", value: "morphism.iso.moveR_1V", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {q : hom b c} {h : hom c b} [Hq : morphism.is_iso q], eq id (compose h q) → eq (morphism.inverse q) h"},
{name: "morphism.composition_is_epi", value: "morphism.composition_is_epi", meta: "∀ {ob : Type} {C : category ob} {a b c : ob} {g : hom b c} {f : hom a b} [Hf : morphism.is_epi f] [Hg : morphism.is_epi g], morphism.is_epi (compose g f)"},
{name: "morphism.section_eq_intro", value: "morphism.section_eq_intro", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} {i : hom b a} [H : morphism.is_retraction f], eq (compose i f) id → eq (morphism.section_of f) i"},
{name: "morphism.iso.inv_Vp", value: "morphism.iso.inv_Vp", meta: "∀ {ob : Type} [C : category ob] {b c d : ob} (q : hom b c) (g : hom d c) [Hq : morphism.is_iso q] [H' : morphism.is_iso g], eq (morphism.inverse (compose (morphism.inverse q) g)) (compose (morphism.inverse g) q)"},
{name: "morphism.inverse_compose", value: "morphism.inverse_compose", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], eq (compose (morphism.inverse f) f) id"},
{name: "morphism.epi_elim", value: "morphism.epi_elim", meta: "∀ {ob : Type} {C : category ob} {a b c : ob} {f : hom a b} [H : morphism.is_epi f] {g h : hom b c}, eq (compose g f) (compose h f) → eq g h"},
{name: "morphism.left_inverse_eq_right_inverse", value: "morphism.left_inverse_eq_right_inverse", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} {g g' : hom b a}, eq (compose g f) id → eq (compose f g') id → eq g g'"},
{name: "morphism.inverse_is_iso", value: "morphism.inverse_is_iso", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], morphism.is_iso (morphism.inverse f)"},
{name: "morphism.retraction_of_id", value: "morphism.retraction_of_id", meta: "∀ {ob : Type} [C : category ob] {a : ob}, eq (morphism.retraction_of (ID a)) id"},
{name: "morphism.iso.moveL_Vp", value: "morphism.iso.moveL_Vp", meta: "∀ {ob : Type} {C : category ob} {c b a : ob} {q : hom b c} {p : hom a b} {z : hom a c} [Hq : morphism.is_iso q], eq (compose q p) z → eq p (compose (morphism.inverse q) z)"},
{name: "morphism.inverse_unique", value: "morphism.inverse_unique", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} (H H' : morphism.is_iso f), eq (morphism.inverse f) (morphism.inverse f)"},
{name: "morphism.iso.compose_V_pp", value: "morphism.iso.compose_V_pp", meta: "∀ {ob : Type} [C : category ob] {a b c : ob} (q : hom b c) (p : hom a b) [Hq : morphism.is_iso q], eq (compose (morphism.inverse q) (compose q p)) p"},
{name: "morphism.iso.moveL_pV", value: "morphism.iso.moveL_pV", meta: "∀ {ob : Type} {C : category ob} {d c b : ob} {r : hom c d} {q : hom b c} {x : hom b d} [Hq : morphism.is_iso q], eq (compose r q) x → eq r (compose x (morphism.inverse q))"},
{name: "morphism.is_mono.mk", value: "morphism.is_mono.mk", meta: "∀ {ob : Type} {C : category ob} {a b : ob} {f : hom a b}, (∀ (c : ob) (g h : hom c a), eq (compose f g) (compose f h) → eq g h) → morphism.is_mono f"},
{name: "morphism.iso.inv_VV", value: "morphism.iso.inv_VV", meta: "∀ {ob : Type} [C : category ob] {b c d : ob} (r : hom c d) (q : hom b c) [Hq : morphism.is_iso q] [H' : morphism.is_iso r], eq (morphism.inverse (compose (morphism.inverse q) (morphism.inverse r))) (compose r q)"},
{name: "morphism.iso.moveL_V1", value: "morphism.iso.moveL_V1", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {q : hom b c} {h : hom c b} [Hq : morphism.is_iso q], eq (compose q h) id → eq h (morphism.inverse q)"},
{name: "morphism.iso.compose_Vp", value: "morphism.iso.compose_Vp", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], eq (compose (morphism.inverse f) f) id"},
{name: "morphism.iso.moveL_1M", value: "morphism.iso.moveL_1M", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {i q : hom b c} [Hq : morphism.is_iso q], eq (compose i (morphism.inverse q)) id → eq i q"},
{name: "morphism.iso.compose_pp_V", value: "morphism.iso.compose_pp_V", meta: "∀ {ob : Type} [C : category ob] {b c d : ob} (r : hom c d) (q : hom b c) [Hq : morphism.is_iso q], eq (compose (compose r q) (morphism.inverse q)) r"},
{name: "morphism.is_epi.rec", value: "morphism.is_epi.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {C_1 : Type}, ((∀ (c : ob) (g h : hom b c), eq (compose g f) (compose h f) → eq g h) → C_1) → morphism.is_epi f → C_1"},
{name: "morphism.section_eq_retraction", value: "morphism.section_eq_retraction", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [Hl : morphism.is_section f] [Hr : morphism.is_retraction f], eq (morphism.retraction_of f) (morphism.section_of f)"},
{name: "morphism.composition_is_inverse", value: "morphism.composition_is_inverse", meta: "Π {ob : Type} [C : category ob] {a b c : ob} {g : hom b c} {f : hom a b}, morphism.is_iso f → morphism.is_iso g → morphism.is_iso (compose g f)"},
{name: "morphism.mono_elim", value: "morphism.mono_elim", meta: "∀ {ob : Type} {C : category ob} {a b c : ob} {f : hom a b} [H : morphism.is_mono f] {g h : hom c a}, eq (compose f g) (compose f h) → eq g h"},
{name: "morphism.is_section", value: "morphism.is_section", meta: "Π {ob : Type} [C : category ob] {a b : ob}, hom a b → Type"},
{name: "morphism.iso_imp_section", value: "morphism.iso_imp_section", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], morphism.is_retraction f"},
{name: "morphism.iso.moveR_Mp", value: "morphism.iso.moveR_Mp", meta: "∀ {ob : Type} {C : category ob} {d c b : ob} {q : hom b c} {g : hom d c} {y : hom d b} [Hq : morphism.is_iso q], eq y (compose (morphism.inverse q) g) → eq (compose q y) g"},
{name: "morphism.composition_is_section", value: "morphism.composition_is_section", meta: "Π {ob : Type} [C : category ob] {a b c : ob} {g : hom b c} {f : hom a b} [Hf : morphism.is_section f] [Hg : morphism.is_section g], morphism.is_section (compose g f)"},
{name: "morphism.iso.inv_pV", value: "morphism.iso.inv_pV", meta: "∀ {ob : Type} [C : category ob] {a b c : ob} (f : hom b a) (q : hom b c) [Hq : morphism.is_iso q] [H' : morphism.is_iso f], eq (morphism.inverse (compose q (morphism.inverse f))) (compose f (morphism.inverse q))"},
{name: "morphism.iso.moveR_1M", value: "morphism.iso.moveR_1M", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {i q : hom b c} [Hq : morphism.is_iso q], eq id (compose i (morphism.inverse q)) → eq q i"},
{name: "morphism.isomorphic.is_iso", value: "morphism.isomorphic.is_iso", meta: "Π {ob : Type} {C : category ob} {a b : ob} (H : morphism.isomorphic a b), morphism.is_iso (morphism.isomorphic.iso H)"},
{name: "morphism.section_of", value: "morphism.section_of", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_retraction f], hom b a"},
{name: "morphism.iso.compose_pV_p", value: "morphism.iso.compose_pV_p", meta: "∀ {ob : Type} [C : category ob] {a b c : ob} (f : hom b a) (q : hom b c) [Hq : morphism.is_iso q], eq (compose (compose f (morphism.inverse q)) q) f"},
{name: "morphism.id_is_epi", value: "morphism.id_is_epi", meta: "∀ {ob : Type} {C : category ob} {a : ob}, morphism.is_epi (ID a)"},
{name: "morphism.iso.moveL_Mp", value: "morphism.iso.moveL_Mp", meta: "∀ {ob : Type} {C : category ob} {d c b : ob} {q : hom b c} {g : hom d c} {y : hom d b} [Hq : morphism.is_iso q], eq (compose (morphism.inverse q) g) y → eq g (compose q y)"},
{name: "morphism.iso_of_id", value: "morphism.iso_of_id", meta: "∀ {ob : Type} [C : category ob] {a : ob}, eq (morphism.inverse (ID a)) id"},
{name: "morphism.iso.compose_p_Vp", value: "morphism.iso.compose_p_Vp", meta: "∀ {ob : Type} [C : category ob] {b c d : ob} (q : hom b c) (g : hom d c) [Hq : morphism.is_iso q], eq (compose q (compose (morphism.inverse q) g)) g"},
{name: "morphism.iso.moveL_pM", value: "morphism.iso.moveL_pM", meta: "∀ {ob : Type} {C : category ob} {c b a : ob} {f : hom b a} {q : hom b c} {w : hom c a} [Hq : morphism.is_iso q], eq (compose f (morphism.inverse q)) w → eq f (compose w q)"},
{name: "morphism.inverse", value: "morphism.inverse", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], hom b a"},
{name: "morphism.compose_inverse", value: "morphism.compose_inverse", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], eq (compose f (morphism.inverse f)) id"},
{name: "morphism.isomorphic.iso", value: "morphism.isomorphic.iso", meta: "Π {ob : Type} {C : category ob} {a b : ob}, morphism.isomorphic a b → hom a b"},
{name: "morphism.isomorphic.symm", value: "morphism.isomorphic.symm", meta: "Π {ob : Type} {C : category ob} ⦃a b : ob⦄, morphism.isomorphic a b → morphism.isomorphic b a"},
{name: "morphism.iso.compose_pV", value: "morphism.iso.compose_pV", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], eq (compose f (morphism.inverse f)) id"},
{name: "morphism.iso.moveR_pM", value: "morphism.iso.moveR_pM", meta: "∀ {ob : Type} {C : category ob} {c b a : ob} {f : hom b a} {q : hom b c} {w : hom c a} [Hq : morphism.is_iso q], eq w (compose f (morphism.inverse q)) → eq (compose w q) f"},
{name: "morphism.is_section.mk", value: "morphism.is_section.mk", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {g : hom b a}, eq (compose g f) id → morphism.is_section f"},
{name: "morphism.section_is_mono", value: "morphism.section_is_mono", meta: "∀ {ob : Type} {C : category ob} {a b : ob} (f : hom a b) [H : morphism.is_section f], morphism.is_mono f"},
{name: "morphism.iso.inv_pp", value: "morphism.iso.inv_pp", meta: "∀ {ob : Type} [C : category ob] {a b c : ob} (q : hom b c) (p : hom a b) [Hq : morphism.is_iso q] [H' : morphism.is_iso p], eq (morphism.inverse (compose q p)) (compose (morphism.inverse p) (morphism.inverse q))"},
{name: "morphism.iso.moveR_M1", value: "morphism.iso.moveR_M1", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {i q : hom b c} [Hq : morphism.is_iso q], eq id (compose (morphism.inverse q) i) → eq q i"},
{name: "morphism.retraction_eq_intro", value: "morphism.retraction_eq_intro", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} {i : hom b a} [H : morphism.is_section f], eq (compose f i) id → eq (morphism.retraction_of f) i"},
{name: "morphism.is_iso", value: "morphism.is_iso", meta: "Π {ob : Type} [C : category ob] {a b : ob}, hom a b → Type"},
{name: "morphism.inverse_eq_intro_left", value: "morphism.inverse_eq_intro_left", meta: "∀ {ob : Type} [C : category ob] {a b : ob} {f : hom a b} {i : hom b a} [H : morphism.is_iso f], eq (compose i f) id → eq (morphism.inverse f) i"},
{name: "morphism.retraction_of", value: "morphism.retraction_of", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_section f], hom b a"},
{name: "morphism.inverse_involutive", value: "morphism.inverse_involutive", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], eq (morphism.inverse (morphism.inverse f)) f"},
{name: "morphism.is_iso.mk", value: "morphism.is_iso.mk", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {g : hom b a}, eq (compose g f) id → eq (compose f g) id → morphism.is_iso f"},
{name: "morphism.is_retraction.rec", value: "morphism.is_retraction.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {C_1 : morphism.is_retraction f → Type}, (Π {g : hom b a} (a_1 : eq (compose f g) id), C_1 (morphism.is_retraction.mk a_1)) → (Π (n : morphism.is_retraction f), C_1 n)"},
{name: "morphism.composition_is_mono", value: "morphism.composition_is_mono", meta: "∀ {ob : Type} {C : category ob} {a b c : ob} {g : hom b c} {f : hom a b} [Hf : morphism.is_mono f] [Hg : morphism.is_mono g], morphism.is_mono (compose g f)"},
{name: "morphism.is_iso.rec", value: "morphism.is_iso.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {C_1 : morphism.is_iso f → Type}, (Π {g : hom b a} (a_1 : eq (compose g f) id) (a_2 : eq (compose f g) id), C_1 (morphism.is_iso.mk a_1 a_2)) → (Π (n : morphism.is_iso f), C_1 n)"},
{name: "morphism.is_mono.rec", value: "morphism.is_mono.rec", meta: "Π {ob : Type} {C : category ob} {a b : ob} {f : hom a b} {C_1 : Type}, ((∀ (c : ob) (g h : hom c a), eq (compose f g) (compose f h) → eq g h) → C_1) → morphism.is_mono f → C_1"},
{name: "morphism.retraction_compose", value: "morphism.retraction_compose", meta: "∀ {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_section f], eq (compose (morphism.retraction_of f) f) id"},
{name: "morphism.iso.moveR_Vp", value: "morphism.iso.moveR_Vp", meta: "∀ {ob : Type} {C : category ob} {c b a : ob} {q : hom b c} {p : hom a b} {z : hom a c} [Hq : morphism.is_iso q], eq z (compose q p) → eq (compose (morphism.inverse q) z) p"},
{name: "morphism.iso_imp_retraction", value: "morphism.iso_imp_retraction", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [H : morphism.is_iso f], morphism.is_section f"},
{name: "morphism.iso.moveL_1V", value: "morphism.iso.moveL_1V", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {q : hom b c} {h : hom c b} [Hq : morphism.is_iso q], eq (compose h q) id → eq h (morphism.inverse q)"},
{name: "morphism.section_of_id", value: "morphism.section_of_id", meta: "∀ {ob : Type} [C : category ob] {a : ob}, eq (morphism.section_of (ID a)) id"},
{name: "morphism.section_retraction_imp_iso", value: "morphism.section_retraction_imp_iso", meta: "Π {ob : Type} [C : category ob] {a b : ob} (f : hom a b) [Hl : morphism.is_section f] [Hr : morphism.is_retraction f], morphism.is_iso f"},
{name: "morphism.iso.moveL_M1", value: "morphism.iso.moveL_M1", meta: "∀ {ob : Type} {C : category ob} {c b : ob} {i q : hom b c} [Hq : morphism.is_iso q], eq (compose (morphism.inverse q) i) id → eq i q"},
{name: "morphism.iso.moveR_pV", value: "morphism.iso.moveR_pV", meta: "∀ {ob : Type} {C : category ob} {d c b : ob} {r : hom c d} {q : hom b c} {x : hom b d} [Hq : morphism.is_iso q], eq x (compose r q) → eq (compose x (morphism.inverse q)) r"},
{name: "category.product.prod_category", value: "category.product.prod_category", meta: "Π {obC : Type} {obD : Type}, category obC → category obD → category (prod obC obD)"},
{name: "category.slice.forgetful", value: "category.slice.forgetful", meta: "Π {ob : Type} (C : category ob) (x : ob), functor (category.slice_category C x) C"},
{name: "category.hom_dst", value: "category.hom_dst", meta: "Π {ob : Type} {C : category ob} {a b : category.arrow_obs ob C}, category.arrow_hom a b → category.hom (category.dst a) (category.dst b)"},
{name: "category.set_compose", value: "category.set_compose", meta: "Π {A : Type} [H : decidable_eq A] {a b c : A}, category.set_hom b c → category.set_hom a b → category.set_hom a c"},
{name: "category.opposite.Opposite", value: "category.opposite.Opposite", meta: "Category → Category"},
{name: "category.category_one", value: "category.category_one", meta: "category unit"},
{name: "category.product.prod_functor", value: "category.product.prod_functor", meta: "Π {obC : Type} {obC' : Type} {obD : Type} {obD' : Type} {C : category obC} {C' : category obC'} {D : category obD} {D' : category obD'}, functor C D → functor C' D' → functor (category.product.prod_category C C') (category.product.prod_category D D')"},
{name: "category.opposite.opposite_functor", value: "category.opposite.opposite_functor", meta: "Π {obC : Type} {obD : Type} {C : category obC} {D : category obD}, functor C D → functor (category.opposite.opposite C) (category.opposite.opposite D)"},
{name: "category.slice.composition_functor", value: "category.slice.composition_functor", meta: "Π {ob : Type} (C : category ob) {x y : ob}, category.hom x y → functor (category.slice_category C x) (category.slice_category C y)"},
{name: "category.opposite.op_op", value: "category.opposite.op_op", meta: "∀ {ob : Type} {C : category ob}, eq (category.opposite.opposite (category.opposite.opposite C)) C"},
{name: "category.category_of_categories", value: "category.category_of_categories", meta: "category Category"},
{name: "category.set_hom_subsingleton", value: "category.set_hom_subsingleton", meta: "∀ {A : Type} [H : decidable_eq A] (a b : A), subsingleton (category.set_hom a b)"},
{name: "category.arrow_hom", value: "category.arrow_hom", meta: "Π {ob : Type} {C : category ob}, category.arrow_obs ob C → category.arrow_obs ob C → Type"},
{name: "category.set_hom", value: "category.set_hom", meta: "Π {A : Type} [H : decidable_eq A], A → A → Type"},
{name: "category.slice_category", value: "category.slice_category", meta: "Π {ob : Type} (C : category ob) (c : ob), category (sigma (λ (b : ob), category.hom b c))"},
{name: "category.opposite.opposite", value: "category.opposite.opposite", meta: "Π {ob : Type}, category ob → category ob"},
{name: "category.functor_category", value: "category.functor_category", meta: "Π {obC : Type} {obD : Type} (C : category obC) (D : category obD), category (functor C D)"},
{name: "category.src", value: "category.src", meta: "Π {ob : Type} {C : category ob}, category.arrow_obs ob C → ob"},
{name: "category.arrow_obs", value: "category.arrow_obs", meta: "Π (ob : Type), category ob → Type"},
{name: "category.set_category", value: "category.set_category", meta: "Π {A : Type} [H : decidable_eq A] (A : Type) [H : decidable_eq A], category A"},
{name: "category.commute", value: "category.commute", meta: "∀ {ob : Type} {C : category ob} {a b : category.arrow_obs ob C} (m : category.arrow_hom a b), eq (category.compose (category.to_hom b) (category.hom_src m)) (category.compose (category.hom_dst m) (category.to_hom a))"},
{name: "category.to_hom", value: "category.to_hom", meta: "Π {ob : Type} {C : category ob} (a : category.arrow_obs ob C), category.hom (category.src a) (category.dst a)"},
{name: "category.category_two", value: "category.category_two", meta: "category bool"},
{name: "category.coslice", value: "category.coslice", meta: "Π {ob : Type} (C : category ob) (c : ob), category (sigma (λ (b : ob), category.hom c b))"},
{name: "category.arrow", value: "category.arrow", meta: "Π (ob : Type) (C : category ob), category (category.arrow_obs ob C)"},
{name: "category.hom_src", value: "category.hom_src", meta: "Π {ob : Type} {C : category ob} {a b : category.arrow_obs ob C}, category.arrow_hom a b → category.hom (category.src a) (category.src b)"},
{name: "category.type_category", value: "category.type_category", meta: "category Type"},
{name: "category.opposite.compose_op", value: "category.opposite.compose_op", meta: "∀ {ob : Type} {C : category ob} {a b c : ob} {f : category.hom a b} {g : category.hom b c}, eq (category.compose f g) (category.compose g f)"},
{name: "category.dst", value: "category.dst", meta: "Π {ob : Type} {C : category ob}, category.arrow_obs ob C → ob"},
{name: "function.flip", value: "function.flip", meta: "Π {A : Type} {B : Type} {C : A → B → Type}, (Π (x : A) (y : B), C x y) → (Π (y : B) (x : A), C x y)"},
{name: "function.app", value: "function.app", meta: "Π {A : Type} {B : A → Type}, (Π (x : A), B x) → (Π (x : A), B x)"},
{name: "function.is_typeof", value: "function.is_typeof", meta: "Π (A : Type), A → A"},
{name: "function.compose", value: "function.compose", meta: "Π {A : Type} {B : Type} {C : Type}, (B → C) → (A → B) → A → C"},
{name: "function.dcompose", value: "function.dcompose", meta: "Π {A : Type} {B : A → Type} {C : Π {x : A}, B x → Type}, (Π {x : A} (y : B x), C y) → (Π (g : Π (x : A), B x) (x : A), C (g x))"},
{name: "function.id", value: "function.id", meta: "Π {A : Type}, A → A"},
{name: "function.combine", value: "function.combine", meta: "Π {A : Type} {B : Type} {C : Type} {D : Type} {E : Type}, (A → B → C) → (C → D → E) → (A → B → D) → A → B → E"},
{name: "function.const", value: "function.const", meta: "Π {A : Type} (B : Type), A → B → A"},
{name: "function.on_fun", value: "function.on_fun", meta: "Π {A : Type} {B : Type} {C : Type}, (B → B → C) → (A → B) → A → A → C"},
]
