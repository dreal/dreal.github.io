// Generated by CoffeeScript 1.7.1
(function() {
  var config_file, doit, gup, loadScript;

  gup = function(name) {
    var regex, regexS, results;
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    regexS = "[\\?&]" + name + "=([^&#]*)";
    regex = new RegExp(regexS);
    results = regex.exec(window.location.href);
    if (results === null) {
      return "";
    } else {
      return results[1];
    }
  };

  loadScript = function(url, callback) {
    var head, script;
    head = document.getElementsByTagName('head')[0];
    script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.onreadystatechange = callback;
    script.onload = callback;
    return head.appendChild(script);
  };

  doit = function(config) {
    var Chart, addTimeToData, animation_delay, color, contextHeight, contextWidth, createChart, height, margin, processJson, showOnly, svg, vis_data_file, width;
    vis_data_file = gup("data");
    console.log(vis_data_file);
    if (vis_data_file) {
      console.log("Loaded?");
      loadScript("benchmarks/" + vis_data_file, function() {
        return console.log("Loaded: ", config);
      });
    }
    color = d3.scale.category10();
    animation_delay = config.animation_delay;
    showOnly = function(chart, b) {
      chart.xScale.domain(b);
      chart.chartContainer.selectAll("rect").data(chart.chartData).attr("x", function(d) {
        return chart.xScale(d.domX[0]) + .5;
      }).attr("width", function(d) {
        return chart.xScale(d.domX[1]) - chart.xScale(d.domX[0]) - .5;
      });
      chart.chartContainer.selectAll("line").data(chart.chartData).attr("x1", function(d) {
        return chart.xScale(d.domX[0]) + .5;
      }).attr("x2", function(d) {
        return chart.xScale(d.domX[0]) + .5;
      });
      chart.chartContainer.selectAll("path.chart").attr("d", chart.area);
      chart.chartContainer.selectAll("path.line").attr("d", chart.line);
      if (chart.id === 0) {
        chart.chartContainer.select(".x.axis.top").call(chart.xAxisTop);
      }
      return chart.chartContainer.select(".x.axis.bottom").call(chart.xAxisBottom);
    };
    addTimeToData = function(t, item) {
      item.values = item.values.map(function(data) {
        var ret;
        ret = {};
        ret.time = [+data.time[0] + t[1], +data.time[1] + t[1]];
        ret.enclosure = data.enclosure;
        return ret;
      });
      return item;
    };
    processJson = function(json) {
      var data, groups, k, lastTime, result, trace, traces;
      groups = json.groups;
      traces = json.traces;
      result = [];
      traces.forEach(function(trace) {
        return trace.forEach(function(piece) {
          var MAX_TO_SHOW, count, divisor, k, key_strings, s, size;
          MAX_TO_SHOW = 300.0;
          if (piece.values.length > MAX_TO_SHOW) {
            count = 0;
            size = piece.values.length;
            divisor = Math.ceil(size / MAX_TO_SHOW);
            piece.values = _.filter(piece.values, function(d) {
              count = count + 1;
              return count % divisor === 1;
            });
          }
          key_strings = piece.key.split("_");
          key_strings = _.initial(key_strings);
          s = piece.step = _.last(key_strings);
          key_strings = _.initial(key_strings);
          k = piece.key = key_strings.join("_");
          if (!(k in result)) {
            result[k] = new Array();
          }
          if (!(s in result[k])) {
            result[k][s] = new Array();
          }
          result[k][s] = piece;
          return result[k].key = k;
        });
      });
      lastTime = [];
      for (k in result) {
        trace = result[k];
        _.each(trace, function(piece) {
          if (!(k in lastTime)) {
            lastTime[k] = [0.0, 0.0];
          }
          piece = addTimeToData(lastTime[k], piece);
          lastTime[k] = _.last(piece.values).time;
          return piece.domX = [
            d3.min(piece.values, function(d) {
              return d.time[0];
            }), d3.max(piece.values, function(d) {
              return d.time[1];
            })
          ];
        });
        trace.domX = [
          d3.min(trace, function(piece) {
            return piece.domX[0];
          }), d3.max(trace, function(piece) {
            return piece.domX[1];
          })
        ];
        trace.domY = [
          d3.min(trace, function(piece) {
            return d3.min(piece.values, function(d) {
              return d.enclosure[0];
            });
          }), d3.max(trace, function(piece) {
            return d3.max(piece.values, function(d) {
              return d.enclosure[1];
            });
          })
        ];
      }
      data = {};
      data.title = json.title;
      data.values = _.values(result);
      data.domX = [
        d3.min(data.values, function(trace) {
          return trace.domX[0];
        }), d3.max(data.values, function(trace) {
          return trace.domX[1];
        })
      ];
      data.domY = [
        d3.min(data.values, function(trace) {
          return trace.domY[0];
        }), d3.max(data.values, function(trace) {
          return trace.domY[1];
        })
      ];
      return data;
    };
    createChart = function(json) {
      var brush, chartHeight, charts, context, contextArea, contextAxis, contextLine, contextXScale, contextYScale, data, keys, onBrush;
      data = processJson(json);
      charts = [];
      keys = data.values.length;
      chartHeight = ((height - contextHeight) / keys) - config.inter_chart_margin;
      contextXScale = d3.scale.linear().range([0, contextWidth]).domain(data.domX);
      contextYScale = d3.scale.linear().range([contextHeight, 0]).domain(data.domY);
      contextAxis = d3.svg.axis().scale(contextXScale).tickSize(contextHeight).tickPadding(-10).orient("bottom");
      contextArea = d3.svg.area().interpolate("monotone").x0(function(p) {
        return contextXScale(p.time[0]);
      }).x1(function(p) {
        return contextXScale(p.time[1]);
      }).y0(function(p) {
        return contextYScale(p.enclosure[0]);
      }).y1(function(p) {
        return contextYScale(p.enclosure[1]);
      });
      contextLine = d3.svg.line().interpolate("monotone").x(function(p) {
        return contextXScale((p.time[0] + p.time[1]) / 2);
      }).y(function(p) {
        return contextYScale((p.enclosure[0] + p.enclosure[1]) / 2);
      });
      context = svg.append("g").attr("class", "context").attr("transform", "translate(" + (0 + margin.left) + "," + (margin.top + height - contextHeight) + ")");
      context.append("g").attr("class", "x axis top").attr("transform", "translate(0,0)").call(contextAxis);
      _.each(data.values, function(data, i) {
        return charts.push(new Chart({
          data: data,
          id: i,
          name: data.key,
          width: width,
          height: chartHeight,
          domainX: data.domainX,
          svg: svg,
          margin: margin,
          context: context,
          contextArea: contextArea,
          contextLine: contextLine
        }));
      });
      context.append("text").attr("class", "instructions").attr("transform", "translate(0," + (contextHeight + 20) + ")").text('Click and drag above to zoom / pan the data');
      onBrush = function() {
        var b, i, _i, _results;
        b = brush.empty() ? contextXScale.domain() : brush.extent();
        _results = [];
        for (i = _i = 0; _i < keys; i = _i += 1) {
          _results.push(showOnly(charts[i], b));
        }
        return _results;
      };
      brush = d3.svg.brush().x(contextXScale).on("brush", onBrush);
      return context.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("y", 0).attr("height", contextHeight);
    };
    Chart = (function() {
      function Chart(data) {
        var chart, chartContainer, maxY, minY, tickDom, tickVal, tickValCard, xS, yS;
        this.chartData = data.data;
        this.width = data.width;
        this.height = data.height;
        this.domX = data.domX;
        this.modes = data.modes;
        this.svg = data.svg;
        this.id = data.id;
        this.name = data.name;
        this.margin = data.margin;
        this.xScale = d3.scale.linear().range([0, this.width]).domain(this.chartData.domX);
        minY = d3.min(this.chartData, function(p) {
          return p.domX[0];
        });
        maxY = d3.max(this.chartData, function(p) {
          return p.domX[1];
        });
        this.yScale = d3.scale.linear().range([this.height, 0]).domain(this.chartData.domY);
        xS = this.xScale;
        yS = this.yScale;
        chart = this;
        this.line = d3.svg.line().interpolate("basis").x(function(p) {
          return xS((p.time[0] + p.time[1]) / 2);
        }).y(function(p) {
          return yS((p.enclosure[0] + p.enclosure[1]) / 2);
        });
        this.area = d3.svg.area().interpolate("basis").x0(function(p) {
          return xS(p.time[0]);
        }).x1(function(p) {
          return xS(p.time[1]);
        }).y0(function(p) {
          return yS(p.enclosure[0]);
        }).y1(function(p) {
          return yS(p.enclosure[1]);
        });
        this.svg.append("defs").append("clipPath").attr("id", "clip-" + this.id).append("rect").attr("width", this.width).attr("height", this.height);
        chartContainer = this.chartContainer = svg.append("g").attr('class', this.name.toLowerCase()).attr("transform", "translate(" + this.margin.left + "," + (this.margin.top + (this.height * this.id) + (config.inter_chart_margin * this.id)) + ")");
        this.chartContainer.selectAll("rect").data(this.chartData).enter().append("svg:rect").on("mouseover", function(d) {
          return d3.select(this).transition().style("fill-opacity", 0.5);
        }).on("mouseout", function(d) {
          return d3.select(this).transition().style("fill-opacity", 0.2);
        }).attr("x", function(d) {
          return xS(d.domX[0]) + .5;
        }).attr("y", 0).attr("height", this.height).attr("width", function(d) {
          return xS(d.domX[1]) - xS(d.domX[0]) - .5;
        }).attr("fill", function(d) {
          return d3.rgb(color(d.key)).brighter(d.mode * 2);
        }).style("fill-opacity", 0.0).transition().duration(function(d) {
          return animation_delay * (+d.step + 1);
        }).style("fill-opacity", 0.3).transition().duration(function(d) {
          return animation_delay / 10 * (+d.step + 1);
        }).style("fill-opacity", 0.2).attr("clip-path", "url(#clip-" + this.id + ")");
        this.chartContainer.selectAll("line").data(this.chartData).enter().append("svg:line").attr("x1", function(d) {
          return xS(d.domX[1]) + .5;
        }).attr("x2", function(d) {
          return xS(d.domX[1]) + .5;
        }).attr("y1", 0).attr("y2", this.height).style("stroke", "#999999").style("stroke-width", "0.5px").attr("clip-path", "url(#clip-" + this.id + ")");
        _.each(this.chartData, function(piece) {
          return chart.chartContainer.append("path").data([piece.values]).attr("class", "chart").attr("clip-path", "url(#clip-" + chart.id + ")").attr("d", chart.area).style("fill-opacity", 0.0).transition().duration(animation_delay * (+piece.step + 1)).style("fill", color(piece.key)).style("fill-opacity", 0.8);
        });
        _.each(this.chartData, function(piece) {
          return chart.chartContainer.append("path").data([piece.values]).attr("class", "line").attr("clip-path", "url(#clip-" + chart.id + ")").style("stroke", color(piece.key)).style("stroke-width", "2px").style("fill-opacity", 0.0).style("stroke-opacity", 0.0).transition().duration(animation_delay * (+piece.step + 1)).style("stroke-opacity", 1.0).attr("d", chart.line);
        });
        _.each(this.chartData, function(piece) {
          return data.context.append("path").data([piece.values]).attr("class", "chart").attr("d", data.contextArea).style("fill", "black").style("fill-opacity", 0.1);
        });
        _.each(this.chartData, function(piece) {
          return data.context.append("path").data([piece.values]).attr("d", data.contextLine).style("stroke", color(piece.key)).style("stroke-width", "2px").style("fill-opacity", 0.0);
        });
        tickVal = _.map(data.data, function(d) {
          return (d3.min(d.values, function(item) {
            return item.time[0];
          }) + d3.max(d.values, function(item) {
            return item.time[1];
          })) / 2;
        });
        tickDom = [d3.min(tickVal), d3.max(tickVal)];
        tickValCard = tickDom[1] - tickDom[0];
        if (this.id === 0) {
          this.xAxisTop = d3.svg.axis().scale(this.xScale).tickSize(0).tickValues(tickVal).tickFormat(function(n, i) {
            return "Mode" + data.data[i].mode;
          }).orient("bottom");
        }
        this.xAxisBottom = d3.svg.axis().scale(this.xScale).orient("bottom");
        if (this.id === 0) {
          this.chartContainer.append("g").attr("class", "x axis top").attr("transform", "translate(0,0)").call(this.xAxisTop);
        }
        chartContainer.append("g").attr("class", "x axis bottom").attr("transform", "translate(0," + this.height + ")").call(this.xAxisBottom);
        this.yAxis = d3.svg.axis().scale(this.yScale).orient("left").ticks(5);
        chartContainer.append("g").attr("class", "y axis").attr("transform", "translate(0,0)").call(this.yAxis);
        this.chartContainer.append("text").attr("class", "country-title").attr("transform", "translate(15,40)").text(this.name);
      }

      return Chart;

    })();
    margin = config.margin;
    width = config.width - margin.left - margin.right;
    height = config.height - margin.top - margin.bottom;
    contextHeight = config.contextHeight;
    contextWidth = width;
    svg = d3.select("#chart-container").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
    return d3.json(config.jsonfile, createChart);
  };

  config_file = gup("config");

  if (config_file) {
    loadScript("benchmarks/" + config_file, function() {
      return doit(config);
    });
  } else {
    doit(config);
  }

}).call(this);
